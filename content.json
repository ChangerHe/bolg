{"meta":{"title":"ChangerHe's Bolg|何庆畅的个人博客","subtitle":"What doesn't kill you make you stronger.","description":"何庆畅|ChangerHe|个人博客|Bolg|hexo|hexo主题","author":"ChangerHe","url":"https://github.com/ChangerHe"},"pages":[{"title":"About Me","date":"2017-06-15T02:33:19.000Z","updated":"2017-09-18T03:03:38.954Z","comments":true,"path":"about/index.html","permalink":"https://github.com/ChangerHe/about/index.html","excerpt":"","text":"基本信息姓名：何庆畅性别：男毕业院校：湖南工业大学毕业时间：2016年学历：本科目前所在城市：深圳 联系方式Phone: 13237083312WeChat: 13237083312Email: 244737162@qq.comWeibo: http://weibo.com/ChangerHeee 个人简介技能清单"},{"title":"categories","date":"2017-06-15T02:13:36.000Z","updated":"2017-06-15T02:14:09.223Z","comments":true,"path":"categories/index.html","permalink":"https://github.com/ChangerHe/categories/index.html","excerpt":"","text":""},{"title":"","date":"2017-09-18T03:03:08.116Z","updated":"2017-09-14T12:57:13.625Z","comments":true,"path":"demos/index.html","permalink":"https://github.com/ChangerHe/demos/index.html","excerpt":"","text":"lianjiedao"},{"title":"tags","date":"2017-06-15T02:13:36.000Z","updated":"2017-06-18T16:13:33.438Z","comments":true,"path":"tags/index.html","permalink":"https://github.com/ChangerHe/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"纯CSS实现元素水平垂直居中的方法","slug":"纯CSS实现元素水平垂直居中的方法","date":"2017-10-30T11:42:25.000Z","updated":"2017-10-20T09:19:30.190Z","comments":true,"path":"2017/10/30/纯CSS实现元素水平垂直居中的方法/","link":"","permalink":"https://github.com/ChangerHe/2017/10/30/纯CSS实现元素水平垂直居中的方法/","excerpt":"","text":"垂直居中是布局中十分常见的效果之一，为实现良好的兼容性，PC端实现垂直居中的方法一般是通过绝对定位，table-cell，负边距等方法。有了css3，针对移动端的垂直居中就更加多样化。 笔者在这里总结了九种使用纯CSS实现水平垂直居中的方法 OK. Let’s see it! 最开始, 我们先设置几个盒子, 设置它们的统一样式为以下 123456.box &#123; width: 300px; height: 300px; margin: 10px; box-shadow: 2px 3px 4px #000;&#125; 方法1: table-cell1234&lt;!-- HTML --&gt;&lt;div class=&quot;box box1&quot;&gt; &lt;span&gt;垂直居中&lt;/span&gt;&lt;/div&gt; 整体的结构是相当简单的, css直接设置本身的宽高, 然后设置为table-cell,并将对齐方式设置为vertic-align就可以实现水平垂直居中了 1234567/* CSS */.box1&#123; display: table-cell; vertical-align: middle; text-align: center; &#125; 实际上table-cell的兼容性也是相当不错的, 可兼容至IE8+, 相当于将这个区块设置成了一个td 方法2: display: flex;12345.box2&#123; display: flex; justify-content:center; align-items:Center;&#125; 使用flex布局就非常简单了, 只需要设置两个属性即可, 存在的问题就是兼容性很有限, 虽然非常简单, 一般使用在移动端 方法3 绝对定位和负边距这个在以前算是比较中规中矩的办法了, 首先需要将父盒子设置为相对定位, 子盒子设置为绝对定位 12345678910111213.box3 &#123; position:relative;&#125;.box3 span &#123; position: absolute; width:100px; height: 50px; top:50%; left:50%; margin-left:-50px; margin-top:-25px; text-align: center;&#125; 原理也非常简单, 将定位到中间距左部和顶部50%之后,需要减去自身的长宽的一半,就实现居中了 方法4: 绝对定位和0这种方法常用于做蒙层和遮罩效果 123456789101112.box4 span&#123; width: 50%; height: 50%; background: #000; overflow: auto; margin: auto; position: absolute; top: 0; left: 0; bottom: 0; right: 0; &#125; 利用绝对定位上下左右都设为0, 中间的子盒子设置margin为auto实现 方法5: translate 1234567891011.box6 &#123; position: relative;&#125;.box6 span &#123; position: absolute; top:50%; left:50%; width:100%; transform:translate(-50%,-50%); text-align: center;&#125; 利用CSS3的转换效果, 将自身的位置向左上分别移动了50%, 也就是自身的一半, 就实现居中了 方法6：display:inline-block12345678910111213141516.box7 &#123; text-align:center; font-size:0;&#125;.box7 span &#123; vertical-align:middle; display:inline-block; font-size:16px;&#125;.box7:after &#123; content:&apos;&apos;; width:0; height:100%; display:inline-block; vertical-align:middle;&#125; 这个方法就比较复杂一些了, 通过一个没有任何内容但高度为100%的伪类来进行占位, 根据vertical-align的特性, 来进行居中 方法7：display:flex和margin:auto1234567.box8 &#123; display: flex; text-align: center;&#125;.box8 span &#123; margin: auto;&#125; 方法8：display:-webkit-box1234567.box9 &#123; display: -webkit-box; -webkit-box-pack:center; -webkit-box-align:center; -webkit-box-orient: vertical; text-align: center&#125; 方法9：display:-webkit-box这种方法，在 content 元素外插入一个 div。设置此 div height:50%; margin-bottom:-contentheight;。 content 清除浮动，并显示在中间。 12&lt;div class=&quot;floater&quot;&gt;&lt;/div&gt; &lt;div class=&quot;content&quot;&gt; Content here &lt;/div&gt; 12345678910.floater &#123; float:left; height:50%; margin-bottom:-120px;&#125;.content &#123; clear:both; height:240px; position:relative;&#125; (后两种居中方法摘自网络)","categories":[{"name":"CSS","slug":"CSS","permalink":"https://github.com/ChangerHe/categories/CSS/"}],"tags":[{"name":"CSS","slug":"CSS","permalink":"https://github.com/ChangerHe/tags/CSS/"}]},{"title":"处理git无法上传超过100M文件的问题","slug":"处理git无法上传超过100M文件的问题","date":"2017-10-13T03:26:43.000Z","updated":"2017-10-13T11:53:08.165Z","comments":true,"path":"2017/10/13/处理git无法上传超过100M文件的问题/","link":"","permalink":"https://github.com/ChangerHe/2017/10/13/处理git无法上传超过100M文件的问题/","excerpt":"","text":"最近在项目提交分支到github的时候, 出现了一件很尴尬的事情, 文件超过100m, 被github拒绝了 宝宝心里苦, 但宝宝不说 当时也没太在意, 但是当我的当前分支提交堆积到12次的时候, 我急了 卧槽, 要是我以后都不能提交, 那得多尴尬啊 谁叫我有轻微强迫症呢 自己搞不定, 那百度啊 然后, 我百度了一圈, 更换各种搜索词, 从百度的搜索结果的第一页看到第四页, 玛德终于解决了 所以我响应祖国的号召, 坚持每年3.15打击假冒伪劣的思想, 向大家告知一下, 下面的方法 都!!!! 是!!!!! 不!!!!! 对!!!!! 的!!!!! 在这里可能有人要说了, 卧槽你整些不对的跟我说干嘛 没事, 我开心, 结尾也有正确的答案, 不想看过程直接看结果的跳到最后就好 坑爹的jar包首先引用一下前辈的话 如果做了这几步你push的时候还是报和开始的时候一样的错，那说明这个文件你不是最近一次commit时添加的，而是在之前commit过很多次了，这就需要把关于这个文件的所有历史commit记录全部清除掉，这时候我们就需要用到一个叫BFG的工具。我们要到https://rtyley.github.io/bfg-repo-cleaner/#download这个网站去下载并学习如何使用这个工具。 —— [ 来自某位不知名的大佬 ] 我去尝试下下来这个文档, 卧槽原来是一个jar包, 瞬间觉得高大上了 前辈, 您是想要我学习一下java的运行原理么? 嗯~ jar包, 可以的, 跟着前辈指示的指令一波操作 结果: 指令没卵用 使用git-lfs其实这个方法也是可行的, 因为git是专门提供了一个工具来给我们存储大容量文件的, 就是Git Large File Storage 大家有兴趣可以百度或者google一下 但问题是, 搞这个玩意儿又要下另一个版本的git, 神烦, 故跳转到下一百度词条了, 毕竟以后很少用到, 学习成本太高 这里也一样, 贴上前辈的文章链接, 有兴趣的可以学习一下 —— [ [Git] 处理 github 不允许上传超过 100MB 文件的问题 ] 修正错误?还有某前辈建议这样做 第一步输入命令 cd /Users/Dora/Desktop/XXX（cd后面的这个路径要换成你自己项目的路径），然后第二步输入命令 git rm –cached /Users/Dora/Desktop/XXX/XXX/IJKMediaFramework（加下划线部分是你自己的要移除的文件的路径），第三步输入命令 git commit –amend -CHEAD，执行完这步后，这个大文件将会从你的commit记录里移除，并且以后commit都将不会再把它commit了，这时候就可以git push把本地代码push到github上了。 —— [ Github 修正上传时“this exceeds GitHub’s file size limit of 100 MB”错误 ] 似乎~ 还是不行 正确的做法其实就代码来说, 很简单 注意一点就是, 记得在你当前本地仓库的根目录下打开git bash 否则是无效的, 别问我怎么知道的, 蓝瘦香菇 代码就只有三行, 复制粘贴就好了 12345git filter-branch --force --index-filter &quot;git rm --cached --ignore-unmatch ***&quot; --prune-empty --tag-name-filter cat -- --allgit commit --amend -CHEADgit push origin master 代码第一行中的三个*, 将它换为你之前不要提交的文件的相对路径, 然后会看到一堆的代码校验, 最后会在分支中删除掉你提交这个大文件的记录 那么最后使用git push就可以提交了, 全部搞定, 大吉大利, 今晚吃鸡 (完)","categories":[{"name":"github","slug":"github","permalink":"https://github.com/ChangerHe/categories/github/"}],"tags":[{"name":"Git","slug":"Git","permalink":"https://github.com/ChangerHe/tags/Git/"},{"name":"github","slug":"github","permalink":"https://github.com/ChangerHe/tags/github/"}]},{"title":"Angularjs的数据绑定和脏检查","slug":"Angularjs的数据绑定和脏检查","date":"2017-10-10T04:53:41.000Z","updated":"2017-10-13T12:01:38.767Z","comments":true,"path":"2017/10/10/Angularjs的数据绑定和脏检查/","link":"","permalink":"https://github.com/ChangerHe/2017/10/10/Angularjs的数据绑定和脏检查/","excerpt":"","text":"接触Angular也有一段时间了，时常问自己一些问题, 如果是我实现它，会在哪些方面选择跟它相同的道路, 哪些方面不同。为此，记录了一些思考，给自己回顾，也供他人参考。 本篇博客将分下面几个方面进行讲解 -数据双向绑定-视图模型的继承关系-模块和依赖注入的设计 数据的双向绑定Angular实现了双向绑定机制。所谓的双向绑定，无非是从界面的操作能实时反映到数据，数据的变更能实时展现到界面。 一个最简单的示例就是这样： 1234&lt;div ng-controller=&quot;CounterCtrl&quot;&gt; &lt;span ng-bind=&quot;counter&quot;&gt;&lt;/span&gt; &lt;button ng-click=&quot;counter=counter+1&quot;&gt;increase&lt;/button&gt;&lt;/div&gt; 123function CounterCtrl($scope) &#123; $scope.counter = 1;&#125; 这个例子很简单，毫无特别之处，每当点击一次按钮，界面上的数字就增加一。 绑定数据是怎样生效的初学AngularJS的人可能会踩到这样的坑，假设有一个指令： 12345678910111213var app = angular.module(&quot;test&quot;, []);app.directive(&quot;myclick&quot;, function() &#123; return function (scope, element, attr) &#123; element.on(&quot;click&quot;, function() &#123; scope.counter++; &#125;); &#125;;&#125;);app.controller(&quot;CounterCtrl&quot;, function($scope) &#123; $scope.counter = 0;&#125;); 123456&lt;body ng-app=&quot;test&quot;&gt; &lt;div ng-controller=&quot;CounterCtrl&quot;&gt; &lt;button myclick&gt;increase&lt;/button&gt; &lt;span ng-bind=&quot;counter&quot;&gt;&lt;/span&gt; &lt;/div&gt;&lt;/body&gt; 这个时候，点击按钮，界面上的数字并不会增加。很多人会感到迷惑，因为他查看调试器，发现数据确实已经增加了，Angular不是双向绑定吗，为什么数据变化了，界面没有跟着刷新？ 试试在scope.counter++;这句之后加一句scope.digest();再看看是不是好了？ 为什么要这么做呢，什么情况下要这么做呢？我们发现第一个例子中并没有digest，而且，如果你写了digest，它还会抛出异常，说正在做其他的digest，这是怎么回事？ 我们先想想，假如没有AngularJS，我们想要自己实现这么个功能，应该怎样？ 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;meta charset=&quot;utf-8&quot; /&gt; &lt;title&gt;two-way binding&lt;/title&gt; &lt;/head&gt; &lt;body onload=&quot;init()&quot;&gt; &lt;button ng-click=&quot;inc&quot;&gt; increase 1 &lt;/button&gt; &lt;button ng-click=&quot;inc2&quot;&gt; increase 2 &lt;/button&gt; &lt;span style=&quot;color:red&quot; ng-bind=&quot;counter&quot;&gt;&lt;/span&gt; &lt;span style=&quot;color:blue&quot; ng-bind=&quot;counter&quot;&gt;&lt;/span&gt; &lt;span style=&quot;color:green&quot; ng-bind=&quot;counter&quot;&gt;&lt;/span&gt; &lt;script type=&quot;text/javascript&quot;&gt; /* 数据模型区开始 */ var counter = 0; function inc() &#123; counter++; &#125; function inc2() &#123; counter+=2; &#125; /* 数据模型区结束 */ /* 绑定关系区开始 */ function init() &#123; bind(); &#125; function bind() &#123; var list = document.querySelectorAll(&quot;[ng-click]&quot;); for (var i=0; i&lt;list.length; i++) &#123; list[i].onclick = (function(index) &#123; return function() &#123; window[list[index].getAttribute(&quot;ng-click&quot;)](); apply(); &#125;; &#125;)(i); &#125; &#125; function apply() &#123; var list = document.querySelectorAll(&quot;[ng-bind=&apos;counter&apos;]&quot;); for (var i=0; i&lt;list.length; i++) &#123; list[i].innerHTML = counter; &#125; &#125; /* 绑定关系区结束 */ &lt;/script&gt; &lt;/body&gt;&lt;/html&gt; 可以看到，在这么一个简单的例子中，我们做了一些双向绑定的事情。从两个按钮的点击到数据的变更，这个很好理解，但我们没有直接使用DOM的onclick方法，而是搞了一个ng-click，然后在bind里面把这个ng-click对应的函数拿出来，绑定到onclick的事件处理函数中。为什么要这样呢？因为数据虽然变更了，但是还没有往界面上填充，我们需要在此做一些附加操作。 从另外一个方面看，当数据变更的时候，需要把这个变更应用到界面上，也就是那三个span里。但由于Angular使用的是脏检测，意味着当改变数据之后，你自己要做一些事情来触发脏检测，然后再应用到这个数据对应的DOM元素上。问题就在于，怎样触发脏检测？什么时候触发？ 我们知道，一些基于setter的框架，它可以在给数据设值的时候，对DOM元素上的绑定变量作重新赋值。脏检测的机制没有这个阶段，它没有任何途径在数据变更之后立即得到通知，所以只能在每个事件入口中手动调用apply()，把数据的变更应用到界面上。在真正的Angular实现中，这里先进行脏检测，确定数据有变化了，然后才对界面设值。 所以，我们在ng-click里面封装真正的click，最重要的作用是为了在之后追加一次apply()，把数据的变更应用到界面上去。 那么，为什么在ng-click里面调用$digest的话，会报错呢？因为Angular的设计，同一时间只允许一个$digest运行，而ng-click这种内置指令已经触发了$digest，当前的还没有走完，所以就出错了。 $digest和$apply在Angular中，有$apply和$digest两个函数，我们刚才是通过$digest来让这个数据应用到界面上。但这个时候，也可以不用$digest，而是使用$apply，效果是一样的，那么，它们的差异是什么呢？ 最直接的差异是，$apply可以带参数，它可以接受一个函数，然后在应用数据之后，调用这个函数。所以，一般在集成非Angular框架的代码时，可以把代码写在这个里面调用。 12345678910111213141516var app = angular.module(&quot;test&quot;, []);app.directive(&quot;myclick&quot;, function() &#123; return function (scope, element, attr) &#123; element.on(&quot;click&quot;, function() &#123; scope.counter++; scope.$apply(function() &#123; scope.counter++; &#125;); &#125;); &#125;;&#125;);app.controller(&quot;CounterCtrl&quot;, function($scope) &#123; $scope.counter = 0;&#125;); 除此之外，还有别的区别吗？ 在简单的数据模型中，这两者没有本质差别，但是当有层次结构的时候，就不一样了。考虑到有两层作用域，我们可以在父作用域上调用这两个函数，也可以在子作用域上调用，这个时候就能看到差别了。 对于$digest来说，在父作用域和子作用域上调用是有差别的，但是，对于$apply来说，这两者一样。我们来构造一个特殊的示例： 12345678910111213141516171819202122232425262728293031323334353637383940var app = angular.module(&quot;test&quot;, []);app.directive(&quot;increasea&quot;, function() &#123; return function (scope, element, attr) &#123; element.on(&quot;click&quot;, function() &#123; scope.a++; scope.$digest(); &#125;); &#125;;&#125;);app.directive(&quot;increaseb&quot;, function() &#123; return function (scope, element, attr) &#123; element.on(&quot;click&quot;, function() &#123; scope.b++; scope.$digest(); //这个换成$apply即可 &#125;); &#125;;&#125;);app.controller(&quot;OuterCtrl&quot;, [&quot;$scope&quot;, function($scope) &#123; $scope.a = 1; $scope.$watch(&quot;a&quot;, function(newVal) &#123; console.log(&quot;a:&quot; + newVal); &#125;); $scope.$on(&quot;test&quot;, function(evt) &#123; $scope.a++; &#125;);&#125;]);app.controller(&quot;InnerCtrl&quot;, [&quot;$scope&quot;, function($scope) &#123; $scope.b = 2; $scope.$watch(&quot;b&quot;, function(newVal) &#123; console.log(&quot;b:&quot; + newVal); $scope.$emit(&quot;test&quot;, newVal); &#125;);&#125;]); 12345678910&lt;div ng-app=&quot;test&quot;&gt; &lt;div ng-controller=&quot;OuterCtrl&quot;&gt; &lt;div ng-controller=&quot;InnerCtrl&quot;&gt; &lt;button increaseb&gt;increase b&lt;/button&gt; &lt;span ng-bind=&quot;b&quot;&gt;&lt;/span&gt; &lt;/div&gt; &lt;button increasea&gt;increase a&lt;/button&gt; &lt;span ng-bind=&quot;a&quot;&gt;&lt;/span&gt; &lt;/div&gt;&lt;/div&gt; 这时候，我们就能看出差别了，在increase b按钮上点击，这时候，a跟b的值其实都已经变化了，但是界面上的a没有更新，直到点击一次increase a，这时候刚才对a的累加才会一次更新上来。怎么解决这个问题呢？只需在increaseb这个指令的实现中，把$digest换成$apply即可。 当调用$digest的时候，只触发当前作用域和它的子作用域上的监控，但是当调用$apply的时候，会触发作用域树上的所有监控。 因此，从性能上讲，如果能确定自己作的这个数据变更所造成的影响范围，应当尽量调用$digest，只有当无法精确知道数据变更造成的影响范围时，才去用$apply，很暴力地遍历整个作用域树，调用其中所有的监控。 从另外一个角度，我们也可以看到，为什么调用外部框架的时候，是推荐放在$apply中，因为只有这个地方才是对所有数据变更都应用的地方，如果用$digest，有可能临时丢失数据变更。 脏检测的利弊很多人对Angular的脏检测机制感到不屑，推崇基于setter，getter的观测机制，在我看来，这只是同一个事情的不同实现方式，并没有谁完全胜过谁，两者是各有优劣的。 大家都知道，在循环中批量添加DOM元素的时候，会推荐使用DocumentFragment，为什么呢，因为如果每次都对DOM产生变更，它都要修改DOM树的结构，性能影响大，如果我们能先在文档碎片中把DOM结构创建好，然后整体添加到主文档中，这个DOM树的变更就会一次完成，性能会提高很多。 同理，在Angular框架里，考虑到这样的场景： 123456789101112131415161718192021function TestCtrl($scope) &#123; $scope.numOfCheckedItems = 0; var list = []; for (var i=0; i&lt;10000; i++) &#123; list.push(&#123; index: i, checked: false &#125;); &#125; $scope.list = list; $scope.toggleChecked = function(flag) &#123; for (var i=0; i&lt;list.length; i++) &#123; list[i].checked = flag; $scope.numOfCheckedItems++; &#125; &#125;;&#125; 如果界面上某个文本绑定这个numOfCheckedItems，会怎样？在脏检测的机制下，这个过程毫无压力，一次做完所有数据变更，然后整体应用到界面上。这时候，基于setter的机制就惨了，除非它也是像Angular这样把批量操作延时到一次更新，否则性能会更低。 所以说，两种不同的监控方式，各有其优缺点，最好的办法是了解各自使用方式的差异，考虑出它们性能的差异所在，在不同的业务场景中，避开最容易造成性能瓶颈的用法。","categories":[{"name":"Angularjs","slug":"Angularjs","permalink":"https://github.com/ChangerHe/categories/Angularjs/"}],"tags":[{"name":"Angularjs","slug":"Angularjs","permalink":"https://github.com/ChangerHe/tags/Angularjs/"},{"name":"数据绑定","slug":"数据绑定","permalink":"https://github.com/ChangerHe/tags/数据绑定/"}]},{"title":"Javascript中隐式类型转换的神坑","slug":"Javascript中隐式类型转换的神坑","date":"2017-09-30T06:16:09.000Z","updated":"2017-09-30T03:41:50.749Z","comments":true,"path":"2017/09/30/Javascript中隐式类型转换的神坑/","link":"","permalink":"https://github.com/ChangerHe/2017/09/30/Javascript中隐式类型转换的神坑/","excerpt":"","text":"开篇之前, 大家先思考一个问题, 下面这段代码运行出来之后的结果是多少 1++[[]][+[]]+[+[]] 首先, 不得不说, 发现并提出这个问题的人是个天才，他怎么会遇到这样的一个问题。 其次，回答这个问题的人更是一个天才，我难以想象他会回答这个问题，更难以想象的是，他的回答是如此的详细和丰富和完整，真正称得上诲人不倦。 不卖关子了, 这道题的答案是10, String类型的, 10 那么, 这个问题怎么解呢? 下面跟着我一起把小车开起来~ 回归本源我们先复习一下: JS中有两种数据类型: 基本数据类型, 复杂数据类型 基本数据类型存储在栈空间中, 类型加上ES6新增的Symbol一共六种 string number boolean undefined null symbol 复杂数据类型存储在堆空间中,包含以下三种 function object array 但是听说最近爆出了Chrome的61版本存在的安全漏洞的问题 因为V8团队之前做的一个优化,将函数中的内部复杂数据类型直接存储在栈空间了, 导致V8对ES6的解构, for…of,rest参数的解析功能会变慢, 当然, 这又是另外一回事了. 当我们执行加法操作时,JS在想什么首先还是申明一下,下面的解释是在网上查阅资料, 加上我自己的实践得出的结果, 可能和准确值存在偏差. 欢迎指正 加法运算的隐式转换的执行顺序加法运算符会触发三种类型转换： 转换为原始值 转换为数字 转换为字符串 通过 ToPrimitive() 将值转换为原始值如果操作值是个原始值，则直接返回它。 否则，如果操作值是一个对象。则调用 obj.valueOf() 方法。 如果返回值是一个原始值，则返回这个原始值。 否则，调用 obj.toString() 方法。 如果返回值是一个原始值，则返回这个原始值。 否则，抛出 TypeError 异常。 通过 ToNumber() 将值转换为数字下面的表格解释了 ToNumber() 是如何将原始值转换成数字的 参数 结果 undefined NaN null +0 boolean true被转换为1,false转换为+0 number 无需转换 string 由字符串解析为数字。例如，”324”被转换为324 通过ToString()将值转换为字符串下面的表格解释了 ToString() 是如何将原始值转换成字符串的 参数 结果 undefined “undefined” null “null” boolean “true” 或者 “false” number 数字作为字符串。比如，”1.765” string 无需转换 小小的总结一下其实说这么多, 最后想表达的还是一个重要思想 对于JS中的加法, 流程是这样的 判断两边的值是否都为普通的String或Number类型, 如果是,则直接进行数学相加或字符串的拼接操作 如果两边并非都为数字或字符串,那么首先会对相加值中的复杂数据类型进行valueOf()操作, 首先确定一下这个复杂数据类型能否通过求值来返回一个简单数据类型, 然后将求值结果与另一个值进行相加. 如果结果不是一个原始值, 则会调用toString()方法,将复杂类型直接转为字符串,进行拼接操作. 码完了, 好累啊, 那么下面我们做一些简单的测试, 对应上面列出的几条语法 16 + &#123; valueOf: function () &#123; return 2 &#125; &#125; // 8 上面的代码中,我们把valueOf()转为了直接返回2, 所以因为在加法运算时会直接运行所以返回了2 没看懂? 没事儿咱们还有一个例子来说明这个问题,再来看一个好玩的 12345Number.prototype.valueOf = function() &#123; return 3&#125;new Number(2) == 3 // true 接下来看个简单的 1[] + [] // &quot;&quot; 为什么返回空值呢? 因为[]的valueOf值就是空值啊 1[] + &#123;&#125; // &apos;&apos;[object Object]&apos;&apos; 同样的,因为{} 的valueOf()返回的是[object Object], 加上前面的`, 所以返回了[object Object]` 开始的结果解析看完这些之后,我们再看一下开始的代码 1++[[]][+[]]+[+[]] 其实这样就很好解释了 根据优先级,会先计算括号内的元素 [[]] 变成了 [&#39;&#39;] [+[]] 变成了 [0] 上面的代码可以简化为 1++[&apos;&apos;][0] + [0] 而[&#39;&#39;][0] , 数组的第零位,也就是&#39;&#39;, 进行自加操作时进行上述的隐式类型转换, 变成了0, 自加1, 所以变成了1 同样的 [0] 会被转换为 0 , 注意是字符类型的 0 所以最后的结果是 11 + &quot;0&quot; 所以答案是 ‘10’ (完)","categories":[{"name":"JavaScript 学习笔记","slug":"JavaScript-学习笔记","permalink":"https://github.com/ChangerHe/categories/JavaScript-学习笔记/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://github.com/ChangerHe/tags/JavaScript/"}]},{"title":"sass/scss和less的区别","slug":"sass-scss和less的区别","date":"2017-09-01T15:13:23.000Z","updated":"2017-10-26T02:30:24.659Z","comments":true,"path":"2017/09/01/sass-scss和less的区别/","link":"","permalink":"https://github.com/ChangerHe/2017/09/01/sass-scss和less的区别/","excerpt":"","text":"Sass/Scss、Less是什么?Sass (Syntactically Awesome Stylesheets)是一种动态样式语言，Sass语法属于缩排语法，比css比多出好些功能(如变量、嵌套、运算,混入(Mixin)、继承、颜色处理，函数等)，更容易阅读。 Sass与Scss是什么关系?Sass的缩排语法，对于写惯css前端的web开发者来说很不直观，也不能将css代码加入到Sass里面，因此sass语法进行了改良，Sass 3就变成了Scss(sassy css)。与原来的语法兼容，只是用{}取代了原来的缩进。 Less也是一种动态样式语言. 对CSS赋予了动态语言的特性，如变量，继承，运算， 函数. Less 既可以在客户端上运行 (支持IE 6+, Webkit, Firefox)，也可在服务端运行 (借助 Node.js)。 Sass/Scss与Less区别编译环境不一样Sass的安装需要Ruby环境，是在服务端处理的，而Less是需要引入less.js来处理Less代码输出css到浏览器，也可以在开发环节使用Less，然后编译成css文件，直接放到项目中，也有 Less.app、SimpleLess、CodeKit.app这样的工具，也有在线编译地址。 变量符不一样Less是@，而Scss是$，而且变量的作用域也不一样。 1234567891011121314// Less-作用域@color: #00c; /* 蓝色 */#header &#123; @color: #c00; /* red */ border: 1px solid @color; /* 红色边框 */&#125;#footer &#123; border: 1px solid @color; /* 蓝色边框 */&#125;// Less-作用域编译后#header&#123;border:1px solid #cc0000;&#125;#footer&#123;border:1px solid #0000cc;&#125; 1234567891011121314151617// scss-作用域$color: #00c; /* 蓝色 */#header &#123; $color: #c00; /* red */ border: 1px solid $color; /* 红色边框 */&#125;#footer &#123; border: 1px solid $color; /* 蓝色边框 */&#125;// Sass-作用域编译后#header&#123;border:1px solid #c00&#125;#footer&#123;border:1px solid #c00&#125; 我们可以看出来，less和scss中的变量会随着作用域的变化而不一样。 输出设置Less没有输出设置，Sass提供4中输出选项：nested, compact, compressed 和 expanded。 输出样式的风格可以有四种选择，默认为nested -nested：嵌套缩进的css代码-expanded：展开的多行css代码-compact：简洁格式的css代码-compressed：压缩后的css代码 条件语句的支持Sass支持条件语句，可以使用if{}else{},for{}循环等等。而Less不支持。 123456789101112131415// 简单的if语句@if lightness($color) &gt; 30% &#123;&#125; @else &#123;&#125;// 简单的for语句@for $i from 1 to 10 &#123; .border-#&#123;$i&#125; &#123; border: #&#123;$i&#125;px solid blue; &#125;&#125; 引用外部CSS文件scss引用的外部文件命名必须以_开头, 如下例所示:其中_test1.scss、_test2.scss、test3.scss文件分别设置的h1 h2 h3。文件名如果以下划线开头的话，Sass会认为该文件是一个引用文件，不会将其编译为css文件. 1234567891011121314151617// 源代码：@import &quot;_test1.scss&quot;;@import &quot;_test2.scss&quot;;@import &quot;_test3.scss&quot;;// 编译后：h1 &#123; font-size: 17px;&#125; h2 &#123; font-size: 17px;&#125; h3 &#123; font-size: 17px;&#125; Less引用外部文件和css中的@import没什么差异。 Sass和Less的工具库不同Sass有工具库Compass, 简单说，Sass和Compass的关系有点像Javascript和jQuery的关系,Compass是Sass的工具库。在它的基础上，封装了一系列有用的模块和模板，补充强化了Sass的功能。 Less有UI组件库Bootstrap,Bootstrap是web前端开发中一个比较有名的前端UI组件库，Bootstrap的样式文件部分源码就是采用Less语法编写。 总结不管是Sass，还是Less，都可以视为一种基于CSS之上的高级语言，其目的是使得CSS开发更灵活和更强大，Sass的功能比Less强大,基本可以说是一种真正的编程语言了，Less则相对清晰明了,易于上手,对编译环境要求比较宽松。考虑到编译Sass要安装Ruby,而Ruby官网在国内访问不了,个人在实际开发中更倾向于选择Less。","categories":[{"name":"CSS","slug":"CSS","permalink":"https://github.com/ChangerHe/categories/CSS/"}],"tags":[{"name":"SASS","slug":"SASS","permalink":"https://github.com/ChangerHe/tags/SASS/"},{"name":"LESS","slug":"LESS","permalink":"https://github.com/ChangerHe/tags/LESS/"},{"name":"SCSS","slug":"SCSS","permalink":"https://github.com/ChangerHe/tags/SCSS/"}]},{"title":"基于MongoDB 2dSphere索引查找最近的点","slug":"基于MongoDB-2dSphere索引查找最近的点","date":"2017-07-21T15:27:22.000Z","updated":"2017-09-24T15:35:44.241Z","comments":true,"path":"2017/07/21/基于MongoDB-2dSphere索引查找最近的点/","link":"","permalink":"https://github.com/ChangerHe/2017/07/21/基于MongoDB-2dSphere索引查找最近的点/","excerpt":"","text":"在移动端普及的今天，LBS应用需求也越来越大。比如查找附近的人，最近的餐厅等。面对这些需求，MongoDB提供了功能完备的解决方案。下面通过一个案例来解释一下MongoDB的2dSphere 在这个图片中，有A B C D E F G,假如我是搜索点A。我想查找离自己最近的点。下面是具体的操作步骤： 建立集合和索引。sp为建立索引的字段名，我们建立的索引类型是2dsphere12# 创建2dsphere索引 db.sphere.ensureIndex(&#123;&quot;sp&quot;:&quot;2dsphere&quot;&#125;) 向集合中插入测试数据，我们插入的是实际的经纬度。这里需要注意的是，如果我们如果用的是2dsphere索引，那么插入的应该是GeoJson数据。GeoJson的格式是 { type: ‘GeoJSON type’ , coordinates: ‘coordinates’ } 其中type指的是类型，可以是Point(本例中用的)，LineString，Polygon等，coordinates是一个坐标数组。英语好的同学可以去官网看看https://docs.mongodb.com/manual/reference/geojson/ 12345678# 插入Point数据db.sphere.insert(&#123;name:&quot;A&quot;,sp:&#123;type:&quot;Point&quot;,coordinates:[105.754484701156,41.689607057699]&#125;&#125;)db.sphere.insert(&#123;name:&quot;B&quot;,sp:&#123;type:&quot;Point&quot;,coordinates:[105.304045248031,41.783456183240]&#125;&#125;)db.sphere.insert(&#123;name:&quot;C&quot;,sp:&#123;type:&quot;Point&quot;,coordinates:[105.084318685531,41.389027478812]&#125;&#125;)db.sphere.insert(&#123;name:&quot;D&quot;,sp:&#123;type:&quot;Point&quot;,coordinates:[105.831388998031,41.285916385493]&#125;&#125;)db.sphere.insert(&#123;name:&quot;E&quot;,sp:&#123;type:&quot;Point&quot;,coordinates:[106.128706502914,42.086868474465]&#125;&#125;)db.sphere.insert(&#123;name:&quot;F&quot;,sp:&#123;type:&quot;Point&quot;,coordinates:[105.431074666976,42.009365053841]&#125;&#125;)db.sphere.insert(&#123;name:&quot;G&quot;,sp:&#123;type:&quot;Point&quot;,coordinates:[104.705977010726,41.921549795110]&#125;&#125;) 进行查询。介绍一下其中的参数 （1）geoNear:我们要查询的集合名称 （2）near:就是基于那个点进行搜索，这里是我们的搜索点A （3）spherical:是个布尔值，如果为true，表示将计算实际的物理距离比如两点之间有多少km,若为false,则会基于点的单位进行计算 （4）minDistance:搜索的最小距离，这里的单位是米 （5）maxDistance:搜索的最大距离 1234567db.runCommand(&#123; geoNear:&quot;sphere&quot;, near:&#123;type:&quot;Point&quot;,coordinates:[105.794621276855,41.869574065014]&#125;, spherical:true, minDistance:25000, maxDistance:40000, &#125;) 结果分析1234567891011121314151617181920212223242526272829303132333435363738394041&#123; &quot;waitedMS&quot; : NumberLong(0), &quot;results&quot; : [ &#123; &quot;dis&quot; : 33887.5416611258, &quot;obj&quot; : &#123; &quot;_id&quot; : ObjectId(&quot;57e3857e6a4a326367ae0d05&quot;), &quot;name&quot; : &quot;F&quot;, &quot;sp&quot; : &#123; &quot;type&quot; : &quot;Point&quot;, &quot;coordinates&quot; : [ 105.431074666976, 42.009365053841 ] &#125; &#125; &#125;, &#123; &quot;dis&quot; : 36734.9748784127, &quot;obj&quot; : &#123; &quot;_id&quot; : ObjectId(&quot;57e3857e6a4a326367ae0d04&quot;), &quot;name&quot; : &quot;E&quot;, &quot;sp&quot; : &#123; &quot;type&quot; : &quot;Point&quot;, &quot;coordinates&quot; : [ 106.128706502914, 42.086868474465 ] &#125; &#125; &#125; ], &quot;stats&quot; : &#123; &quot;nscanned&quot; : 24, &quot;objectsLoaded&quot; : 20, &quot;avgDistance&quot; : 35311.2582697693, &quot;maxDistance&quot; : 36734.9748784127, &quot;time&quot; : 87 &#125;, &quot;ok&quot; : 1.0&#125; 在results中，我们搜索到了点F和E。每个文档都加上了一个dis字段，他表示这个点离你搜索点的距离。 比如说，在结果中name为F的点的dis为33887.5416611258。表示F点距离搜索点的距离是33887米。这个结果对于LBS应用是非常有用的。","categories":[{"name":"MongoDB学习笔记","slug":"MongoDB学习笔记","permalink":"https://github.com/ChangerHe/categories/MongoDB学习笔记/"}],"tags":[{"name":"MongoDB","slug":"MongoDB","permalink":"https://github.com/ChangerHe/tags/MongoDB/"},{"name":"2dSphere","slug":"2dSphere","permalink":"https://github.com/ChangerHe/tags/2dSphere/"}]},{"title":"《ES6标准入门》阅读笔记——-Module","slug":"《ES6标准入门》阅读笔记——-Module","date":"2017-07-19T16:23:13.000Z","updated":"2017-09-18T00:42:20.342Z","comments":true,"path":"2017/07/20/《ES6标准入门》阅读笔记——-Module/","link":"","permalink":"https://github.com/ChangerHe/2017/07/20/《ES6标准入门》阅读笔记——-Module/","excerpt":"","text":"写在前面本系列为在我读完阮一峰老师的《ES6标准入门》第二版之后，所做的阅读笔记的整理。 许多初学ES6, 同时和我一样初次阅读阮老师的这本书的时候, 读第一遍会越发的困惑, 因为阮老师上面说的很多的定义,方法,之前都是没有见过的, 读到后面才发现, 哦~原来是这样. 有一句话叫做”大神的世界我们不懂”, 所以我在初读第一遍《ES6标准入门》这本书的时候,也是踩了不少坑,读书的时候查阅了不少的资料. 所以,在这一系列的笔记教程中,我会从一个初学者的角度,向您讲述ES6的相关知识,在后面介绍的知识我会尽量不提前用,即使提前使用,也会同时做好标注,避免了阅读时各种查阅资料的烦恼. 系列博客将采用一个一个的样例，来说明书中的精华部分（当然，这只是我认为的），同时引导新手，快速入门ES6，并逐步将其投入到生产实践中。 同时,在阅读前也提醒您, 为了系统连贯性的学习ES6的基础知识,建议您从我的博客第一章开始阅读,当然,如果您对对应的知识已经有所了解,那么可以跳转到任意章节阅读,每一篇博客名中均有介绍该博客中涉及到的ES6的内容. 阮一峰老师的这本书是开源的，在其官方博客就可以下载到，但是我强烈建议大家去购买一本书, 一是方便自己查阅ES6中新增的众多API, 二也是表达一下对大神的敬仰.","categories":[{"name":"ES6标准入门","slug":"ES6标准入门","permalink":"https://github.com/ChangerHe/categories/ES6标准入门/"}],"tags":[{"name":"ES6","slug":"ES6","permalink":"https://github.com/ChangerHe/tags/ES6/"},{"name":"Module","slug":"Module","permalink":"https://github.com/ChangerHe/tags/Module/"}]},{"title":"《ES6标准入门》阅读笔记——-Class","slug":"《ES6标准入门》阅读笔记——-Class","date":"2017-07-16T15:52:52.000Z","updated":"2017-09-18T00:42:14.635Z","comments":true,"path":"2017/07/16/《ES6标准入门》阅读笔记——-Class/","link":"","permalink":"https://github.com/ChangerHe/2017/07/16/《ES6标准入门》阅读笔记——-Class/","excerpt":"","text":"写在前面本系列为在我读完阮一峰老师的《ES6标准入门》第二版之后，所做的阅读笔记的整理。 许多初学ES6, 同时和我一样初次阅读阮老师的这本书的时候, 读第一遍会越发的困惑, 因为阮老师上面说的很多的定义,方法,之前都是没有见过的, 读到后面才发现, 哦~原来是这样. 有一句话叫做”大神的世界我们不懂”, 所以我在初读第一遍《ES6标准入门》这本书的时候,也是踩了不少坑,读书的时候查阅了不少的资料. 所以,在这一系列的笔记教程中,我会从一个初学者的角度,向您讲述ES6的相关知识,在后面介绍的知识我会尽量不提前用,即使提前使用,也会同时做好标注,避免了阅读时各种查阅资料的烦恼. 系列博客将采用一个一个的样例，来说明书中的精华部分（当然，这只是我认为的），同时引导新手，快速入门ES6，并逐步将其投入到生产实践中。 同时,在阅读前也提醒您, 为了系统连贯性的学习ES6的基础知识,建议您从我的博客第一章开始阅读,当然,如果您对对应的知识已经有所了解,那么可以跳转到任意章节阅读,每一篇博客名中均有介绍该博客中涉及到的ES6的内容. 阮一峰老师的这本书是开源的，在其官方博客就可以下载到，但是我强烈建议大家去购买一本书, 一是方便自己查阅ES6中新增的众多API, 二也是表达一下对大神的敬仰.","categories":[{"name":"ES6标准入门","slug":"ES6标准入门","permalink":"https://github.com/ChangerHe/categories/ES6标准入门/"}],"tags":[{"name":"ES6","slug":"ES6","permalink":"https://github.com/ChangerHe/tags/ES6/"},{"name":"Class","slug":"Class","permalink":"https://github.com/ChangerHe/tags/Class/"}]},{"title":"记一次简单的Nodejs爬虫","slug":"记一次简单的Nodejs爬虫","date":"2017-07-13T10:32:57.000Z","updated":"2017-09-27T09:13:27.086Z","comments":true,"path":"2017/07/13/记一次简单的Nodejs爬虫/","link":"","permalink":"https://github.com/ChangerHe/2017/07/13/记一次简单的Nodejs爬虫/","excerpt":"","text":"作为初学nodejs的小学森, 不玩一把爬虫真的都不好意思说自己学过nodejs 所以, 本次教程本着严谨的教学角度, 向大家传授一下严谨的老司机绝技 学完之后, 自己写点儿小程序, 爬一爬某些不可描述的小图片啊, 小电影啊什么的, 也是可以的 所以我要在这里再次重申一下啊, 这真的是一篇严谨的教学博客 一入*门深似海, 从此节操是路人 准备工作看到这篇博客时, 默认您已经掌握了nodejs的基本知识以及模块化的相关理念, 以及npm包管理的简单使用方法(也就一个cmd命令, npm i),所以基本上是看一遍之后就可以非常简单的上手的. 本次的数据库是直接使用的mongoDB, 简单上手,值得拥有. mongoDB的配置这个下载就不用说了吧, 老司机都知道上度娘. 关键是配置这块, 安装好之后,我们在项目的文件夹下创建一个db文件夹, 当然,项目文件夹是要存储你待会儿写的代码用的,新建一个就好 下好之后, 可以启动cmd(win + r, 然后回车) 输入mongo 输完了吗? 是不是没有看到结果? 没有结果就对了,因为我没教你配置环境变量啊 配置环境变量首先,进入安装目录的bin文件夹,比如我是直接在安装的时候全部点的下一步,所以我的安装目录在C:\\Program Files\\MongoDB\\Server\\3.2\\bin, 找到这个地方之后,在地址栏, 将这个文件路径复制下来,粘贴到环境变量的对应地方 环境变量的位置在: 我的电脑右键&gt; 属性 &gt; 高级系统设置 &gt; 环境变量 &gt; 管理员的用户变量 注意不要动系统变量,不然一旦操作不慎是会造成系统宕机的. 我们在用户变量的PATH中,鼠标光标点到最后,在它后面插上一个小分号 哎, 怎么有了一种邪恶的感觉 咳咳~ 插进去之后, 将我们之前bin目录的文件路径复制上去,然后确定 现在我们要做一下简单的配置让mongoDB启动起来: mongod --storageEngine mmapv1 --dbpath &quot;d:\\mongodb\\db&quot; --logpath &quot;d:\\mongodb\\log\\MongoDB.log 下面详细讲一下配置的参数: mongod mongoDB的命令,这个不用说 --storageEngine mmapv1 这是一个比较老的mongoDB的存储引擎, 32位系统的童鞋需要有这条命令, 64位系统的可以不用, --dbpath &quot;d:\\mongodb\\db&quot; 数据库路径,找到项目文件夹, 把自己的项目文件夹的db路径替换掉上面的路径 --logpath &quot;d:\\mongodb\\log\\MongoDB.log 日志路径,一般我们会放在和db一起, 也是一样的, 把自己的log文件夹的路径替换掉上面的路径,因为刚开始是没有MongoDB.log这个文件的,所以需要新建一个. 执行成功之后,如果没有看到ERROR的提示, 那么恭喜你,mongo的服务已经成功启动了, 报错的可以再往上翻一下是不是有步骤遗漏, 因为我也是纯手工码字, 难免可能自己也有遗漏的地方, 确实不懂的地方也可以度娘或google 以上,mongo的配置就搞定了,mongo服务默认跑在27017端口, 如果不需要长期使用, 保持cmd挂起服务就正常运行的, 记住不能关掉哦 如果需要长期使用mongo服务的, 可以将mongo服务设置为系统服务,开机即启动, 可以在cmd中执行以下代码, 用于创建mongo服务进程 mongod --storageEngine mmapv1 --dbpath &quot;d:\\mongodb\\db&quot; --logpath &quot;d:\\mongodb\\log\\MongoDB.log&quot; --install --serviceName &quot;MongoDB&quot; 这个是mongo的指令,所以要在cmd状态下,不要在mongo的交互状态下执行这个命令,否则会报错的 完成以上指令, 就已经成功创建了系统服务了, 我们现在来启动它, 在cmd中输入: NET START MongoDB 提示服务器启动成功, bongo~ 安装依赖进入项目文件夹, 在cmd中输入npm init 创建一个json文件, 然后使用npm i * 一次安装express, cheerio, mongoose, superagent这几个依赖, 所以需要将指令中的*改为以上的依赖名称 万事俱备只欠东风了, 我们新建一个app.js文件, 并引入刚刚安装的依赖 1234var express = require(&apos;express&apos;)var cheerio = require(&apos;cheerio&apos;)var superagent = require(&apos;superagent&apos;)var mongoose = require(&apos;mongoose&apos;) 下面来大概说明一下这几个模块的作用 express: 一个极简快速灵活的web开发框架, 用来快速搭建web服务器的 cheerio: nodejs中的jQuery superagent 用来做客户端请求代理的, 直接点儿说就是代我们上网站拉网页代码的 mongoose: 用来连接mongoDB和处理mongo的请求 好了解完之后,我们要正式开始写代码了 首先一步,还是连接mongo数据库, 不然我们趴下来的数据就没地儿存了 1234567891011121314151617// 连接到mongoDB数据库,端口是27017, 我们将内容存储在cnodejs这个数据库中mongoose.connect(&apos;mongodb://localhost:27017/cnodejs&apos;,function(err) &#123; if(err) &#123; throw err &#125; else &#123; console.log(&apos;服务器连接成功...&apos;) &#125;&#125;)// 实例化一个骨架,定义我们要传入的内容的键名及键值var schema = new mongoose.Schema(&#123; title: String, href: String&#125;)// 定义一个模型变量, 我们将模型名称定义为List, 将爬取的内容存储在list这个文档中var model = mongoose.model(&apos;List&apos;, schema, &apos;list&apos;) 然后,我们再实例一个express, 方便我们进行操作 1var app = express() 使用代码来进行抓取 1234567891011121314151617181920212223242526272829303132333435app.get(&apos;/&apos;, function(req, res, next)&#123; // 使用superagent去抓取https://cnodejs.org的内容 superagent.get(&apos;https://cnodejs.org/&apos;).end(function(err, sres)&#123; // 常规的错误处理 if(err) return next(err) // sres.text里面存储着网页的html内容, 将它传给cheerio.load之后 //就可以得到一个实现了jQuery接口的变量,我们习惯性将其命名为 &apos;$&apos; var $ = cheerio.load(sres.text) var items = [] // 使用cheerio获取到爬取到的东西的内容 $(&apos;#topic_list .topic_title&apos;).each((idx, element)=&gt; &#123; // 预定义一个变量,从而提升整体的程序性能 var $element = $(element); var listModel = new model() listModel.title = $element.attr(&apos;title&apos;) listModel.href = $element.attr(&apos;href&apos;) // 将内容保存到数据库 listModel.save((err) =&gt; &#123; if(err) &#123; throw err &#125; else &#123; console.log(&apos;保存成功...&apos;) &#125; &#125;) &#125;) &#125;)&#125;) 最后一步, 指定服务器的监听端口 1234567app.listen(8090, function(err) &#123; if(err) &#123; throw err &#125; else &#123; console.log(&apos;服务器启动成功.. &apos;) &#125;&#125;) 全部搞定,我们使用cmd输入命令 node app 或者使用webstorm的ctrl + f9启动一下 到浏览器中,输入刚刚设置的本地服务器加端口号: localhost:8090 回来一看,我靠,好多的保存成功啊 至此,我们的爬取工作就已经全部完成了, 看下成果呗: 在mongoDB中查看自己的爬取结果如果不想麻烦的话, 可以直接安装一个ROBO 3T, 傻瓜式操作 也可以自己输入指令查看 在cmd中输入mongo, 进入mongo的交互 输入指令: use cnodejs 转到我们的cnodejs这个数据库中 然后输入指令: ‘db.list.find().pretty()’ 爬取的结果就都出来了 结束爬取的过程至此圆满结束 当然, 作为一个负责任的老司机, 怎么可能会不告诉你, 爬取出来的小电影小图片怎么看呢. 很简单, 使用ejs或者handlebars这类的模板引擎, 将数据库的内容渲染出来就好了","categories":[{"name":"Nodejs学习笔记","slug":"Nodejs学习笔记","permalink":"https://github.com/ChangerHe/categories/Nodejs学习笔记/"}],"tags":[{"name":"Nodejs","slug":"Nodejs","permalink":"https://github.com/ChangerHe/tags/Nodejs/"},{"name":"爬虫","slug":"爬虫","permalink":"https://github.com/ChangerHe/tags/爬虫/"}]},{"title":"《ES6标准入门》阅读笔记——-Promise","slug":"《ES6标准入门》阅读笔记——-Promise","date":"2017-07-11T14:23:54.000Z","updated":"2017-09-18T00:42:09.303Z","comments":true,"path":"2017/07/11/《ES6标准入门》阅读笔记——-Promise/","link":"","permalink":"https://github.com/ChangerHe/2017/07/11/《ES6标准入门》阅读笔记——-Promise/","excerpt":"","text":"写在前面本系列为在我读完阮一峰老师的《ES6标准入门》第二版之后，所做的阅读笔记的整理。 许多初学ES6, 同时和我一样初次阅读阮老师的这本书的时候, 读第一遍会越发的困惑, 因为阮老师上面说的很多的定义,方法,之前都是没有见过的, 读到后面才发现, 哦~原来是这样. 有一句话叫做”大神的世界我们不懂”, 所以我在初读第一遍《ES6标准入门》这本书的时候,也是踩了不少坑,读书的时候查阅了不少的资料. 所以,在这一系列的笔记教程中,我会从一个初学者的角度,向您讲述ES6的相关知识,在后面介绍的知识我会尽量不提前用,即使提前使用,也会同时做好标注,避免了阅读时各种查阅资料的烦恼. 系列博客将采用一个一个的样例，来说明书中的精华部分（当然，这只是我认为的），同时引导新手，快速入门ES6，并逐步将其投入到生产实践中。 同时,在阅读前也提醒您, 为了系统连贯性的学习ES6的基础知识,建议您从我的博客第一章开始阅读,当然,如果您对对应的知识已经有所了解,那么可以跳转到任意章节阅读,每一篇博客名中均有介绍该博客中涉及到的ES6的内容. 阮一峰老师的这本书是开源的，在其官方博客就可以下载到，但是我强烈建议大家去购买一本书, 一是方便自己查阅ES6中新增的众多API, 二也是表达一下对大神的敬仰.","categories":[{"name":"ES6标准入门","slug":"ES6标准入门","permalink":"https://github.com/ChangerHe/categories/ES6标准入门/"}],"tags":[{"name":"ES6","slug":"ES6","permalink":"https://github.com/ChangerHe/tags/ES6/"},{"name":"Promise","slug":"Promise","permalink":"https://github.com/ChangerHe/tags/Promise/"}]},{"title":"《ES6标准入门》阅读笔记——-Iterator和Generator","slug":"《ES6标准入门》阅读笔记——-Iterator和Generator","date":"2017-07-07T15:11:34.000Z","updated":"2017-09-18T00:42:03.573Z","comments":true,"path":"2017/07/07/《ES6标准入门》阅读笔记——-Iterator和Generator/","link":"","permalink":"https://github.com/ChangerHe/2017/07/07/《ES6标准入门》阅读笔记——-Iterator和Generator/","excerpt":"","text":"写在前面本系列为在我读完阮一峰老师的《ES6标准入门》第二版之后，所做的阅读笔记的整理。 许多初学ES6, 同时和我一样初次阅读阮老师的这本书的时候, 读第一遍会越发的困惑, 因为阮老师上面说的很多的定义,方法,之前都是没有见过的, 读到后面才发现, 哦~原来是这样. 有一句话叫做”大神的世界我们不懂”, 所以我在初读第一遍《ES6标准入门》这本书的时候,也是踩了不少坑,读书的时候查阅了不少的资料. 所以,在这一系列的笔记教程中,我会从一个初学者的角度,向您讲述ES6的相关知识,在后面介绍的知识我会尽量不提前用,即使提前使用,也会同时做好标注,避免了阅读时各种查阅资料的烦恼. 系列博客将采用一个一个的样例，来说明书中的精华部分（当然，这只是我认为的），同时引导新手，快速入门ES6，并逐步将其投入到生产实践中。 同时,在阅读前也提醒您, 为了系统连贯性的学习ES6的基础知识,建议您从我的博客第一章开始阅读,当然,如果您对对应的知识已经有所了解,那么可以跳转到任意章节阅读,每一篇博客名中均有介绍该博客中涉及到的ES6的内容. 阮一峰老师的这本书是开源的，在其官方博客就可以下载到，但是我强烈建议大家去购买一本书, 一是方便自己查阅ES6中新增的众多API, 二也是表达一下对大神的敬仰.","categories":[{"name":"ES6标准入门","slug":"ES6标准入门","permalink":"https://github.com/ChangerHe/categories/ES6标准入门/"}],"tags":[{"name":"ES6","slug":"ES6","permalink":"https://github.com/ChangerHe/tags/ES6/"},{"name":"Iterator","slug":"Iterator","permalink":"https://github.com/ChangerHe/tags/Iterator/"},{"name":"Generator","slug":"Generator","permalink":"https://github.com/ChangerHe/tags/Generator/"}]},{"title":"《ES6标准入门》阅读笔记——-set和map","slug":"《ES6标准入门》阅读笔记——-set和map","date":"2017-07-03T03:37:44.000Z","updated":"2017-10-09T09:51:25.926Z","comments":true,"path":"2017/07/03/《ES6标准入门》阅读笔记——-set和map/","link":"","permalink":"https://github.com/ChangerHe/2017/07/03/《ES6标准入门》阅读笔记——-set和map/","excerpt":"","text":"写在前面本系列为在我读完阮一峰老师的《ES6标准入门》第二版之后，所做的阅读笔记的整理。 许多初学ES6, 同时和我一样初次阅读阮老师的这本书的时候, 读第一遍会越发的困惑, 因为阮老师上面说的很多的定义,方法,之前都是没有见过的, 读到后面才发现, 哦~原来是这样. 有一句话叫做”大神的世界我们不懂”, 所以我在初读第一遍《ES6标准入门》这本书的时候,也是踩了不少坑,读书的时候查阅了不少的资料. 所以,在这一系列的笔记教程中,我会从一个初学者的角度,向您讲述ES6的相关知识,在后面介绍的知识我会尽量不提前用,即使提前使用,也会同时做好标注,避免了阅读时各种查阅资料的烦恼. 系列博客将采用一个一个的样例，来说明书中的精华部分（当然，这只是我认为的），同时引导新手，快速入门ES6，并逐步将其投入到生产实践中。 同时,在阅读前也提醒您, 为了系统连贯性的学习ES6的基础知识,建议您从我的博客第一章开始阅读,当然,如果您对对应的知识已经有所了解,那么可以跳转到任意章节阅读,每一篇博客名中均有介绍该博客中涉及到的ES6的内容. 阮一峰老师的这本书是开源的，在其官方博客就可以下载到，但是我强烈建议大家去购买一本书, 一是方便自己查阅ES6中新增的众多API, 二也是表达一下对大神的敬仰. SetES6提供了一种新的数据结构Set,类似于数组,但成员值是唯一的,没有重复值. set本身是一个构造函数,用来生成set数据结构 因此, 利用set这个结构的特性, 就可以很容易地进行数组去重了 123let s = new Set();let a = [1, 2, 3, 4, 5, 5, 6, 2, 12, 53, 34, 5, 1, 2, 5, 3, 1, 1].map(x =&gt; s.add(x))console.log(...s) // 1 2 3 4 5 6 12 53 34 向set加入值的时候不会发生类型转换,所以 5 和 ‘5’ 是两个不同的值 在set内部判断两数是否相等使用的是精确相等运算符, 也就是说,当我们比较对象是否相等的时候,两个不同引用空间的对象是永远不相等的 有一个例外是,当我们使用NaN的时候,会发现两个NaN其实是相等的,而在ES5的时候NaN会被认为是一个Object从而判定两者不相等 12345let set = new Set([1, 2, 3, NaN, NaN])console.log(set.size) // 4set.add(&#123;&#125;)set.add(&#123;&#125;)console.log(set.size) // 6 由上面的打印结果很明显的能看到, 两个NaN是相等的, 但是两个对象是不等的 set结构的实例是默认可遍历的 1234let set = new Set([&apos;red&apos;, &apos;green&apos;, &apos;blue&apos;])for (let x of set) &#123; console.log(x) // red green blue&#125; 由于扩展运算符内部使用for…of循环,所以也可以用于set结构 set的使用技巧利用set可以很容易地实现并集 交集 差集的操作 1234567891011121314let a = new Set([1, 2, 3])let b = new Set([2, 3, 4])// 求并集let union = new Set([...a, ...b])console.log(union) // Set(4) &#123;1, 2, 3, 4&#125;// 求交集let intersect = new Set([...a].filter(x =&gt; b.has(x)))console.log(intersect) // Set(2) &#123;2, 3&#125;// 求差集let difference = new Set([...a].filter(x =&gt; !b.has(x)))console.log(difference) // Set(1) &#123;1&#125; WeakSetWeakSet的结构和Set类似,也是不重复的值的集合.但是,它与Set有两个区别 weakset成员只能是对象,不能是其他类型的值 weakset对象都是弱引用,即垃圾回收机制不考虑 weakset对该对象的引用,如果其他对象都不再引用该对象,那么该对象就会被GC回收. 这一特点意味着无法引用weakset的成员,因此weakset是不可遍历的 Mapjavascript的对象本质上是键值对的集合,但是只能用字符串作为键名 123456let data = &#123;&#125;let element = document.getElementById(&apos;myDiv&apos;)data[element] = metadata // 报错console.log(data[&apos;[Object HTMLElement]&apos;]) ES6提供了Map数据结构,它类似于对象,也是键值对的集合,但是键的范围不限于字符串,各种类型的值都可以当做键名 因此,map是比object更加合适的键值对结构 12345678910let m = new Map()let o = &#123; p: &apos;Hello world&apos;&#125;m.set(o, &apos;content&apos;)console.log(m.get(o)) // contentconsole.log(m.has(o)) // trueconsole.log(m.delete(o)) // trueconsole.log(m.has(o)) // false 另外有一点需要注意的是,map的键是和内存地址绑定的,只要内存地址不一样,那么就会被视为两个键, 这样就解决了同名属性的碰撞问题 12345678910let map = new Map()let k1 = [&apos;a&apos;]let k2 = [&apos;a&apos;]map.set(k1, 111)map.set(k2, 222)console.log(map.get(k1)) // 111console.log(map.get(k2)) // 222 那么同样的,当我们使用简单数据类型时,只要两值完全相等,map就将其视为一个键 包括+0 和 -0 , 以及NaN 1234567let map = new Map()map.set(NaN, 123)console.log(map.get(NaN)) // 123map.set(-0, 321)console.log(map.get(+0)) // 321 map结构转为数组结构比较方便的方法就是使用三点运算符,或者说是扩展运算符,或者说是rest参数 1234567891011121314let map = new Map([ [1, &apos;one&apos;], [2, &apos;two&apos;], [3, &apos;three&apos;]])console.log([...map.keys()])// 1 2 3console.log([...map.values()])// &quot;one&quot; &quot;two&quot; &quot;three&quot;console.log([...map.entries()])// [1, &quot;one&quot;] [2, &quot;two&quot;] [3, &quot;three&quot;]console.log([...map]) // [1, &quot;one&quot;] [2, &quot;two&quot;] [3, &quot;three&quot;] WeakMapWeakmap的结构和map结构基本类似,但是weakmap只接受对象作为键名,不接受其他类型的值作为键名 weakmap的应用典型场景就是在DOM节点作为键名的时候 123456789101112let myElement = document.getElementById(&apos;logo&apos;)let myWeakmap = new WeakMap()myWeakmap.set(myElement, &#123; timesClicked: 0&#125;)myElement.addEventListener(&apos;click&apos;, () =&gt; &#123; let logoData = myWeakmap.get(myElement) logoData.timesClicked++ myWeakmap.set(myElement, logoData)&#125;, false) (完)","categories":[{"name":"ES6标准入门","slug":"ES6标准入门","permalink":"https://github.com/ChangerHe/categories/ES6标准入门/"}],"tags":[{"name":"ES6","slug":"ES6","permalink":"https://github.com/ChangerHe/tags/ES6/"},{"name":"set","slug":"set","permalink":"https://github.com/ChangerHe/tags/set/"},{"name":"map","slug":"map","permalink":"https://github.com/ChangerHe/tags/map/"}]},{"title":"《ES6标准入门》阅读笔记——-symbol及proxy/reflect","slug":"《ES6标准入门》阅读笔记——-symbol及proxy-reflect","date":"2017-07-01T05:51:28.000Z","updated":"2017-10-09T09:10:47.950Z","comments":true,"path":"2017/07/01/《ES6标准入门》阅读笔记——-symbol及proxy-reflect/","link":"","permalink":"https://github.com/ChangerHe/2017/07/01/《ES6标准入门》阅读笔记——-symbol及proxy-reflect/","excerpt":"","text":"写在前面本系列为在我读完阮一峰老师的《ES6标准入门》第二版之后，所做的阅读笔记的整理。 许多初学ES6, 同时和我一样初次阅读阮老师的这本书的时候, 读第一遍会越发的困惑, 因为阮老师上面说的很多的定义,方法,之前都是没有见过的, 读到后面才发现, 哦~原来是这样. 有一句话叫做”大神的世界我们不懂”, 所以我在初读第一遍《ES6标准入门》这本书的时候,也是踩了不少坑,读书的时候查阅了不少的资料. 所以,在这一系列的笔记教程中,我会从一个初学者的角度,向您讲述ES6的相关知识,在后面介绍的知识我会尽量不提前用,即使提前使用,也会同时做好标注,避免了阅读时各种查阅资料的烦恼. 系列博客将采用一个一个的样例，来说明书中的精华部分（当然，这只是我认为的），同时引导新手，快速入门ES6，并逐步将其投入到生产实践中。 同时,在阅读前也提醒您, 为了系统连贯性的学习ES6的基础知识,建议您从我的博客第一章开始阅读,当然,如果您对对应的知识已经有所了解,那么可以跳转到任意章节阅读,每一篇博客名中均有介绍该博客中涉及到的ES6的内容. 阮一峰老师的这本书是开源的，在其官方博客就可以下载到，但是我强烈建议大家去购买一本书, 一是方便自己查阅ES6中新增的众多API, 二也是表达一下对大神的敬仰. Symbol在ES6之前,当我们命名变量的时候,总是会担心,如果我把之前的变量改写了该怎么办呢 那么,现在ES6推出了继 null undefined string number boolean 这五中数据类型以外的第六种简单数据类型symbol 推出的主要目的在于,解决属性名冲突的问题 12let s = Symbol()console.log(typeof s) // symbol symbol一般会传入一个字符串作为不同symbol实例的描述,方便进行区分 1234let a = Symbol(&apos;a&apos;)let b = Symbol(&apos;b&apos;)console.log(a, b) // Symbol(a) Symbol(b)console.log(a.toString(), b.toString()) // Symbol(a) Symbol(b) 我们查看控制台的打印结果,会发现symbol的值是以红色显示的,而普通字符串则以灰色显示 symbol的几个特征 symbol函数的参数只表示对当前symbol值的表示,因此相同参数的symbol函数的返回值是不相等的 symbol无法与其他类型值进行运算,否则会报错 symbol可以转为布尔值,但是无法转为数值 symbol作为变量时,不能使用点运算符 因为symbol是一个特殊的基本类型,因此使用点运算符是不行的,这样会被理解为是在使用字符串作为变量名称 那么这个时候,可以使用方括号加上symbol名称的方式,来调取这个symbol值 12345678910var mySymbol = Symbol(&apos;aaa&apos;)var a = &#123;&#125;a.mySymbol = &apos;hello&apos;console.log(a[mySymbol]) // undefinedconsole.log(a.mySymbol) // helloconsole.log(a[&apos;mySymbol&apos;]) // hellolet c = Symbollet d = cconsole.log(d, d === c) // ƒ Symbol() &#123; [native code] &#125; true 作为属性名的symbolsymbol作为属性名,该属性不会出现在for…in for…of 循环中,也不会被Object.keys()/Object.getOwnPropertyNames()返回 但它也不是私有属性,有一个Object.getOwnPropertSymbols方法可以获取指定对象的所有symbol属性名 123456789101112var obj = &#123;&#125;var a = Symbol(&apos;a&apos;)var b = Symbol.for(&apos;b&apos;)obj[a] = &apos;hello&apos;obj[b] = &apos;world&apos;var objectSymbols = Object.getOwnPropertySymbols(obj)console.log(objectSymbols) // [Symbol(a), Symbol(b)]var symbolNames = Object.getOwnPropertyNames(obj)console.log(symbolNames) // [] 由以上可知,使用getOwnPropertySymbols() 方法可以得到对应的symbol值,而getOwnPropertyNames() 是得不到对应的symbol值的 Reflect.ownKeys(obj)ES6中定义了一个新的API Reflect.ownKeys(obj) 可以返回所有类型的键名称,包括常规键名和symbol键名 12345678910let obj = &#123; [Symbol(&apos;my_key&apos;)]: 1, enum: 2, nonEnum: 3&#125;console.log(Object.keys(obj)) // [&quot;enum&quot;, &quot;nonEnum&quot;]console.log(Reflect.ownKeys(obj)) //[&quot;enum&quot;, &quot;nonEnum&quot;, Symbol(my_key)] Symbol.for() 和 Symbol.keyFor()有时候我们希望重新使用同一个symbol值, Symbol.for方法可以做到这一点,它接收一个字符串作为参数,然后搜索没有以该字符串作为名称的Symbol值. 如果有,就返回这个Symbol值, 否则就新建一个以该字符串为名称的Symbol值 1234let s1 = Symbol.for(&apos;foo&apos;)let s2 = Symbol.for(&apos;foo&apos;)console.log(s1 === s2) // true 上面的代码中,虽然s1和s2都是Symbol值,但是它们都是同一个Symbol.for生成的,所以是同一个值 Symbol()和Symbol.for()两种写法,都会生成新的Symbol,但是后者会被登记在全局环境中供 搜索,但是前者不会 12console.log(Symbol.for(&apos;bar&apos;) === Symbol.for(&apos;bar&apos;)) // trueconsole.log(Symbol(&apos;bar&apos;) === Symbol(&apos;bar&apos;)) // false 上面的代码中,由于Symbol()没有登记机制,所以每次调用都会返回不同的值 Symbol.keyFor()方法用于返回一个已经登记的Symbol类型值的key 12345let s3 = Symbol.for(&apos;aaa&apos;)let s4 = Symbol(&apos;bbb&apos;)console.log(Symbol.keyFor(s3)) // aaaconsole.log(Symbol.keyFor(s4)) // undefined Proxy概述proxy 用于修改某些操作的默认行为,等同于在语言层面做出修改,所以属于一种元编程, 即对编程语言进行编程 Proxy 可以理解为在目标对象前架设一个拦截层,外界对该对象的访问都必须先通过这一层拦截,因此提供了一钟机制来对外界的访问进行过滤和改写 所以,Proxy 也可以理解为一种代理器 12345678910111213let obj = new Proxy(&#123;&#125;, &#123; get: function(target, key, receiver) &#123; console.log(`getting $&#123;key&#125;`) return Reflect.get(target, key, receiver) &#125;, set: function(target, key, value, receiver) &#123; console.log(`setting $&#123;key&#125;`) return Reflect.set(target, key, value, receiver) &#125;&#125;)obj.count = 1 // setting count obj.count++ // getting count setting count 上面的代码说明, proxy实际上重载了点运算符, 即用自己的定义覆盖了语言的原始定义 一个小技巧是,可以将Proxy对象设置到object.proxy属性,从而可以在object对象上调用 123var object = &#123; proxy: new Proxy(target, handler)&#125; 那么我们就可以直接定义一个proxy对象,并在需要的时候使用Object.create() 进行对象的创建即可 123456789var proxy = new Proxy(&#123;&#125;, &#123; get: function(target, property) &#123; return 35 &#125;&#125;)let obj = Object.create(proxy)console.log(obj.time) ReflectReflect对象和Proxy对象一样, 也是ES6为了操作对象而提供的新api reflect对象的设计目的主要有以下几个 将object对象的一些明显属于语言层面的方法放到reflect对象上. 现阶段, 某些方法同时在object和reflect对象上部署, 未来的新方法将只部署在reflect对象上 修改某些object方法的返回结果, 让其变得更加合理, 如:Object.defineProperty(obj, name, desc) 在无法定义属性时会抛出一个错误, 而Reflect.defineProperty(obj, name, desc)则会返回一个false 让Object操作都变成函数行为, 某些object操作是命令式, 比如name in obj和delete obj[name], 而Reflect.has(obj, name)和Reflect.deleteProperty(obj, name)让他们变成了函数行为 Reflect对象的方法和Proxy对象的方法一一对应, 只要是Proxy对象的方法, 就能在Reflect对象上找到相应的方法. 也就是说, 不管Proxy怎么修改默认行为, 你总可以在Reflect上获取默认行为 123456789Proxy(target, &#123; set: function(target, name, value, receiver) &#123; var success = Reflect.set(target, name, value, receiver) if(success) &#123; log(&apos;property &apos; + name + &apos; on &apos; + target + &apos; set to &apos; + value) &#125; return success &#125;&#125;) 上面的代码中,proxy方法拦截了target对象的属性赋值行为, 它采用Reflect.set方法赋值给对象的属性, 然后再部署额外的功能. (完)","categories":[{"name":"ES6标准入门","slug":"ES6标准入门","permalink":"https://github.com/ChangerHe/categories/ES6标准入门/"}],"tags":[{"name":"ES6","slug":"ES6","permalink":"https://github.com/ChangerHe/tags/ES6/"},{"name":"symbol","slug":"symbol","permalink":"https://github.com/ChangerHe/tags/symbol/"},{"name":"proxy","slug":"proxy","permalink":"https://github.com/ChangerHe/tags/proxy/"},{"name":"reflect","slug":"reflect","permalink":"https://github.com/ChangerHe/tags/reflect/"}]},{"title":"Margin和Padding值设置成百分数的布局","slug":"Margin和Padding值设置成百分数的布局","date":"2017-06-30T11:36:43.000Z","updated":"2017-10-25T03:51:41.577Z","comments":true,"path":"2017/06/30/Margin和Padding值设置成百分数的布局/","link":"","permalink":"https://github.com/ChangerHe/2017/06/30/Margin和Padding值设置成百分数的布局/","excerpt":"","text":"Margin和Padding是我们在网页设计经常使用到的CSS样式，他们分别是间距和填充，一个作用于盒子外面，一个作用于盒子里面，默认的情况下，这些属性的值都会被计算在盒子的面积里面，在网页开发中的流体布局或者是响应式布局中，经常将Margin和Padding设置成百分数，那么到底这个百分数是多少，他是如何计算的呢？ Margin假设我们有这样的一段HTML代码，外面一个DIV宽度980px，高度500px，里面有一个子元素DIV，宽度和高度都不设置，然后给他设置margin:10% 5%，这个属性相当于margin:10% 5% 10% 5%。 123&lt;div class=&quot;demo1&quot;&gt; &lt;div&gt;这个div设置：margin:10% 5%&lt;/div&gt;&lt;/div&gt; CSS代码12.demo1&#123; height:500px; width:980px; margin:0 auto; background:#EEE; overflow:hidden;&#125;.demo1 div&#123;margin:10% 5%; background:#666;&#125; 为了方便查看效果，我们还分别为他们设置了不同的背景。 这里还出现了一个小的hack，就是demo1盒子不会紧挨着body，也就是不会定格布局，而且body元素上面还有一段空白，这段空白的高度刚好是.demo1 div元素的margin-top，demo1和.demo1 div元素都是顶格对其的，只要给demo1元素设置overflow:hidden，即可解决这个问题，点击这里查看示例。 我们根据以往的理解，.demo1 div的margin应该是：50px 49px 50px 49px，但是运行以后，通过查看盒模型示意图，却发现是：98px 49px 98px 49px，这是怎么回事呢 总结从上面的示例和代码，我们可以发现当margin设置成百分数的时候，其top right bottom left的值是参照父元素盒子的宽度进行计算，在w3c的规范中也是这样描述的： margin 的百分比值参照其包含块的宽度进行计算，同样的padding如果设置成百分数的话，其盒子模型和margin是一样的。 这只发生在默认的writing-mode: horizontal-tb;和direction: ltr;的情况下，当书写模式变成纵向的时候，其参照将会变成包含块的高度。 为什么要选择宽度做参照而不是高度呢？ 这其实更多的要从CSS设计意图上去想，因为CSS的基础需求是排版，而通常我们所见的横排文字，其水平宽度一定（仔细回想一下，如果没有显式的定义宽度 或者强制一行显示，都会遇到边界换行，而不是水平延展），垂直方向可以无限延展。但当书写模式为纵向时，其参照就变成了高度而不再是宽度了。","categories":[{"name":"CSS","slug":"CSS","permalink":"https://github.com/ChangerHe/categories/CSS/"}],"tags":[{"name":"CSS","slug":"CSS","permalink":"https://github.com/ChangerHe/tags/CSS/"}]},{"title":"《ES6标准入门》阅读笔记——-对象的扩展","slug":"《ES6标准入门》阅读笔记——-对象的扩展","date":"2017-06-30T05:49:33.000Z","updated":"2017-09-23T13:50:55.999Z","comments":true,"path":"2017/06/30/《ES6标准入门》阅读笔记——-对象的扩展/","link":"","permalink":"https://github.com/ChangerHe/2017/06/30/《ES6标准入门》阅读笔记——-对象的扩展/","excerpt":"","text":"写在前面本系列为在我读完阮一峰老师的《ES6标准入门》第二版之后，所做的阅读笔记的整理。 许多初学ES6, 同时和我一样初次阅读阮老师的这本书的时候, 读第一遍会越发的困惑, 因为阮老师上面说的很多的定义,方法,之前都是没有见过的, 读到后面才发现, 哦~原来是这样. 有一句话叫做”大神的世界我们不懂”, 所以我在初读第一遍《ES6标准入门》这本书的时候,也是踩了不少坑,读书的时候查阅了不少的资料. 所以,在这一系列的笔记教程中,我会从一个初学者的角度,向您讲述ES6的相关知识,在后面介绍的知识我会尽量不提前用,即使提前使用,也会同时做好标注,避免了阅读时各种查阅资料的烦恼. 系列博客将采用一个一个的样例，来说明书中的精华部分（当然，这只是我认为的），同时引导新手，快速入门ES6，并逐步将其投入到生产实践中。 同时,在阅读前也提醒您, 为了系统连贯性的学习ES6的基础知识,建议您从我的博客第一章开始阅读,当然,如果您对对应的知识已经有所了解,那么可以跳转到任意章节阅读,每一篇博客名中均有介绍该博客中涉及到的ES6的内容. 阮一峰老师的这本书是开源的，在其官方博客就可以下载到，但是我强烈建议大家去购买一本书, 一是方便自己查阅ES6中新增的众多API, 二也是表达一下对大神的敬仰. 属性的简洁表示法ES6允许写入变量和函数作为对象的属性和方法, 也就是说,在ES6中是允许在对象中只写属性名,不写属性值的 12345678var foo = &apos;bar&apos;var baz = &#123;foo&#125;console.log(baz) // &#123;foo: &quot;bar&quot;&#125;function f(x, y) &#123; return &#123;x,y&#125;&#125;console.log(f(1, 2)) // &#123;x: 1, y: 2&#125; 除了属性简写,方法也是可以简写的 12345var o = &#123; method() &#123; return &apos;Hello!&apos; &#125;&#125; 等价于 12345var o = &#123; method: function() &#123; return &apos;Hello&apos; &#125;&#125; CommonJS的模块输出变量就非常适合使用简洁写法 123456789101112131415var ms = &#123;&#125;function getItem(key) &#123; return key in ms ? ms[key] : null&#125;function setItem(key, value) &#123; ms[key] = value&#125;function clear() &#123; ms = &#123;&#125;&#125;module.exports = &#123;getItem, setItem, clear&#125; 上面代码的最后一句就等价于 12345module.exports = &#123; getItem: getItem, setItem: setItem, clear: clear&#125; 属性名表达式ES6同时开放了使用表达式放在方括号内,作为字面量的方式定义对象 1234var obj = &#123; [propkey]: true, [&apos;a&apos; + &apos;bc&apos;]: 123&#125; 方法的name属性函数的name属性返回函数名,对象方法也是函数,因此也存在name属性 1console.log((new Function()).name) //anonymous 关于方法的name属性,存在以下几个特点 正常的情况下,函数的函数体的name值返回函数的名称 当我们使用get或者set方法对函数进行描述的时候,会返回对应的前缀加上函数名 当我们使用bind方法创造的函数,函数会有一个bound来修饰 当使用构造函数来创造的函数中,name值固定为anonymous 如果对象的方法是一个symbol值, 那么那么属性返回的是这个symbol值的描述 12345678const key1 = Symbol(&apos;description&apos;)const key2 = Symbol()let obj = &#123; [key1]() &#123;&#125;, [key2]() &#123;&#125;&#125;console.log(obj[key1].name) // &apos;[description]&apos;console.log(obj[key2].name) // &apos;&apos; Object.is()Object.is() 是ES6新定义的方法,用于确定传入的两个参数是否严格相等 但是, 与全等 === 符号唯一不同的地方是 +0不等于-0 NaN等于自身NaN 12345console.log(-0 === +0) // trueconsole.log(NaN === NaN) // falseconsole.log(Object.is(-0, +0)) // falseconsole.log(Object.is(NaN, NaN)) // true 在ES5中可以部署对应的方法, 来模拟Object.is的效果 1234567891011Object.defineProperty(Object, &apos;is&apos;, &#123; value: function(x, y) &#123; if (x === y) &#123; return x !== 0 || 1 / x === 1 / y &#125; return x !== x &amp;&amp; y !== y &#125;, configurable: true, enumerable: false, writable: true&#125;) Object.assign()Object.assign() 方法将源对象的所有可枚举属性复制到目标对象 123456let target = &#123;a: 1&#125;let source1 = &#123;b: 2&#125;let source2 = &#123;c: 3&#125;Object.assign(target, source1, source2)console.log(target) // &#123;a: 1, b: 2, c: 3&#125; 同样的,Object.assign 方法可以用来复制数组,但是因为会将数组视为一个对象,所以后面数组的对应数组下标的值会覆盖之前的数组的下标的值 1234var a = [1, 2, 3]var b = [4, 5]Object.assign(a, b)console.log(a) // [4,5,3] 使用Object.assign可以将原始对象赋值到一个空对象, 就得到了原始对象的克隆 123function clone(origin) &#123; return Object.assign(&#123;&#125;, origin)&#125; 通过将对象赋值到一个空对象的方式,获得了这个origin对象的克隆 不过,采用这种方法克隆,只能克隆原始对象自身的值,而不能克隆它继承的值 那么,如果想要获得保持原型链的对象,那么就需要使用这样的方法 1234function clone(origin) &#123; let originProto = Object.getPrototypeOf(origin) return Object.assign(Object.create(originProto), origin)&#125; 实现方式就是这样的,使用getPropertyOf方法获取了origin的原型,然后将函数体合并到原型中,并返回 当使用Object.assign() 对两个对象进行合并的时候,不论前面对应对象名称的内容是什么,其内容都会被替换掉 123456789var target = &#123; a: &#123;b: &apos;c&apos;,d: &apos;e&apos;&#125;&#125;var source = &#123; a: &#123;b: &apos;hello&apos;&#125;&#125;Object.assign(target, source)console.log(target) // a:&#123;b: &quot;hello&quot;&#125; 属性的可枚举性ES6规定,所有class的原型的方法都是不可枚举的 123456var a = Object.getOwnPropertyDescriptor( class &#123; foo() &#123;&#125; &#125;.prototype, &apos;foo&apos;).enumerableconsole.log(a) // false proto属性proto属性用来读取或设置当前对象的prototype对象, 这个属性其实在很早版本的chrome Firefox Opera等现代浏览器中都已经得到了支持,被广泛用于查找原型上的方法和属性. 但是IE迟迟得不到支持,在ES6中,此属性被写到了规范中 让人欣喜的是,IE11开始,也支持此属性了 对应的, ES6也同时推出了Object.setPrototypeOf()方法, 该方法的作用与proto是相同的,只不过proto是一个内部方法, 因此TC39推荐使用Object.setPrototypeOf()来设置原型对象的方法. 对象的扩展运算符ES7有个提案, 将rest参数,也就是扩展运算符引入对象,目前babel已经支持 rest参数(扩展运算符) 用于从一个对象取值,相当于将所有可遍历但尚未被读取的键但尚未读取的属性,分配到指定的对象上,所有的键及相应的值都会被赋值到新对象上 123456789let &#123;x, y, ...z&#125; = &#123; x: 1, a: 3, y: 2, b: 4,&#125;console.log(x) // 1console.log(y) // 2console.log(z) // &#123;a: 3, b: 4&#125; 目前在Chrome中测试, 尚未支持上面的方法 有一点要注意的是,rest参数的复制是浅复制 1234let obj = &#123;a: &#123;b: 1&#125;&#125;let &#123;...x&#125; = objobj.a.b = 2console.log(x.a.b) // 2","categories":[{"name":"ES6标准入门","slug":"ES6标准入门","permalink":"https://github.com/ChangerHe/categories/ES6标准入门/"}],"tags":[{"name":"ES6","slug":"ES6","permalink":"https://github.com/ChangerHe/tags/ES6/"},{"name":"Object","slug":"Object","permalink":"https://github.com/ChangerHe/tags/Object/"}]},{"title":"《ES6标准入门》阅读笔记——-函数的扩展","slug":"《ES6标准入门》阅读笔记——-函数的扩展","date":"2017-06-28T13:36:55.000Z","updated":"2017-09-23T13:13:22.892Z","comments":true,"path":"2017/06/28/《ES6标准入门》阅读笔记——-函数的扩展/","link":"","permalink":"https://github.com/ChangerHe/2017/06/28/《ES6标准入门》阅读笔记——-函数的扩展/","excerpt":"","text":"写在前面本系列为在我读完阮一峰老师的《ES6标准入门》第二版之后，所做的阅读笔记的整理。 许多初学ES6, 同时和我一样初次阅读阮老师的这本书的时候, 读第一遍会越发的困惑, 因为阮老师上面说的很多的定义,方法,之前都是没有见过的, 读到后面才发现, 哦~原来是这样. 有一句话叫做”大神的世界我们不懂”, 所以我在初读第一遍《ES6标准入门》这本书的时候,也是踩了不少坑,读书的时候查阅了不少的资料. 所以,在这一系列的笔记教程中,我会从一个初学者的角度,向您讲述ES6的相关知识,在后面介绍的知识我会尽量不提前用,即使提前使用,也会同时做好标注,避免了阅读时各种查阅资料的烦恼. 系列博客将采用一个一个的样例，来说明书中的精华部分（当然，这只是我认为的），同时引导新手，快速入门ES6，并逐步将其投入到生产实践中。 同时,在阅读前也提醒您, 为了系统连贯性的学习ES6的基础知识,建议您从我的博客第一章开始阅读,当然,如果您对对应的知识已经有所了解,那么可以跳转到任意章节阅读,每一篇博客名中均有介绍该博客中涉及到的ES6的内容. 阮一峰老师的这本书是开源的，在其官方博客就可以下载到，但是我强烈建议大家去购买一本书, 一是方便自己查阅ES6中新增的众多API, 二也是表达一下对大神的敬仰. 函数的默认值在ES6之前,函数的默认值只能在函数体内进行判断 123456789function log(x, y) &#123; y = y || &quot;world&quot; console.log(x, y)&#125;log(&quot;hello &quot;) // hello world// 当我们采用ES5的写法时,是存在问题的,当我们给第二个参数传入布尔值为false的值的时候,实际上并不会使用这个值而是仍然使用默认值.log(&quot;hello &quot;, false) // hello worldlog(&quot;hello &quot;, &quot;&quot;) // hello worldlog(&quot;hello &quot;, undefined) // hello world 在ES6中就不会有这个烦恼了,ES6允许将参数设置默认值,直接写在参数定义的后面即可 1234567function log(x, y = &quot;world&quot;) &#123; console.log(x, y)&#125;log(&quot;hello &quot;) // hello worldlog(&quot;hello &quot;, false) // hello falselog(&quot;hello &quot;, &quot;&quot;) // hello log(&quot;hello &quot;, undefined) // hello world 由此可见,ES6的写法比之前更加自然,也更加的语义化了. 123456789function Point(x = 0, y = 0) &#123; this.x = x this.y = y&#125;var p1 = new Point()console.log(p1.x, p1.x) // 0 0var p2 = new Point(2)console.log(p2.x, p2.y) // 2 0 因为变量的参数是默认声明的,所以我们在内部重新使用let或const对变量声明的时候,是会报错的 123456function foo(x = 5) &#123; let x = 1 // 报错 const x = 1 // 报错&#125;## 函数的默认值与解构赋值默认值结合使用 function foo({x, y = 5}) { console.log(x, y)}foo({}) // undefined 5foo({x: 1}) // 1 51234在为函数使用解构赋值时,因为有必填的参数,所以这个情况下必须要填需要的参数,否则会报错.但是当我们在这种情况下,如果不想让它报错的话,可以使用双重解赋值的方法解决此问题 function fetch(url, {method = “GET”} = {}) { console.log(method)}fetch(“http://example.com“) // GET12## 解构赋值的默认值和函数默认值的区别 function m1({x = 0, y = 0} = {}) { return [x, y]}1234以上代码将函数参数默认值设置为空对象, 但设置了对象解构赋值的默认值我们在来看一下下面的代码 function m2({x, y} = {x: 0, y: 0}) { return [x, y]}12在函数都有参数或都没有参数的情况下,两者是相等的 m1() // [0, 0]m2() // [0, 0]m1({x: 3, y: 8}) // [3, 8]m2({x: 3, y: 8}) // [3, 8]12但是在当一个有值,一个没有值的情况下,区别就显现出来了 m1({x: 3}) // [3, 0]m2({x: 3}) // [3, undefined]12当我们传入的是不同的对象的时候, m1的默认值为0, 所以, 会输出0, 而因为输入的对象与解构赋值的默认值不匹配,所以会输出undefined m1({z: 3}) // [0, 0]m2({z: 3}) // [undefined, undefined]12当我们将非尾部的参数设置了默认值,那么这个时候这个参数是没有办法省略的 function f(x = 1, y) { return [x, y]}console.log(f()) // [1, undefined]console.log(f(1)) // [1, undefined]console.log(f(, 1)) // 报错12345678## 参数默认值的位置通常情况下,定义了默认值的参数应该是函数的尾参数.因为这样比较容易看出到底省略了哪些参数,如果非尾部的参数设置默认值实际上这个参数是无法省略的. 换句话说,就是当中间设置了默认值,如果要给其后的非指定默认值参数设置值的话,必须要给这个参数设置值,或者显式的设置undefined或null, 否则会报错 function f(x, y = 5, z) { return [x, y, z]}console.log(f()) // [undefined, 5, undefined]console.log(f(1)) // [1, 5, undefined]console.log(f(1, undefined, 3)) // [1, 5, 3]console.log(f(1, , 2)) // 报错123456## 函数的length属性指定了默认值后.函数的length属性将会返回没有指定默认值的参数个数,也就是说,指定了默认值后,length属性将会失真同时,经过测试,当我们设置默认值在前时,其实显示的形参个数是设置默认值的形参前面的形参个数,后面的形参个数是不计入在内的 console.log((function(x) {}).length) // 1console.log((function(x = 90, a, b) {}).length) // 0console.log((function(x, a = 90, b) {}).length) // 1console.log((function(x, a, b = 90) {}).length) // 212同样的,因为rest参数,也就是俗称的三点运算符的特殊性,其长度是不会计入length属性的 console.log((function(…args){}).length) // 01234## 函数的作用域一个需要注意的地方是,如果参数默认值是一个变量,则该变量所处的作用域与其他的变量的作用域是一样的,即先是当前函数的作用域,然后才是全局作用域 let x = 1 function f(x, y = x) { console.log(y) // 2}f(2)123456上面的代码中,参数的默认值等于x. 调用时, 由于函数作用域内部的变量x已经生成, 所以y等于参数x而不是全局变量x但当调用的时候函数作用域内部的变量x没有生成,那么x就会指向全局变量,因为全局变量中没有这个参数,所以y依然指向自身另外说明一下,这个和阮一峰老师的书中结果是不一致的,经过在chrome59版本下测试,结果为1 function f1(y = x) { let x = 2 console.log(y) // 1}f1(1)1234## 函数的参数默认值的小应用引用参数默认值,可以指定某一个参数不得省略,否则会抛出一个错误 throwIfMissing = () =&gt; { throw new Error(‘Missing parameter’)} function foo(mustBeProvided = throwIfMissing()) { return mustBeProvided} foo() // Error: Missing parameter1234# rest参数(三点运算符)在ES6中引入了rest参数, 用于获取函数的多余参数,这样就不需要使用arguments对象了,rest参数搭配的变量是一个数组,该变量将多余的参数放入其中 function add(…values) { let sum = 0 console.log(values) // [2, 3, 4] for (var val of values) { sum += val } return sum}console.log(add(2, 3, 4)) // 912下面是rest参数代替arguments变量的例子 //在ES5中const shortNumbers = () =&gt; { return Array.prototype.slice.call(arguments).sort()}12// 使用rest参数无疑让写法更加简洁自然了 const sortNumbers = (…numbers) =&gt; { return numbers.sort()} 使用rest参数的特性,可以改写push方法12345678function push(array, ...items) &#123; items.forEach(function(item) &#123; array.push(item) &#125;) return array&#125;console.log(push([1, 2, 3], 1, 2, 3, 4, 54)) // [1, 2, 3, 1, 2, 3, 4, 54] 扩展运算符 …扩展运算符好比rest参数的逆运算,将一个数组转为用逗号分隔的参数序列 12345678console.log(...[1, 2, 3]) // 1 2 3console.log(1, ...[2, [[3], 4]], 5) // 1, 2, [[3], 4]], 5## 扩展运算符的应用### 替代数组的apply方法在ES5之前,我们如果需要将数组的值作为函数的参数逐一传进函数的时候,最简便的方法就是使用apply方法 function f(x, y, z) {}var args = [1, 2, 3]f.apply(null, args)12在ES6中,写法是这样的 function f2(x, y, z) {}var args = [0, 1, 2]f2(…args)1234### 替代Math.max方法当我们需要对数组进行最大最小值的判断的时候,在ES5中,用法是这样的 var a = [1, 2, 4, 12, 3, 5, 1, 12]console.log(Math.max.apply(null, a)) // 1212但是在ES6中,我们就不必要这么麻烦了,因为扩展运算符 ... 可以将数组直接转换为普通的单个数字 var a = [1, 2, 4, 12, 3, 5, 1, 12]console.log(Math.max(…a)) // 121234### 替代push方法同样的,在ES5中,如果我们需要使用push方法将两个数组连接起来的时候,我们需要这样做 var a = [1, 2, 3]var b = [4, 5, 6]Array.prototype.push.apply(a, b)console.log(a) // [1, 2, 3, 4, 5, 6]console.log(b) // [4, 5, 6]1234因为最后需要得到扁平化的数组,所以并不能直接使用`a.push(b)`这样的方法,这样会使得到的变成多维数组同样的,ES6还提供了数组合并的新写法: var a = [1, 2, 3]var b = [4, 5, 6]a.push(…b)console.log(a) // [1, 2, 3, 4, 5, 6]console.log(b) // [4, 5, 6]12### 替代数组合并方法 var a = [1, 2, 3]var b = [4, 5, 6]var c = a.concat(b)console.log(c) // [1, 2, 3, 4, 5, 6]12在ES6中,因为有了 ... 运算符,那么其实concat是可以省略的 var a = [1, 2, 3]var b = [4, 5, 6]var d = […a, …b]console.log(d) // [1, 2, 3, 4, 5, 6]1234### 与解构赋值结合起来,用于生成数组那么,我们先来看一下,在ES5中,是怎么做到的 let a = [1, 2, 3, 4]let b = a[0]let c = a.slice(1)console.log(b, c) // 1 [2, 3, 4]12那么在ES6中,这样的形式就很容易实现了,通过解构赋值和三点运算符结合的方式 let a = [1, 2, 3, 4]let [d, …e] = aconsole.log(d, e) // 1 [2, 3, 4]12当我们对一个空的数组进行解构赋值的时候,会出现什么情况呢? let [f, …g] = []console.log(f, g) //undefined []let [h, …i] = [‘foo’]console.log(h, i) // foo []12需要注意的是,我们使用扩展运算符,也就是三点运算符,这个运算是必须要放在参数的最后一位的,否则会报错 let […j, k] = [1, 2, 3, 4]console.log(j, k)//报错,Rest element must be last element12## 扩展运算符对字符串的支持 console.log([…’hello’]) // [“h”, “e”, “l”, “l”, “o”]// 扩展运算符将字符串中的每一个值都拆分成了单个的字符组成的数组12当然,这还不是最重要的,重要的是, 扩展运算符对32位Unicode字符的支持 console.log([…’x\\u{20bb7}\\u20bb7’].length) // 4// 可见,两个大括号完美地解决了32位字符这个bug的尴尬1234对于unicode不太了解的童鞋, 可以先跳转到之前,看下我写的ES6中对Unicode的支持这一章节括展运算符内部调用的是数据结构的iterator接口,因此只要具有iterator接口的对象,都可以使用扩展运算符 let map = new Map([ [1, ‘one’], [2, ‘two’], [3, ‘three’]])let arr = […map.values()]console.log(arr)12Generator函数运行后返回一个遍历器对象,因此也可以使用扩展运算符 var go = function*() { yield 1 yield 2 yield 3 }console.log([…go()])123456# 函数的name属性函数的name属性返回该函数的函数名通过bind返回的函数, name属性会加上&apos;bound&apos;前缀 function foo() {}console.log(foo.name) // foofunction foo() {}console.log(foo.bind({}).name) //bound foo12345678# ES6的箭头函数ES6允许使用箭头定义函数` var f = v =&gt; v `上面的箭头其实就等价于 var f = function(v) { return v}12345678那么,上面是需要参数的情况下,当我们不需要参数的时候怎么办呢?在这个情况下是可以使用圆括号代替的`var f = () =&gt; 5`等价于 var f = function() { return 5}123456当存在多个参数的时候`var f = (num1, num2) =&gt; num1 + num2`等价于 var f = function(num1, num2) { return num1 + num2}1234如果箭头函数的代码块部分多于一条语句, 就要使用大括号将其括起来, 并使用return语句返回由于大括号被解释为代码块,所以当我们需要箭头函数返回一个对象的时候,需要使用圆括号将对象括起来 var f = id =&gt; ({ id: id, name: ‘temp’})12还有一点是,箭头函数还可以和解构赋值一起使用 var full = ({first, last}) =&gt; first + ‘ ‘ + last12等价于 var full = function(person) { return first + “ “ + last}1234567891011121314151617181920212223242526箭头函数的另一个用处就是简化回调函数`[1, 2, 3].map(x =&gt; x * x)`等价于`[1, 2, 3].map(function(x) &#123;return x * x&#125;)`rest参数的写法`const headAndTail = (head, ...tail) =&gt; [head, tail]`# 箭头函数的使用注意点&gt;函数体内的this对象就是定义的时候所在的对象,而不是使用的时候所在的对象&gt;不可以拿来当做构造函数,也就是不可以拿来new一下,否则会抛出一个错误&gt;不可以使用arguments对象,该对象在函数体内是不存在的,如果需要使用,可以使用rest参数将arguments对象转为数组之后使用&gt;不可以使用yield命令,因此箭头函数不能用作Generator参数# 箭头函数中的thisthis的指向在之前是可变的,但是在箭头函数中是固定的 function foo() { setTimeout(() =&gt; { console.log(‘id:’, this.id) // id: 42 }, 100)} foo.call({id: 42})12而且不论嵌套多少层,都是没有问题的,朝阳指向调用的对象 function foo3() { return () =&gt; { return () =&gt; { console.log(‘id: ‘, this.id) // id: 42 } }}foo3.call({id: 42})()()12因为箭头函数没有自己的this, 所以我们在内部绑定this,是不能生效的 var a = (function() { return [ (() =&gt; this.x).bind({ x: ‘inner’ }) ]}).call({ x: ‘outer’})console.log(a()) // () =&gt; this.x12箭头函数的内部还可以再使用箭头函数 function insert(value) { return { into: function(array) { return { after: function(afterValue) { array.splice(array.indexOf(afterValue) + 1, 0, value) } } } }} console.log(insert(2).into([1, 3]).after(1)) // [1, 2, 3]123456# 函数绑定箭头函数可以绑定this对象, 大大减少了显式绑定this对象的写法, 但是因为this在箭头函数中的特殊性,因此其并不适用于所有场合所以ES7提出了函数绑定的写法, 目前浏览器暂不支持,但babel转码器已经支持 foo::bar// 等同于bar.bind(foo)```","categories":[{"name":"ES6标准入门","slug":"ES6标准入门","permalink":"https://github.com/ChangerHe/categories/ES6标准入门/"}],"tags":[{"name":"ES6","slug":"ES6","permalink":"https://github.com/ChangerHe/tags/ES6/"},{"name":"Function","slug":"Function","permalink":"https://github.com/ChangerHe/tags/Function/"}]},{"title":"《ES6标准入门》阅读笔记——-数组的扩展","slug":"《ES6标准入门》阅读笔记——-数组的扩展","date":"2017-06-25T14:34:21.000Z","updated":"2017-09-18T02:59:23.397Z","comments":true,"path":"2017/06/25/《ES6标准入门》阅读笔记——-数组的扩展/","link":"","permalink":"https://github.com/ChangerHe/2017/06/25/《ES6标准入门》阅读笔记——-数组的扩展/","excerpt":"","text":"写在前面本系列为在我读完阮一峰老师的《ES6标准入门》第二版之后，所做的阅读笔记的整理。 许多初学ES6, 同时和我一样初次阅读阮老师的这本书的时候, 读第一遍会越发的困惑, 因为阮老师上面说的很多的定义,方法,之前都是没有见过的, 读到后面才发现, 哦~原来是这样. 有一句话叫做”大神的世界我们不懂”, 所以我在初读第一遍《ES6标准入门》这本书的时候,也是踩了不少坑,读书的时候查阅了不少的资料. 所以,在这一系列的笔记教程中,我会从一个初学者的角度,向您讲述ES6的相关知识,在后面介绍的知识我会尽量不提前用,即使提前使用,也会同时做好标注,避免了阅读时各种查阅资料的烦恼. 系列博客将采用一个一个的样例，来说明书中的精华部分（当然，这只是我认为的），同时引导新手，快速入门ES6，并逐步将其投入到生产实践中。 同时,在阅读前也提醒您, 为了系统连贯性的学习ES6的基础知识,建议您从我的博客第一章开始阅读,当然,如果您对对应的知识已经有所了解,那么可以跳转到任意章节阅读,每一篇博客名中均有介绍该博客中涉及到的ES6的内容. 阮一峰老师的这本书是开源的，在其官方博客就可以下载到，但是我强烈建议大家去购买一本书, 一是方便自己查阅ES6中新增的众多API, 二也是表达一下对大神的敬仰. 新增的API–Array.from()Array.from() 方法将两类对象转为真正的数组:类数组对象和可遍历对象 1234567891011let arrayLike = &#123; &apos;0&apos;: &apos;a&apos;, &apos;1&apos;: &apos;b&apos;, &apos;2&apos;: &apos;c&apos;, length: 3&#125;var arr1 = Array.prototype.slice.call(arrayLike)console.log(arr1) // [1,2,3]let arr2 = Array.from(arrayLike)console.log(arr2) // [1,2,3] 可见,在将类数组转换为数组的过程中,使用ES6定义的新方法能够更好且更简单地将类数组转换为真正的数组. 在实际应用中,我们最常见的对象是DOM操作返回的NodeList集合,同样的,使用这个方法就可以实现将相应的类数组对象转换为数组 123let nameSet = new Set([&apos;a&apos;, &apos;b&apos;])var a = Array.from(nameSet)console.log(a) // [&apos;a&apos;, &apos;b&apos;] 注: Set是ES6中的新的数据结构, 类似于数组, 但是成员的值都是唯一的, 没有重复的值, 这是Set结构的最大特征. 如果对象是一个真的数组,那么使用Array.from() 方法会返回一个和原来一模一样的新数组 12345let a = [1, 2, 3]let b = Array.from(a)a = [3, 2, 1]console.log(a) // [3,2,1]console.log(b) // [1,2,3] 扩展运算符也可以将某些数据结构转为数组那么,我们可以对函数的变量arguments进行相应的处理,让其变成真正的数组 123function foo() &#123; var args = [...arguments]&#125; 那么同样的,我们也可以对HTML的元素对象进行相应的操作 1[...document.querySelectorAll(&apos;div&apos;)] 扩展运算符背后调用的是遍历器接口Iterator, 如果一个对象没有部署该接口就无法进行转换, Iterator将在后面详细讲解. 但是,所有的转换,一个最大的前提条件是,必须要有一个length对象,保存一个数值,没有这个属性的话是没有办法转为数组的 对于没有部署Array.from() 方法的浏览器,我们可以使用对应的老方法和新方法进行结合模拟 123const toArray = (() =&gt; Array.from ? Array.from : obj =&gt; [].slice.call(obj)) 注: 箭头函数也是ES6中新定义的方法, 其实是一种语法糖,方便我们进行编程而已.() =&gt; console.log(1) 等价于 function() {console.log(1)} Array.from 方法还可以接受第二个参数,作用类似于数组的map方法,用来对每个元素进行处理,并将处理后的值放入返回的数组 12345678910111213let arrayLike = &#123; &apos;0&apos;: &apos;a&apos;, &apos;1&apos;: &apos;b&apos;, &apos;2&apos;: &apos;c&apos;, length: 3&#125;Array.from(arrayLike, x =&gt; x * x)// 其实上面的方法就等同于下面的方法Array.from(arrayLike).map(function(x) &#123; return x * x&#125;)// 上面是使用ES5的方法所写的方法,我们可以将函数转换为箭头函数的形式Array.from(arrayLike).map(x =&gt; x * x) 利用这个特性,可以很容易地将数组的空位置零 12let a = Array.from([1,,2,,5], (x) =&gt; x || 0)console.log(a) // [1,0,2,0,5] 数组的Array.of()方法Array.of() 方法用于将一组值转换为数组 123console.log(Array.of(1, 8, 3)) // [1,8,3]console.log(Array.of(3)) // [3]console.log(Array.of()) // [] 其实这个方法的主要目的,是弥补构造函数Array的不足, 因为参数的不同会导致Array的行为有所差异 123console.log(Array()) // []console.log(Array(3)) // [,,,]console.log(1,2,3) // [1,2,3] 因此, 不同于直接使用Array方法, 使用Array.of()方法不论你传入的是一个数,还是几个数,其实最后都是返回的数组对象, 而不同于使用Array, 会产生不同的行为. 数组的copyWithin() 方法数组的copyWithin()方法, 主要的作用是在当前数组内部将指定位置的成员复制到其他位置, 此方法接受三个参数 target 必需值,从该位置开始替换数据, 也就是说, 从这个地方开始要更改数组了atart 可选值,从该位置开始读取数据,默认为0 , 若为负值,则表示倒数, 也就是说, 我要更改数组,总得找个东西替换这些个之前的数组呀. 那么我就从这个位置开始截取数组的值,把它放到要更改的地方end 到该位置前停止读取数据,默认等于数组长度,如果为负值,表示倒数, 也就是说,截取也不能截取个没完嘛,所以需要在这个地方停止截取, 然后就把截取的值丢到target的那个位置了. 123let a = [1, 2, 3, 4, 5]a.copyWithin(3, 1, 2)console.log(a) // [1, 2, 3, 2, 5] 由上可见,其实copyWithin()最终更改了, 第四个位置, 也就是a[3] 的值 数组的find() 方法和findIndex() 方法数组的find() 方法,用于找出第一个符合条件的数组成员.数组成员依次执行其后的回调函数,直到找出第一个匹配的成员,否则返回undefined 下面的代码找出了数组中小于0 的成员, 并将其打印出来 12let a = [1, 2, 3, -4, 3]console.log(a.find((x) =&gt; x &lt; 0)) // -4 find方法可以接受三个参数, 依次为当前值, 当前位置和原数组. 12let b = [1, 5, 10, 15].find((value, index, arr) =&gt; value &gt; 9)console.log(a) // 10 数组的findeIndex() 方法返回第一个符合条件的数组成员的位置, 如果所有成员都不符合条件,则返回-1 这两个方法还可以接受第二个参数,用来绑定回调函数的this对象 还有重要的一点是,这两个方法都可以发现NaN,弥补了之前NaN支持的不足 12345let a = [NaN].indexOf(NaN)console.log(a) // -1let b = [NaN].findIndex(y =&gt; Object.is(NaN, y))console.log(b) // 0 注: Object.is() 用来比较两个值是否严格相等. 它与全等运算符表现基本一致, 但增加了NaN的支持. 数组的fill() 方法数组实例的fill() 该方法使用给定值填充数组 12console.log([&apos;a&apos;, &apos;b&apos;, &apos;c&apos;].fill(1)) // [1, 1, 1]console.log([&apos;a&apos;, &apos;b&apos;, &apos;c&apos;].fill(7, 1, 2)) // [&quot;a&quot;, 7, &quot;c&quot;] 这样对数组进行初始化非常的方便,该方法还可接受另外两个可选参数,规定填充的起始和结束位置 数组遍历ES6提供了三个新方法用于遍历数组 keys() 对键名的遍历values() 对键值的遍历entries() 对键值对的遍历 123456789for (let index of [&apos;a&apos;, &apos;b&apos;].keys()) &#123; console.log(index) // 0 // 1&#125;for (let index of [&apos;a&apos;, &apos;b&apos;].values()) &#123; console.log(index) // &apos;a&apos; // &apos;b&apos;&#125;for (let index of [&apos;a&apos;, &apos;b&apos;].entries()) &#123; console.log(index) // 0 &apos;a&apos; // 1 &apos;b&apos;&#125; 注: for…of 遍历也是对循环的一种补充,与for…in类似,但不会枚举出对象上的可枚举属性 数组的includes()includes() 方法返回一个实例,表示某数组是否包含给定的值 123let a = [1, 2, 3]console.log(a.includes(2)) // trueconsole.log(a.includes(4)) // false 当浏览器不兼容的时候,可以使用indexOf方法进行替代但是indexOf有一个弊端,原因是indexOf内部使用的是全等操作符进行匹配,所以这个时候当我们判定NaN的时候,是无法判定成功的, 因为NaN!==NaN 1console.log([NaN].indexOf(NaN)) // -1 数组的空位ES5在很多情况下,对于数组的空位是直接忽略的,例如forEach filter every some 等方法会跳过空位, map 会跳过空位,但会保留这个值, join 和 toString 会将空位视为undefined 而undefined和null会被处理为字符串 下面是ES5下的方法 1234567891011121314[, &apos;a&apos;].forEach((x, i) =&gt; console.log(i)); // 1 因为第零个是空位,被忽略了console.log([, &apos;a&apos;].filter((x, i) =&gt; true)); // [&quot;a&quot;] 小红书有讲过的方法,使用true将数组的空位去除console.log([, &apos;a&apos;].every((x, i) =&gt; x !== undefined)) // trueconsole.log([, &apos;a&apos;].some((x, i) =&gt; x === undefined)) // falseconsole.log([, &apos;a&apos;].map((x, i) =&gt; 1));// [empty × 1, 1]console.log([, &apos;a&apos;, undefined, null].join(&apos;#&apos;)) // #a##` 但在ES6中,空位会被明确转为undefined 12console.log([...[&apos;a&apos;, , &apos;b&apos;]]) //[&quot;a&quot;, undefined, &quot;b&quot;] copyWithin()会连空位一起复制 1[, &apos;a&apos;, &apos;b&apos;, ,].copyWithin(2, 0) //[empty × 1, &quot;a&quot;, empty × 1, &quot;a&quot;] fill()会将空位视为正常的数组位置 1new Array(3).fill(&apos;a&apos;) // [&apos;a&apos;, &apos;a&apos;, &apos;a&apos;] for…of循环也会遍历空位, 而map却不会遍历空位 1234let arr = [, ,]for(let i of arr) &#123; console.log(1) // 1 // 1&#125; 数组推导数组推导是ES7中的新方法,允许直接通过现有数组生成新数组. 本来TC39是计划将其放入ES6的,但TC39仍然想完善它,让其支持所有数组结构. 所以推迟到了ES7. 12345let a1 = [1, 2, 3, 4]var a2 = [ for (i of a1) i * 2];console.log(a2) // [2, 4, 6, 8] (完)","categories":[{"name":"ES6标准入门","slug":"ES6标准入门","permalink":"https://github.com/ChangerHe/categories/ES6标准入门/"}],"tags":[{"name":"ES6","slug":"ES6","permalink":"https://github.com/ChangerHe/tags/ES6/"},{"name":"Array","slug":"Array","permalink":"https://github.com/ChangerHe/tags/Array/"}]},{"title":"《ES6标准入门》阅读笔记——-number类型的扩展","slug":"《ES6标准入门》阅读笔记——-number类型的扩展","date":"2017-06-22T15:41:23.000Z","updated":"2017-09-18T00:41:30.254Z","comments":true,"path":"2017/06/22/《ES6标准入门》阅读笔记——-number类型的扩展/","link":"","permalink":"https://github.com/ChangerHe/2017/06/22/《ES6标准入门》阅读笔记——-number类型的扩展/","excerpt":"","text":"写在前面本系列为在我读完阮一峰老师的《ES6标准入门》第二版之后，所做的阅读笔记的整理。 许多初学ES6, 同时和我一样初次阅读阮老师的这本书的时候, 读第一遍会越发的困惑, 因为阮老师上面说的很多的定义,方法,之前都是没有见过的, 读到后面才发现, 哦~原来是这样. 有一句话叫做”大神的世界我们不懂”, 所以我在初读第一遍《ES6标准入门》这本书的时候,也是踩了不少坑,读书的时候查阅了不少的资料. 所以,在这一系列的笔记教程中,我会从一个初学者的角度,向您讲述ES6的相关知识,在后面介绍的知识我会尽量不提前用,即使提前使用,也会同时做好标注,避免了阅读时各种查阅资料的烦恼. 系列博客将采用一个一个的样例，来说明书中的精华部分（当然，这只是我认为的），同时引导新手，快速入门ES6，并逐步将其投入到生产实践中。 同时,在阅读前也提醒您, 为了系统连贯性的学习ES6的基础知识,建议您从我的博客第一章开始阅读,当然,如果您对对应的知识已经有所了解,那么可以跳转到任意章节阅读,每一篇博客名中均有介绍该博客中涉及到的ES6的内容. 阮一峰老师的这本书是开源的，在其官方博客就可以下载到，但是我强烈建议大家去购买一本书, 一是方便自己查阅ES6中新增的众多API, 二也是表达一下对大神的敬仰. 二进制和八进制的新写法ES6的更新同时带来了二进制和八进制数组的新写法, 分别使用0b 和 0o表示 不同于之前在ES5中,我们使用八进制字面量, 在严格模式下是无效的: 123&quot;use strict&quot;var octalNum = 070console.log(octalNum) (不过经过测试,在ES6环境下,这个语句可以正常运行. 这要归功于ES6带来的强大的性能, 这一点需要说明一下) 在ES6环境下,我们可以直接使用 12345console.log(0o11 === 011) // true&apos;use strict&apos;console.log(0o11 === 011) // trueconsole.log(Number(&apos;0b111&apos;)) // 7console.log(Number(&apos;0o10&apos;)) // 8 Number.isFinite()ES6提供了判断数字是否有穷的方法 Number.isFinite() 到这里很多同学很惊讶,这个isFinite()方法不是应该是ES5所出现的吗? 其实是这样的, 在ES6之前,我们调用这个方法是直接在window 上面调用的, 而在ES6中, 将这些数学方法集成到了Number类中. 1234console.log(Number.isFinite(15)) // trueconsole.log(Number.isFinite(&apos;15&apos;)) // falseconsole.log(Number.isFinite(NaN)) // falseconsole.log(Number.isFinite(Infinity)) // false 需要注意的是,当我们传入字符串进去的时候,是不会对我们传入值进行隐式类型转换的 Number.isNaN()同样的, 本来之前在window上面的方法isNaN()也被同时放到了Number类上 1234console.log(Number.isNaN(NaN)) // trueconsole.log(Number.isNaN(15)) // falseconsole.log(Number.isNaN(&apos;15&apos;)) // falseconsole.log(Number.isNaN(&apos;true&apos; / &apos;true&apos;)) // true 两种方法的区别那么,为了遵循线性增强的规则, ES6中也保留了在ES5中的之前的方法. 但是两种方法是存在区别的, 最大的区别在于, Number类下的方法不会进行隐式类型转换 1234console.log(isFinite(25)) // trueconsole.log(isFinite(&apos;25&apos;)) // trueconsole.log(Number.isFinite(25)) // trueconsole.log(Number.isFinite(&apos;25&apos;)) // 因为不存在隐式类型转换的过程,所以这里打印值为false 综上所述, ES6在数值类上的一个创新是,将一些数组类的全局方法逐步转移到Number类型下来,从而达到逐步减少全局方法的目的,实现语言的逐步模块化 1console.log(Number.parseFloat === parseFloat) // true Number.isInterger()Number.isInterger() 方法,用来判断一个值是否为整数,需要注意的是,在javascript内部,整数和浮点数是采用的相同的存储方法的,所以3 和 3.0 其实是全等的 1234console.log(3 === 3.0)console.log(Number.isInteger(3))console.log(Number.isInteger(3.0)) // trueconsole.log(Number.isInteger(3.1)) // false Number.EPSILONNumber.EPSILON 是Number对象引入的一个极小的常量,目的在于解决浮点数计算不精确的问题 123456console.log(Number.EPSILON) //2.220446049250313e-16// 当两者相减,误差小于Number.EPSILON的时候,我们可以判定两数是完全相等的function equal(num1, num2) &#123;return Math.abs(num1 - num2) &lt; Number.EPSILON ? true : false;console.log(equal(.1 + .2, .3)) // true 要知道,在这之前, .1 + .2 != .3 因为浮点的运算精度问题,导致出现了一点点的小误差 安全整数javascript可以准确地表示在2的负53次方到2的正53次方之间的整数,超出则无法精确显示 1console.log(Math.pow(2, 53) === Math.pow(2, 53) - 1) // 返回的是false,书上的有问题 数学对象处理的其他方法在ES6中,新增了17个对数学对象处理相关的方法 Math.trunc() 用于取出一个数的小数部分,返回整数部分 Math.sign() 用于判断一个数到底是整数,还是负数,还是零 Math.cbrt() 用于计算一个数的立方根 Math.clz32() 用于返回一个数的32位二进制的数值表示的数,前面有多少个前导零 Math.imul() 返回两个数以32位带符号整数形式相乘的结果,返回的也是一个32位带符号整数 Math.fround()返回数值的单精度浮点数的数值表示,也就是以64位存储的浮点数 Math.hypot() 返回所有参数的平方和的平方根 Math.expm1(x) 返回其相应的指数减一 即 e ^ x -1 Math.log1p(x) 返回 ln(1+x) 等价于 Math.log(1 + x) Math.log10(x) 返回以10为底的对数 Math.log2() 返回以2为底的对数 下面是打印出来的测试用例 1234567891011121314151617console.log(Math.trunc(4.9)) //4console.log(Math.trunc(-4.9)) //-4console.log(Math.sign(5)) //1 (表示是正数)console.log(Math.sign(-0)) //-0 表示是负零console.log(Math.sign(0))console.log(Math.sign()) //NaN 表示为非数值console.log(Math.cbrt(8)) //2console.log(Math.clz32(1)) //31 表示1的32位二进制的数值,1前面一共有21个零console.log(Math.clz32(1.9)) //31 对于有小数的情况,只返回相应的整数部分console.log(Math.clz32(NaN)) //32 此方法有隐式类型转换的机制console.log(Math.imul(2, 4)) // 8console.log(Math.fround(1.337)) //1.3370000123977661 丧失了精度console.log(Math.hypot(3, 4)) //5console.log(Math.expm1(0)) //0console.log(Math.expm1(1)) //1.718281828459045console.log(Math.log10(10)) //1.718281828459045console.log(Math.log2(2)) //1.718281828459045 指数运算符ES7还新增了一个指数运算符,目前babel转码器已经支持 1234567console.log(2 ** 2) //4console.log(2 ** 3) //8 // 同时,指数运算符还可与等号结合,形成一个新的赋值运算符 **=let a = 3console.log(a **= 2) // 9let b = 2console.log(b **= 3) // 8 (完)","categories":[{"name":"ES6标准入门","slug":"ES6标准入门","permalink":"https://github.com/ChangerHe/categories/ES6标准入门/"}],"tags":[{"name":"ES6","slug":"ES6","permalink":"https://github.com/ChangerHe/tags/ES6/"},{"name":"number","slug":"number","permalink":"https://github.com/ChangerHe/tags/number/"}]},{"title":"《ES6标准入门》阅读笔记——-正则表达式的扩展","slug":"《ES6标准入门》阅读笔记——-正则表达式的扩展","date":"2017-06-20T12:45:51.000Z","updated":"2017-09-18T00:41:22.071Z","comments":true,"path":"2017/06/20/《ES6标准入门》阅读笔记——-正则表达式的扩展/","link":"","permalink":"https://github.com/ChangerHe/2017/06/20/《ES6标准入门》阅读笔记——-正则表达式的扩展/","excerpt":"","text":"写在前面本系列为在我读完阮一峰老师的《ES6标准入门》第二版之后，所做的阅读笔记的整理。 许多初学ES6, 同时和我一样初次阅读阮老师的这本书的时候, 读第一遍会越发的困惑, 因为阮老师上面说的很多的定义,方法,之前都是没有见过的, 读到后面才发现, 哦~原来是这样. 有一句话叫做”大神的世界我们不懂”, 所以我在初读第一遍《ES6标准入门》这本书的时候,也是踩了不少坑,读书的时候查阅了不少的资料. 所以,在这一系列的笔记教程中,我会从一个初学者的角度,向您讲述ES6的相关知识,在后面介绍的知识我会尽量不提前用,即使提前使用,也会同时做好标注,避免了阅读时各种查阅资料的烦恼. 系列博客将采用一个一个的样例，来说明书中的精华部分（当然，这只是我认为的），同时引导新手，快速入门ES6，并逐步将其投入到生产实践中。 同时,在阅读前也提醒您, 为了系统连贯性的学习ES6的基础知识,建议您从我的博客第一章开始阅读,当然,如果您对对应的知识已经有所了解,那么可以跳转到任意章节阅读,每一篇博客名中均有介绍该博客中涉及到的ES6的内容. 阮一峰老师的这本书是开源的，在其官方博客就可以下载到，但是我强烈建议大家去购买一本书, 一是方便自己查阅ES6中新增的众多API, 二也是表达一下对大神的敬仰. 正则表达式的扩展在ES6以前,正则表达式的构造函数只能接受字符串作为参数 但在ES6中,是允许RegExp构造函数使用正则表达式作为参数的,这时候会返回一个原有正则表达式的拷贝 如果在使用正则表达式的第二个参数时,则它将会使用第二个修饰符而忽略原有的正则表达式修饰符12var reg = new RegExp(/abc/ig, &apos;g&apos;).flags // .flags表示查找正则表达式的修饰符,如ige等console.log(reg) // g ES6新增了u修饰符,含义为Unicode模式, 用来正确处理大于\\uFFFF 的Unicode字符 12console.log(/^\\ud83d/u.test(&apos;\\ud83d\\udc2a&apos;))console.log(/^\\ud83d/.test(&apos;\\ud83d\\udc2a&apos;)) // 当不使用u操作符的时候,使用utf-16编码的字符无法被正常识别 对于点字符,当字符为utf-16编码是,是无法正常被识别的,此时必须加上u修饰符 1234console.log(&apos;\\u&#123;20bb7&#125;&apos;)var s = &apos;\\u&#123;20bb7&#125;&apos;console.log(/^.$/.test(s)) // 当正则表达式的标识符不加u时,是不会被识别的,不会被匹配为任意字符,当然,主要原因还是因为它被当成两个字符了console.log(/^.$/u.test(s)) // true 同时,ES6新增了使用大括号表示Unicode的表示法,这种表示法在正则表达式中必须加上u修饰符才能被识别 12345678console.log(/\\u&#123;61&#125;/.test(&apos;a&apos;)) // 当不使用u作为修饰符时,此正则表达式会被认为是u的61个重复console.log(/\\u&#123;61&#125;/u.test(&apos;a&apos;)) // 使用u修饰符后,所有量词都会正确识别码点大于0xFFFF的Unicode字符console.log(/𠮷&#123;2&#125;/u.test(&apos;𠮷𠮷&apos;)) // 当我们使用\\S(非空格字符)对四字节的字符进行匹配的时候,同样会产生问题:无法正常匹配,原因还是一样,之前ES5将这个字符理解成了两个字符了console.log(/^\\S$/.test(&apos;𠮷&apos;))console.log(/^\\S$/u.test(&apos;𠮷&apos;)) 除了u修饰符,ES6还为正则表达式添加了y修饰符,叫做黏连修饰符(y) y修饰符的作用与g修饰符类似,也是全局匹配,后一次的匹配都会从上一次匹配成功的下一个位置开始. 1234567891011var s = &apos;sss_ss_s&apos;var r1 = /s+/gvar r2 = /s+/ygconsole.log(s.match(r1))console.log(s.match(r2)) // 我们使用y修饰符进行匹配,因为同样的s是没有连贯性的出现在一起,所以导致后面的就无法匹配了var r3 = /s+_/gvar r4 = /s+_/yconsole.log(s.match(r3))console.log(s.match(r4))console.log(s.match(r4)) ES6为正则表达式提供了flags 和 source 方法,用于返回正则表达式的修饰符 和匹配正文 123var r = /s/igyconsole.log(r.source)console.log(r.flags) (完)","categories":[{"name":"ES6标准入门","slug":"ES6标准入门","permalink":"https://github.com/ChangerHe/categories/ES6标准入门/"}],"tags":[{"name":"ES6","slug":"ES6","permalink":"https://github.com/ChangerHe/tags/ES6/"},{"name":"RegExp","slug":"RegExp","permalink":"https://github.com/ChangerHe/tags/RegExp/"}]},{"title":"《ES6标准入门》阅读笔记——-Unicode","slug":"《ES6标准入门》阅读笔记——-Unicode","date":"2017-06-19T14:11:34.000Z","updated":"2017-09-18T00:41:10.344Z","comments":true,"path":"2017/06/19/《ES6标准入门》阅读笔记——-Unicode/","link":"","permalink":"https://github.com/ChangerHe/2017/06/19/《ES6标准入门》阅读笔记——-Unicode/","excerpt":"","text":"写在前面本系列为在我读完阮一峰老师的《ES6标准入门》第二版之后，所做的阅读笔记的整理。 许多初学ES6, 同时和我一样初次阅读阮老师的这本书的时候, 读第一遍会越发的困惑, 因为阮老师上面说的很多的定义,方法,之前都是没有见过的, 读到后面才发现, 哦~原来是这样. 有一句话叫做”大神的世界我们不懂”, 所以我在初读第一遍《ES6标准入门》这本书的时候,也是踩了不少坑,读书的时候查阅了不少的资料. 所以,在这一系列的笔记教程中,我会从一个初学者的角度,向您讲述ES6的相关知识,在后面介绍的知识我会尽量不提前用,即使提前使用,也会同时做好标注,避免了阅读时各种查阅资料的烦恼. 系列博客将采用一个一个的样例，来说明书中的精华部分（当然，这只是我认为的），同时引导新手，快速入门ES6，并逐步将其投入到生产实践中。 同时,在阅读前也提醒您, 为了系统连贯性的学习ES6的基础知识,建议您从我的博客第一章开始阅读,当然,如果您对对应的知识已经有所了解,那么可以跳转到任意章节阅读,每一篇博客名中均有介绍该博客中涉及到的ES6的内容. 阮一峰老师的这本书是开源的，在其官方博客就可以下载到，但是我强烈建议大家去购买一本书, 一是方便自己查阅ES6中新增的众多API, 二也是表达一下对大神的敬仰. ES6加强了对Unicode的支持,并扩展了字符串对象ES6对Unicode的主要的新增支持是,已经开始支持32位的字符了,要知道在之前,32位的字符是会被JS判定为两个字符的. codePointAt()方法,可以很方便地判定字符是由2字节还是4字节组成 1234567891011121314let a = &apos;\\uD842\\uDFB7&apos;console.log(a); // 𠮷 在ES5中会被判定为两个字符let b = &apos;\\u20BB7&apos;let c = &apos;\\u&#123;20BB7&#125;&apos;console.log(b) // □7 未被识别console.log(c) // 𠮷let d = &apos;𠮷a&apos;console.log(d.length) // 3 把第一个字符当两个字符了console.log(d.charAt(0)) // 乱码console.log(d.charAt(1)) // 乱码console.log(d.charAt(2)) // aconsole.log(d.charAt(3)) // console.log(d.codePointAt(0)) // 134071console.log(d.codePointAt(1)) // 57271 要知道在之前es5中定义的fromCharCode()方法中,只能够识别16位的字符,并将其转换为相应字符,但是当我们需要进行32位字符码点转换为字符的时候,就无能为力了,这个时候ES6定义了一个新的方法: fromCodePoint() 在ES6中新定义的for-of循环可以实现识别使用32位编码的字符 for of 循环也是ES6中新定义的循环方式,可以用来遍历数组,遍历的同时不同于for in循环,for of循环不会遍历到你定义的原型上的可枚举属性,去除了for in循环的糟粕, 同时也避免了forEach循环不能跳出循环队列的问题,for of是可以随时跳出循环队列的. 同样的for of循环也可以遍历数组,对象等. 12345678let text = String.fromCodePoint(0x20bb7);for (let i = 0; i &lt; text.length; i++) &#123; console.log(text[i]) // 乱码 console.log(i) // 1&#125;for (let i of text) &#123; console.log(i) // 𠮷&#125; ES5为字符串对象提供了charAt方法,返回给定位置的字符,该方法不能识别码点大于0xFFFF的字符 因此,ES7定义了at方法,用于识别码点大于0xFFFF的字符 但是,现在谷歌浏览器暂不支持, 需要通过babel转码 12console.log(&apos;𠮷a&apos;.charAt(0)) // 乱码console.log(&apos;𠮷&apos;.at(0)) // 报错 ES6新增了一些查找字符串的相应方法 includes() 返回布尔值,表示是否找到了参数字符串 startsWith() 返回布尔值,表示字符串是否在元字符串的头部 endsWith() 返回布尔值,表示参数自粗换是否在源字符串的头部 repeat() 返回一个新字符串,表示将原字符串重复n次 12345var str = &apos;hello&apos;console.log(str.startsWith(&apos;he&apos;)) // trueconsole.log(str.endsWith(&apos;lo&apos;)) // trueconsole.log(str.includes(&apos;lo&apos;)) // trueconsole.log(str.repeat(3)) // hellohellohello ES6的模板字符串使用变量直接添加到相应的字符串中 用法很简单,添加到相应的字符串中 需要注意的是,使用模板字符串的时候,需要使用反向引号将整体的字符串引起来,否则是无效的 模板字符串,其实就是模块化了的,放在${}里面的js代码 123456let name = &apos;Bob&apos;, time = &apos;today&apos;console.log(`hello $&#123;name&#125;, how are you $&#123;time&#125;?`) // hello Bob, how are you today?console.log(&apos;hello $&#123;name&#125;&apos;) // hello $&#123;name&#125; 模板字符串还拥有更加灵活的用法 123456789let a = 1, b = 2;console.log(`$&#123;a&#125; + $&#123;b&#125; = $&#123;a+b&#125;`) // 1 + 2 = 3function foo() &#123; return &apos;hello&apos;&#125;console.log(`$&#123;foo()&#125; world`) // hello world (完)","categories":[{"name":"ES6标准入门","slug":"ES6标准入门","permalink":"https://github.com/ChangerHe/categories/ES6标准入门/"}],"tags":[{"name":"ES6","slug":"ES6","permalink":"https://github.com/ChangerHe/tags/ES6/"},{"name":"Unicode","slug":"Unicode","permalink":"https://github.com/ChangerHe/tags/Unicode/"}]},{"title":"理解Node.js里的process.nextTick()","slug":"理解Nodejs里的process-nextTick","date":"2017-06-19T12:00:32.000Z","updated":"2017-09-17T12:25:37.601Z","comments":true,"path":"2017/06/19/理解Nodejs里的process-nextTick/","link":"","permalink":"https://github.com/ChangerHe/2017/06/19/理解Nodejs里的process-nextTick/","excerpt":"","text":"Nodejs的事件驱动,异步IO模型另异步编程变得异常风行,它借助了异步IO模型及V8高性能引擎,突破了单线程的性能瓶颈. 让Jacascript在后端达到了其应有的使用价值. 另外一方面,它也统一了前后端的javascript编程模型. 异步编程也给前端程序猿带来了诸多的痛苦和不适应. 这也是我今天着重想提process.nextTick()这个API的原因之一. 异常处理在过去,我们处理异常一般使用try catch fanily这个语句块进行异常捕获和处理 12345try &#123; JSON.parse(jsonObj)&#125; catch(e) &#123; // do something...&#125; 但是这个方法对异步编程而言是并不适用的, 举个很简单的例子,也是我们在日常开发中常常使用的一个小技巧: 当我们想要某个在文档中间的语句块在整个脚本的最后执行的时候,可以使用setTimeout将这个语句块包起来,将延时时间设为0, 那么这个时候它就会等待所有同步的进程全部执行完毕之后再执行. 在try中,我们进行异步的方式处理JSON.parse的时候,那么它也会被放到文档流的最后执行而try catch先执行了,这就是导致出现这个问题的原因 那么这个时候,就需要们的主角登场了 同样的,我们再来一个例子 12345function foo() &#123; console.error(&apos;foo&apos;);&#125;process.nextTick(foo);console.error(&apos;bar&apos;); 运行上面的代码，你从下面终端打印的信息会看到，”bar”的输出在“foo”的前面。这就验证了上面的说法，foo()是在下一个时间点运行的。 但在内部的处理机制上，process.nextTick()和setTimeout(fn, 0)是不同的，process.nextTick()不是一个单纯的延时，他有更多的 特性。 更精确的说，process.nextTick()定义的调用会创建一个新的子堆栈。在当前的栈里，你可以执行任意多的操作。但一旦调用netxTick，函数就必须返回到父堆栈。然后事件轮询机制又重新等待处理新的事件，如果发现nextTick的调用，就会创建一个新的栈。 下面我们来看看，什么情况下使用process.nextTick()： 在多个事件里交叉执行CPU运算密集型的任务：在下面的例子里有一个compute()，我们希望这个函数尽可能持续的执行，来进行一些运算密集的任务。 但与此同时，我们还希望系统不要被这个函数堵塞住，还需要能响应处理别的事件。这个应用模式就像一个单线程的web服务server。在这里我们就可以使用process.nextTick()来交叉执行compute()和正常的事件响应。 1234567891011121314var http = require(&apos;http&apos;);function compute() &#123; // performs complicated calculations continuously // ... process.nextTick(compute);&#125; http.createServer(function(req, res) &#123; res.writeHead(200, &#123;&apos;Content-Type&apos;: &apos;text/plain&apos;&#125;); res.end(&apos;Hello World&apos;);&#125;).listen(5000, &apos;127.0.0.1&apos;); compute(); 在这种模式下，我们不需要递归的调用compute()，我们只需要在事件循环中使用process.nextTick()定义compute()在下一个时间点执行即可。在这个过程中，如果有新的http请求进来，事件循环机制会先处理新的请求，然后再调用compute()。反之，如果你把compute()放在一个递归调用里，那系统就会一直阻塞在compute()里，无法处理新的http请求了。你可以自己试试。 当然，我们无法通过process.nextTick()来获得多CPU下并行执行的真正好处，这只是模拟同一个应用在CPU上分段执行而已。 保持回调函数异步执行的原则当你给一个函数定义一个回调函数时，你要确保这个回调是被异步执行的。下面我们看一个例子，例子中的回调违反了这一原则： 12345678function asyncFake(data, callback) &#123; if(data === &apos;foo&apos;) callback(true); else callback(false);&#125; asyncFake(&apos;bar&apos;, function(result) &#123; // this callback is actually called synchronously!&#125;); 为什么这样不好呢？我们来看Node.js 文档里一段代码： 1234var client = net.connect(8124, function() &#123; console.log(&apos;client connected&apos;); client.write(&apos;world!\\r\\n&apos;);&#125;); 在上面的代码里，如果因为某种原因，net.connect()变成同步执行的了，回调函数就会被立刻执行，因此回调函数写到客户端的变量就永远不会被初始化了。 这种情况下我们就可以使用process.nextTick()把上面asyncFake()改成异步执行的： 12345function asyncReal(data, callback) &#123; process.nextTick(function() &#123; callback(data === &apos;foo&apos;); &#125;);&#125; 用在事件触发过程中来看一个例子，你想写一个库实现这样的功能：从源文件里读取数据，当读取完毕后，触发一个事件同时传递读取的数据。可能你会这样写： 12345678910var EventEmitter = require(&apos;events&apos;).EventEmitter; function StreamLibrary(resourceName) &#123; this.emit(&apos;start&apos;); // read from the file, and for every chunk read, do: this.emit(&apos;data&apos;, chunkRead); &#125;StreamLibrary.prototype.__proto__ = EventEmitter.prototype; // inherit from EventEmitter 下面是一段调用这个库的客户端程序，我们想在程序中监听这些事件： 123456789var stream = new StreamLibrary(&apos;fooResource&apos;); stream.on(&apos;start&apos;, function() &#123; console.log(&apos;Reading has started&apos;);&#125;); stream.on(&apos;data&apos;, function(chunk) &#123; console.log(&apos;Received: &apos; + chunk);&#125;); 但是上面的代码中，将永远接收不到“start”事件，因为在这个库实例化的时候，“start”事件会被立刻触发执行，但此时事件的回调函数还没有准备好，所以在客户端根本无法接收到这个事件。同样，我们可以用process.nextTick()来改写事件触发的过程，下面是一个正确的版本： 12345678910function StreamLibrary(resourceName) &#123; var self = this; process.nextTick(function() &#123; self.emit(&apos;start&apos;); &#125;); // read from the file, and for every chunk read, do: this.emit(&apos;data&apos;, chunkRead);&#125; (文章部分引用了网上内容)","categories":[{"name":"Nodejs学习笔记","slug":"Nodejs学习笔记","permalink":"https://github.com/ChangerHe/categories/Nodejs学习笔记/"}],"tags":[{"name":"Nodejs","slug":"Nodejs","permalink":"https://github.com/ChangerHe/tags/Nodejs/"},{"name":"process.nextTick()","slug":"process-nextTick","permalink":"https://github.com/ChangerHe/tags/process-nextTick/"}]},{"title":"《ES6标准入门》阅读笔记———解构赋值","slug":"《ES6标准入门》阅读笔记———解构赋值","date":"2017-06-18T13:21:39.000Z","updated":"2017-09-18T00:40:26.230Z","comments":true,"path":"2017/06/18/《ES6标准入门》阅读笔记———解构赋值/","link":"","permalink":"https://github.com/ChangerHe/2017/06/18/《ES6标准入门》阅读笔记———解构赋值/","excerpt":"","text":"写在前面本系列为在我读完阮一峰老师的《ES6标准入门》第二版之后，所做的阅读笔记的整理。 许多初学ES6, 同时和我一样初次阅读阮老师的这本书的时候, 读第一遍会越发的困惑, 因为阮老师上面说的很多的定义,方法,之前都是没有见过的, 读到后面才发现, 哦~原来是这样. 有一句话叫做”大神的世界我们不懂”, 所以我在初读第一遍《ES6标准入门》这本书的时候,也是踩了不少坑,读书的时候查阅了不少的资料. 所以,在这一系列的笔记教程中,我会从一个初学者的角度,向您讲述ES6的相关知识,在后面介绍的知识我会尽量不提前用,即使提前使用,也会同时做好标注,避免了阅读时各种查阅资料的烦恼. 系列博客将采用一个一个的样例，来说明书中的精华部分（当然，这只是我认为的），同时引导新手，快速入门ES6，并逐步将其投入到生产实践中。 同时,在阅读前也提醒您, 为了系统连贯性的学习ES6的基础知识,建议您从我的博客第一章开始阅读,当然,如果您对对应的知识已经有所了解,那么可以跳转到任意章节阅读,每一篇博客名中均有介绍该博客中涉及到的ES6的内容. 阮一峰老师的这本书是开源的，在其官方博客就可以下载到，但是我强烈建议大家去购买一本书, 一是方便自己查阅ES6中新增的众多API, 二也是表达一下对大神的敬仰. 什么是解构赋值?ES6允许我们按照一定模式,从数组和对象中提取值,对变量进行赋值,这被称为解构 解构赋值可将数组的元素或对象的属性赋予给另一个变量，该变量的定义语法与数组字面量或对象字面量很相似。此语法非常简洁，相比于传统的属性访问方式，更加直观清晰。 在不使用解构赋值的情况下，通常我们这样访问数组中的元素： 123var first = arr[0]; var second = arr[1]; var third = arr[2]; 使用解构赋值后，代码得到了极大的简化，同时可读性也更强： 1var [first, second, third] = arr; 以上代码的作用和上面的实例代码是一样的,声明三个变量,存储数组arr中的前三位的内容. 数组的解构赋值我们将数组的对应位置定义好变量,同时在相同位置定义好对应值,就可以完成赋值操作 12let [foo, [[bar], baz]] = [1,[[2],3]]console.log(foo, bar, baz) // 1 2 当我们对变量解构赋值的时候,不想赋值的地方可以使用空数组的键值代替.当需要使用一个变量匹配后面的所有未匹配数组的时候,使用三个点号代替 1234let [head, ...tail] = [1,2,3,4,5,6]console.log(head, tail) // 1 [2,3,4,5,6]let [x, y, ...z] = [&apos;a&apos;];console.log(x,y,z) // a undefined [] 三个点号也是ES6中的新语法, 在阮一峰老师的书中有两种叫法,一个叫做扩展运算符,一个叫做rest参数, 但是我觉得三点运算符好像更加的形象贴切啊哈哈. 当然,这个三点运算符会在数组这一章进行具体讲解. 解构不成功,表示右边的值不足以匹配左边的值,不完全解构,表示右边的值超出要赋予的左边的值当出现如下情况的时候,f是只能匹配第一个数组元素的 12let [e,[f],g] = [1,[2,3],4]console.log(e,f,g) //1 2 4 需要注意的是,当等号的右边不是数组,或者严格的说,不是可以遍历的结构的时候,是会报错的. 1let [a] = 1 // 报错 对于解构赋值,我们可以使用Set结构,也可以使用数组的解构赋值 那么这里再解释一下啥叫set结构,ES6提供了一种新的数据结构Set,类似于数组,但成员值是唯一的,没有重复值. set本身是一个构造函数,用来生成set数据结构. 12let [h,i,j] = new Set([&apos;a&apos;,&apos;b&apos;,&apos;c&apos;])console.log(h,i,j) // a b c 解构赋值也允许使用默认值,所以,当我们为其不传值,或者传值为undefined的时候,是会使用默认值的 12let [foo = true] = [undefined]console.log(foo) // true 但是因为ES6修复了很多之前因为 null == Object 而导致的许多问题,所以,在ES6中,因为其内部的判定机制,如果所属的值不严格等于undefined,那么其值为null的时候,是可以进行赋值的 12let [foo = true] = [null]console.log(foo) 对象的解构赋值同样的,解构赋值也支持对对象的解构赋值 对象不同于数组,数组是按次序排列的,但是对象的属性时没有次序的,只能通过查找对象的键值来找到相应的值 在这里可能很多童鞋就有点懵逼了,为啥对象你写个名字,不赋值都行啊? 那么这里还是要再补充一下,ES6新增了一种对象的表示方法, 允许在对象之中，直接写变量。这时，属性名为变量名, 属性值为变量的值。也就是说: {bar, foo} === {bar: bar, foo: foo} 123var &#123;bar, foo&#125; = &#123;foo: &apos;aaa&apos;, bar: &apos;bbb&apos;&#125;console.log(foo) // bbbconsole.log(bar) // aaa 需要注意的是,我们给对象进行解构赋值的时候,其实是赋值给了对象的键值,对象的键名是不会改变的. 123let obj = &#123;first: &apos;hello&apos;, last: &apos;world&apos;&#125;;let &#123;first: i, last: j&#125; = objconsole.log(i, j) // hello world 那么还有一个问题就是,进行解构赋值的时候,我们必须将声明和赋值写在一起,不写在一起的话就会报错 在书写的时候有一个小坑也需要注意一下 当我们不加圆括号而是直接使用花括号的话,javascript引擎会把{foo}人为是一个语法块,从而不会正常进行语句的解构 那么解决办法就是将整条语句使用圆括号括起来,从而让引擎正确理解这条语句 123let foo(&#123;foo&#125; = &#123;foo: 1&#125;)console.log(foo) // 1 使用解构赋值的小技巧当我们频繁使用某一个函数或是语句的时候,我们可以使用解构赋值,获得相应的更简便的书写方法 1234let &#123;logl, sin, cos&#125; = Math;console.log(cos(60))let &#123;log, dir, debug&#125; = consolelog(log) 对应此方法,字符串也可以进行解构赋值,此时字符串被转换成了一个类似数组的对象 12345const str = &apos;abcd&apos;const [a, b, c, d] = str;const &#123;length: len&#125; = strconsole.log(a,b,c,d) // a b c dconsole.log(len) // 4 当等号右边是数值或布尔值的时候,会转换为对象,因此也拥有了此类的对象相应的方法和属性 需要注意的是,每个内部类型对象的构造函数中都是拥有toString的方法的 123const &#123;toString: s&#125; = 123;console.log(s === Number.prototype.toString) // trueconsole.log(s === Object.prototype.toString) // false 变量解构赋值在函数参数中的应用函数的参数也是可以参与到解构赋值中的 1234function add([x, y]) &#123; return x + y;&#125;console.log(add([1,2])) 我们可以将函数的返回值作为解构赋值的值来进行使用 12345function example() &#123; return [1,2,3]&#125;var [a,b,c] = example()console.log(a,b,c) 同样的,不仅能使用函数的返回值,还可以使用解构赋值给函数赋值 1234function f([x,y,z])&#123;&#125;f([1,2,3])function j(&#123;x,y,z&#125;)&#123;&#125;j(&#123;x: 1,y: 2, z: 3&#125;) 因为解构赋值的特性,因此其对提取json数据有奇效 1234567var jsonData = &#123; id: 42, status: &apos;OK&apos;, data: [123,432]&#125;let &#123;id, status, data&#125; = jsonDataconsole.log(id, status, data) // 42 OK [123, 432] 遍历Map结构 Map结构也是ES6中定义的新的数据结构,它类似于对象,也是键值对的集合,但是键的范围不限于字符串,各种类型的值都可以当做键 123456var map = new Map();map.set(&apos;first&apos;, &apos;hello&apos;);map.set(&apos;second&apos;, &apos;world&apos;)for(let [key, value] of map) &#123; console.log(key + &apos; is &apos; + value)&#125; (完)","categories":[{"name":"ES6标准入门","slug":"ES6标准入门","permalink":"https://github.com/ChangerHe/categories/ES6标准入门/"}],"tags":[{"name":"ES6","slug":"ES6","permalink":"https://github.com/ChangerHe/tags/ES6/"},{"name":"解构赋值","slug":"解构赋值","permalink":"https://github.com/ChangerHe/tags/解构赋值/"}]},{"title":"《ES6标准入门》阅读笔记——let和const","slug":"《ES6标准入门》阅读笔记——let和const","date":"2017-06-17T13:33:39.000Z","updated":"2017-09-18T00:40:15.428Z","comments":true,"path":"2017/06/17/《ES6标准入门》阅读笔记——let和const/","link":"","permalink":"https://github.com/ChangerHe/2017/06/17/《ES6标准入门》阅读笔记——let和const/","excerpt":"","text":"写在前面本系列为在我读完阮一峰老师的《ES6标准入门》第二版之后，所做的阅读笔记的整理。 许多初学ES6, 同时和我一样初次阅读阮老师的这本书的时候, 读第一遍会越发的困惑, 因为阮老师上面说的很多的定义,方法,之前都是没有见过的, 读到后面才发现, 哦~原来是这样. 有一句话叫做”大神的世界我们不懂”, 所以我在初读第一遍《ES6标准入门》这本书的时候,也是踩了不少坑,读书的时候查阅了不少的资料. 所以,在这一系列的笔记教程中,我会从一个初学者的角度,向您讲述ES6的相关知识,在后面介绍的知识我会尽量不提前用,即使提前使用,也会同时做好标注,避免了阅读时各种查阅资料的烦恼. 系列博客将采用一个一个的样例，来说明书中的精华部分（当然，这只是我认为的），同时引导新手，快速入门ES6，并逐步将其投入到生产实践中。 同时,在阅读前也提醒您, 为了系统连贯性的学习ES6的基础知识,建议您从我的博客第一章开始阅读,当然,如果您对对应的知识已经有所了解,那么可以跳转到任意章节阅读,每一篇博客名中均有介绍该博客中涉及到的ES6的内容. 阮一峰老师的这本书是开源的，在其官方博客就可以下载到，但是我强烈建议大家去购买一本书, 一是方便自己查阅ES6中新增的众多API, 二也是表达一下对大神的敬仰. 函数的作用域要知道，在ES6以前，JS一直都是只有函数作用域，而没有块级作用域的。在这样的情况下，我们大多会使用IIFE（自执行函数表达式）来模拟块级作用域，达到避免全局作用域污染等目的。 那么ES6有新定义了两种变量的定义方式，let和const，两种变量的定义方式均会产生块级作用域，也就是我们使用大括号包起来的区域，都是块级作用域。 let和const两者之间的区别就是，const定义的变量，之后是无法更改的。 123456&#123; let a = 10; var b = 1;&#125;console.log(b)console.log(a) // 报错 我们在大括号外面去打印a会报错,说明let其实是有块级作用域的,当我们使用循环语句的时候,let来声明变量是一个不错的选择. 1234567var a = [];for (let i = 0; i &lt; 10; i++) &#123; a[i] = function() &#123; console.log(i) &#125;&#125;a[6]() // 6 当我们使用let来进行声明的时候,才能得到想要的值 也就是6 原因是因为,变量i是let声明的,当前的i只在本轮循环有效,所以相当于每一次循环的i都是一个新的变量 let 不和var一样,存在变量的提升,所以我们在没有声明之前调用let声明的变量,会报错 12console.log(b) // 报错let b = 2; 还有一点要注意的是,我们在第一行使用var声明了b,在这里再声明,就会报错,因为let和const是不允许变量被重复声明的. 暂时性死区只要块级作用域内存在let命令,那么它所声明的变量就绑定了这个区域,不会受外部的影响es6明确规定,只要区块中存在let和const命令,则这个区块对这些命令声明的变量从一开始就形成封闭作用域.只要在声明之前就使用这些变量,就会报错 其实上面那个例子,已经很好地说明了暂时性死区这个概念了. 12345var c = 3;if(true) &#123; tmp = &apos;abc&apos; //报错,tmp没有定义 let tmp&#125; 不仅如此,坑爹的是有些死区,你不仔细看真的很难发现 另外补充一点,在函数中进行形式参数的预定义,也就是设置函数的参数默认值,也是ES6中新定义的函数写法,关于此的内容,会在之后在函数篇中详细介绍. 1234function bar(x = y, y = 2) &#123; return [x, y]&#125;bar() //报错, y is not defined 当然,我们把上面的代码稍微改一下就不会报错了 1234function bac(y = 2, x = y) &#123; return [x, y]&#125;console.log(bac()) // [2,2] 结合上面的介绍,还有一点,当我们在块级作用域的内部再定义块级作用域的时候,就不会报错了. 12345678function f1() &#123; let n = 5; if (true) &#123; let n = 10; &#125; console.log(n) // 5&#125;f1() 讲到这里,我再分享一个坑,关于函数的声明提升问题,当然, 下面这一题我没有直接在题上写答案,大家可以把解析先遮住,思考一下这题的结果是什么.既然是坑, 我觉得新手还是老老实实往上踩几脚比较好. 1234567891011121314let f = function() &#123; console.log(&apos;outside&apos;)&#125;function aaa() &#123; if (false) &#123; function f() &#123; console.log(&apos;inside&apos;) &#125; &#125; f()&#125;aaa() 万万没想到啊没想到, aaa函数中f()函数的执行居然会报错,而且打印f的值居然是undefined! 这其实是一个函数的作用域提升问题,预编译阶段内部函数f会跨过if判断而提升至函数aaa的作用域顶端 那么可能大家会问,我在aaa函数内部打印f函数,是undefined啊. 因为函数的声明赋值时在if判断语句之内的,所以在此之前仅有一个var f,也就是定义了一个f,但并未对其赋值,所以f打印出来就是undefined. const和let的具体区别我们来看下面这几行代码 1234567891011let f;console.log(f); // undefined&#123; let a = &apos;secret&apos; console.log(f) // undefined f = function() &#123; return a; &#125; console.log(f) // f() &#123; return a &#125;&#125;console.log(f()); //secret 其实上面的代码很好地说明了let的作用域的问题,而且需要注意的是,let的变量值,是可以随时更改的. 而const,就没有这么自由了 123const PI = 3.14;PI = 3; // 报错const foo; // 定义变量时位对其赋值,报错 需要注意的是const定义复合类型值的时候,因为复合类型的变量不直接指向数据,而是指向数据所存储的相应内存空间 所以这个时候当我们对相应的内存空间中的值进行更改,只要内存空间不变,则都可以对值进行更改 123const foo = &#123;&#125;;foo.prop = 1;console.log(foo.prop) // 1 但是呢,,如果我们更改相应的foo指向的内存空间,则就会报错 1foo = &#123;&#125; // 报错(接上面的代码实例) 如果在声明引用类型变量后,我们不想让里面的值改变怎么办呢? 这个时候可以使用Object.freeze()方法,冻结这个对象,包括其内存空间的值 123const foo1 = Object.freeze(&#123;&#125;);foo1.prop = 1;console.log(foo1.prop) // undefined 这个时候为该对象定义属性和方法,都无效了,但是不会抛出异常 最后需要注意的一点是,即使我们在全局使用let或是const定义变量,变量都不会挂载到全局的window对象上. 1234567var a = 1let b = 2const c = 3console.log(window.a) // 1console.log(window.b) // undefinedconsole.log(window.c) // undefined (完)","categories":[{"name":"ES6标准入门","slug":"ES6标准入门","permalink":"https://github.com/ChangerHe/categories/ES6标准入门/"}],"tags":[{"name":"ES6","slug":"ES6","permalink":"https://github.com/ChangerHe/tags/ES6/"},{"name":"let","slug":"let","permalink":"https://github.com/ChangerHe/tags/let/"},{"name":"const","slug":"const","permalink":"https://github.com/ChangerHe/tags/const/"}]},{"title":"Nodejs的require()模块源码解读","slug":"Nodejs的require-模块源码解读","date":"2017-06-16T11:44:27.000Z","updated":"2017-09-16T03:39:33.855Z","comments":true,"path":"2017/06/16/Nodejs的require-模块源码解读/","link":"","permalink":"https://github.com/ChangerHe/2017/06/16/Nodejs的require-模块源码解读/","excerpt":"","text":"2009年, nodejs项目诞生,所有模块一律为commonjs格式. 时至今日,Nodejs的包管理npm仓库,已经存放了十万百万级的模块,其中绝大部分都是使用的commonjs格式. 这种格式的核心就是require语句, 模块通过它进行加载. 基本用法以下内容翻译自《Node使用手册》 当 Node 遇到 require(X) 时，按下面的顺序处理。 （1）如果 X 是内置模块（比如 require(‘http’）) a. 返回该模块。 b. 不再继续执行。（2）如果 X 以 “./“ 或者 “/“ 或者 “../“ 开头 a. 根据 X 所在的父模块，确定 X 的绝对路径。 b. 将 X 当成文件，依次查找X,找不到之后会查找X .js,再找不到则找X .json,还找不到则找X .node，只要其中有一个存在，就返回该文件，不再继续执行。 c. 将 X 当成目录，依次查找X /package.json,找不到之后会查找X /index.js,再找不到则找X /index.json,还找不到则找X /index.node，只要其中有一个存在，就返回该文件，不再继续执行。（3）如果 X 不带路径 a. 根据 X 所在的父模块，确定 X 可能的安装目录。 b. 依次在每个目录中，将 X 当成文件名或目录名加载。（4） 抛出 “not found” Module构造函数Module构造函数的部分源码是这样的 123456789101112function Module(id, parent) &#123; this.id = id; this.exports = &#123;&#125;; this.parent = parent; this.filename = null; this.loaded = false; this.children = [];&#125;module.exports = Module;var module = new Module(filename, parent); 上面代码中，Node 定义了一个构造函数 Module，所有的模块都是 Module 的实例。可以看到，当前模块（module.js）也是 Module 的一个实例。每个实例都有自己的属性。下面通过一个例子，看看这些属性的值是什么。新建一个脚本文件 a.js 。 123456789// a.jsconsole.log(&apos;module.id: &apos;, module.id); //.console.log(&apos;module.exports: &apos;, module.exports); // &#123;&#125;console.log(&apos;module.parent: &apos;, module.parent); // nullconsole.log(&apos;module.filename: &apos;, module.filename); // 当前文件路径console.log(&apos;module.loaded: &apos;, module.loaded); // falseconsole.log(&apos;module.children: &apos;, module.children); //console.log(&apos;module.paths: &apos;, module.paths); 可以看到，如果没有父模块，直接调用当前模块，parent 属性就是 null，id 属性就是一个点。filename 属性是模块的绝对路径，path 属性是一个数组，包含了模块可能的位置。另外，输出这些内容时，模块还没有全部加载，所以 loaded 属性为 false 。新建另一个脚本文件 b.js，让其调用 a.js 。 上面代码中，由于 a.js 被 b.js 调用，所以 parent 属性指向 b.js 模块，id 属性和 filename 属性一致，都是模块的绝对路径。 模块实例的 require 方法每个模块实例都有一个 require 方法。 123Module.prototype.require = function(path) &#123;return Module._load(path, this);&#125;; 由此可知，require 并不是全局性命令，而是每个模块提供的一个内部方法，也就是说，只有在模块内部才能使用 require 命令（唯一的例外是 REPL 环境）。另外，require 其实内部调用 Module._load 方法。 1234567891011121314151617181920212223242526272829303132Module._load = function(request, parent, isMain) &#123;// 计算绝对路径var filename = Module._resolveFilename(request, parent);// 第一步：如果有缓存，取出缓存var cachedModule = Module._cache[filename];if (cachedModule) &#123;return cachedModule.exports;// 第二步：是否为内置模块if (NativeModule.exists(filename)) &#123;return NativeModule.require(filename);&#125;// 第三步：生成模块实例，存入缓存var module = new Module(filename, parent);Module._cache[filename] = module;// 第四步：加载模块try &#123;module.load(filename);hadException = false;&#125; finally &#123;if (hadException) &#123;delete Module._cache[filename];&#125;&#125;// 第五步：输出模块的exports属性return module.exports;&#125;; 上面代码中，首先解析出模块的绝对路径（filename），以它作为模块的识别符。然后，如果模块已经在缓存中，就从缓存取出；如果不在缓存中，就加载模块。 因此，Module._load 的关键步骤是两个。 Module._resolveFilename() ：确定模块的绝对路径module.load()：加载模块 模块的绝对路径下面是 Module._resolveFilename 方法的源码。 123456789101112131415161718192021Module._resolveFilename = function(request, parent) &#123;// 第一步：如果是内置模块，不含路径返回if (NativeModule.exists(request)) &#123;return request;&#125;// 第二步：确定所有可能的路径var resolvedModule = Module._resolveLookupPaths(request, parent);var id = resolvedModule[0];var paths = resolvedModule[1];// 第三步：确定哪一个路径为真var filename = Module._findPath(request, paths);if (!filename) &#123;var err = new Error(&quot;Cannot find module &apos;&quot; + request + &quot;&apos;&quot;);err.code = &apos;MODULE_NOT_FOUND&apos;;throw err;&#125;return filename;&#125;; 上面代码中，在 Module.resolveFilename 方法内部，又调用了两个方法 Module.resolveLookupPaths() 和 Module._findPath() ，前者用来列出可能的路径，后者用来确认哪一个路径为真。为了简洁起见，这里只给出 Module._resolveLookupPaths() 的运行结果。 1234567[ &apos;/home/ruanyf/tmp/node_modules&apos;,&apos;/home/ruanyf/node_modules&apos;,&apos;/home/node_modules&apos;,&apos;/node_modules&apos;&apos;/home/ruanyf/.node_modules&apos;,&apos;/home/ruanyf/.node_libraries&apos;，&apos;$Prefix/lib/node&apos; ] 上面的数组，就是模块所有可能的路径。基本上是，从当前路径开始一级级向上寻找 node_modules 子目录。最后那三个路径，主要是为了历史原因保持兼容，实际上已经很少用了。有了可能的路径以后，下面就是 Module._findPath() 的源码，用来确定到底哪一个是正确路径。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354Module._findPath = function(request, paths) &#123;// 列出所有可能的后缀名：.js，.json, .nodevar exts = Object.keys(Module._extensions);// 如果是绝对路径，就不再搜索if (request.charAt(0) === &apos;/&apos;) &#123;paths = [&apos;&apos;];&#125;// 是否有后缀的目录斜杠var trailingSlash = (request.slice(-1) === &apos;/&apos;);// 第一步：如果当前路径已在缓存中，就直接返回缓存var cacheKey = JSON.stringify(&#123;request: request, paths: paths&#125;);if (Module._pathCache[cacheKey]) &#123;return Module._pathCache[cacheKey];&#125;// 第二步：依次遍历所有路径for (var i = 0, PL = paths.length; i &lt; PL; i++) &#123;var basePath = path.resolve(paths[i], request);var filename;if (!trailingSlash) &#123;// 第三步：是否存在该模块文件filename = tryFile(basePath);if (!filename &amp;&amp; !trailingSlash) &#123;// 第四步：该模块文件加上后缀名，是否存在filename = tryExtensions(basePath, exts);&#125;&#125;// 第五步：目录中是否存在 package.jsonif (!filename) &#123;filename = tryPackage(basePath, exts);&#125;if (!filename) &#123;// 第六步：是否存在目录名 + index + 后缀名filename = tryExtensions(path.resolve(basePath, &apos;index&apos;), exts);&#125;// 第七步：将找到的文件路径存入返回缓存，然后返回if (filename) &#123;Module._pathCache[cacheKey] = filename;return filename;&#125;&#125;// 第八步：没有找到文件，返回falsereturn false;&#125;; 经过上面代码，就可以找到模块的绝对路径了。有时在项目代码中，需要调用模块的绝对路径，那么除了 module.filename ，Node 还提供一个 require.resolve 方法，供外部调用，用于从模块名取到绝对路径。 1234567require.resolve = function(request) &#123;return Module._resolveFilename(request, self);&#125;;// 用法require.resolve(&apos;a.js&apos;)// 返回 /home/ruanyf/tmp/a.js 加载模块有了模块的绝对路径，就可以加载该模块了。下面是 module.load 方法的源码。 123456Module.prototype.load = function(filename) &#123;var extension = path.extname(filename) || &apos;.js&apos;;if (!Module._extensions[extension]) extension = &apos;.js&apos;;Module._extensions[extension](this, filename);this.loaded = true;&#125;; 上面代码中，首先确定模块的后缀名，不同的后缀名对应不同的加载方法。下面是 .js 和 .json 后缀名对应的处理方法。 1234567891011121314Module._extensions[&apos;.js&apos;] = function(module, filename) &#123;var content = fs.readFileSync(filename, &apos;utf8&apos;);module._compile(stripBOM(content), filename);&#125;;Module._extensions[&apos;.json&apos;] = function(module, filename) &#123;var content = fs.readFileSync(filename, &apos;utf8&apos;);try &#123;module.exports = JSON.parse(stripBOM(content));&#125; catch (err) &#123;err.message = filename + &apos;: &apos; + err.message;throw err;&#125;&#125;; 这里只讨论 js 文件的加载。首先，将模块文件读取成字符串，然后剥离 utf8 编码特有的BOM文件头，最后编译该模块。module._compile 方法用于模块的编译。 12345Module.prototype._compile = function(content, filename) &#123;var self = this;var args = [self.exports, require, self, filename, dirname];return compiledWrapper.apply(self.exports, args);&#125;; 上面的代码基本等同于下面的形式。 123(function (exports, require, module, __filename, __dirname) &#123;// 模块源码&#125;); 也就是说，模块的加载实质上就是，注入exports、require、module三个全局变量，然后执行模块的源码，然后将模块的 exports 变量的值输出。 (以上文章转载自阮一峰博客)","categories":[{"name":"Nodejs学习笔记","slug":"Nodejs学习笔记","permalink":"https://github.com/ChangerHe/categories/Nodejs学习笔记/"}],"tags":[{"name":"Nodejs","slug":"Nodejs","permalink":"https://github.com/ChangerHe/tags/Nodejs/"},{"name":"require","slug":"require","permalink":"https://github.com/ChangerHe/tags/require/"}]},{"title":"使用Nodejs实现简单的自动化构建","slug":"使用Nodejs实现简单的自动化构建","date":"2017-06-15T15:56:30.000Z","updated":"2017-09-14T14:35:01.695Z","comments":true,"path":"2017/06/15/使用Nodejs实现简单的自动化构建/","link":"","permalink":"https://github.com/ChangerHe/2017/06/15/使用Nodejs实现简单的自动化构建/","excerpt":"","text":"自动化构建是现代前端基本都需要的东西,说起这个,大家自然会想到 Glup/Grount这些自动化的构建工具. 当然,本文只是从最最基础的角度,使用Node的fs模块进行了简单的文档的写入操作. 首先,我们先定义一个JSON,用于存放我们想要预先定义的文件夹的内容,比如说,我想要我的文件夹名称为ProjectModule ,里面的文件夹有 css / js / img 还有一个 index.html,同时定义好index文件中的内容 那么我的JSON结构可以这样写 12345678910111213141516171819202122var projectData = &#123; &apos;name&apos; : &apos;ProjectModule&apos;, &apos;fileData&apos;: [ &#123; &apos;name&apos;: &apos;css&apos;, &apos;type&apos;: &apos;dir&apos; &#125;, &#123; &apos;name&apos;: &apos;js&apos;, &apos;type&apos;: &apos;dir&apos; &#125;, &#123; &apos;name&apos;: &apos;img&apos;, &apos;type&apos;: &apos;dir&apos; &#125;, &#123; &apos;name&apos;: &apos;index.html&apos;, &apos;type&apos;: &apos;file&apos;, &apos;content&apos;: &apos;&lt;html&gt;\\n\\t&lt;head&gt;\\n\\t&lt;title&gt;MyProject&lt;/title&gt;\\n\\t&lt;/head&gt;\\n\\t&lt;body&gt;\\n\\t&lt;/body&gt;\\n&lt;/html&gt;&apos; &#125; ]&#125; 接下来,就是引入fs模块 1var fs = require(&apos;fs&apos;) 因为这里是要实时创建的,我们可以直接使用同步的操作,就省去了异步需要使用回调函数的麻烦 当然,开始之前,要先确定一下,JSON是否有正常的给出文件夹的名称 12345678910111213141516171819202122232425if(projectData.name) &#123; fs.mkdirSync(projectData.name) var fileData = projectData.fileData fileData.forEach(function(f) &#123; f.content = f.content? f.content : &apos;&apos; f.path = projectData.name + &apos;/&apos; + f.name switch (f.type) &#123; case &apos;dir&apos;: fs.mkdirSync(f.path) break; case &apos;file&apos;: fs.writeFileSync(f.path, f.content) break; default: break; &#125; &#125;)&#125; 如果使用的是webstorm, 那么直接使用ctrl+f9, 让你的node程序跑起来吧~","categories":[{"name":"Nodejs学习笔记","slug":"Nodejs学习笔记","permalink":"https://github.com/ChangerHe/categories/Nodejs学习笔记/"}],"tags":[{"name":"Nodejs学习笔记","slug":"Nodejs学习笔记","permalink":"https://github.com/ChangerHe/tags/Nodejs学习笔记/"}]},{"title":"ES6中的遍历器接口Iterator","slug":"ES6中的遍历器接口Iterator","date":"2017-06-15T15:34:18.000Z","updated":"2017-09-14T14:39:16.288Z","comments":true,"path":"2017/06/15/ES6中的遍历器接口Iterator/","link":"","permalink":"https://github.com/ChangerHe/2017/06/15/ES6中的遍历器接口Iterator/","excerpt":"","text":"初读阮一峰老师的这本书,简直如发现了新世界一般.原来ES6的语法是如此的清奇. 随着ES6, ES7, 到今年七月份的ES8. 我们会发现,javascript这门最初被定义在客户端的’玩具语言’已经变得越发的强壮和标准,这也是我们作为前端ers 所希望看到的,毕竟,这涉及到以后的饭碗呢哈哈. 阮一峰老师的文笔还是不错的,但是随着后面的阅读,会发现有一些后面的知识,被直接不明就里的拿到前面来用了,这就导致我这个新手小白就有点懵逼了. 比如说: 箭头函数,当然,这个比较好理解,有固定的语法 但是,阮老师一直有提到的iterator接口,到底是个啥? 估计初学ES6的新手小白自然会有着和我一样的困惑. 那么,下面就综合我的搜索和总结,对iterator接口的相关知识,做一个分享,也算是对自己所学的一个总结 iterator接口是什么不知大家碰到此问题的时候是不是和我一样马上选择了百度(毕竟英语不够好,不能随随便便Google一下啊),泪奔~ 百度上面会告诉你, Java的iterator很好用巴拉巴拉 那么,在javascript中,iterator接口到底是个神马东西呢? iterator, 其实就是一个迭代器,或者说,是一个迭代器 在es6中，能表示“集合”概念的数据类型大致有四种:Array,Object,Map,Set 既然是集合，那遍历便是一种基本需求。而Iterator就是为了提供一种统一的接口机制。任何的数据结构，只要部署了Iterator接口，便可以使用类似的方式完成遍历操作。 当然，Iterator还有2个作用，它使数据结构的成员按某种次序排列，其次，es6有一种新的遍历方式，前面也说过，for…of，而Iterator的主要作用，就是支持此操作。 Iteartor的遍历过程是这样的 创建一个指向数据结构起始位置的指针。(起始位置不是第一个成员的位置，起始位置使一个单独的标志位。) 当调用next()方法，指针就向后移动一个位置，并返回当前位置上的成员，直到指针指向数据结构的结束位置为止。 第二步中，js语言返回的的成员信息是两个，value和done，value不用介绍，done是一个表示遍历是否结束的布尔值。 部署接口上面我们说到的部署接口，那js怎么部署接口呢。其实我们之前已经说到过，在Symbol一节中，介绍了很多es6内置的Symbol值，这些就是接口。 es6中有三类结构生来就具有Iterator接口：数组、类数组对象、Map和Set结构。 当然,如果你和我一样,现在看到第八章的话,暂时是没有学到Map和Set结构的,这个看下就好 12345678var arr = [1,2,3,4];let iterator = arr[Symbol.iterator]();console.log(iterator.next()); //&#123; value: 1, done: false &#125;console.log(iterator.next()); //&#123; value: 2, done: false &#125;console.log(iterator.next()); //&#123; value: 3, done: false &#125;console.log(iterator.next()); //&#123; value: 4, done: false &#125;console.log(iterator.next()); //&#123; value: undefined, done: true &#125; 数组，Map等结构中的成员都是有顺序的，即都是线性的结构，而对象，各成员并没有一个确定的顺序，所以遍历时先遍历谁后遍历谁并不确定。所以，给一个对象部署iterator接口，其实就是对该对象做一种线性转换。 如果有需要，可以手动给对象部署iterator接口 12345678910111213141516171819let obj = &#123; data: [ &apos;hello&apos;, &apos;world&apos; ], [Symbol.iterator]() &#123; const self = this; let index = 0; return &#123; next() &#123; if (index &lt; self.data.length) &#123; return &#123; value: self.data[index++], done: false &#125;; &#125; else &#123; return &#123; value: undefined, done: true &#125;; &#125; &#125; &#125;; &#125;&#125;; 可以看到，Symbol.iterator会返回一个对象，这就是一个遍历器对象，而作为遍历器对象，其必须具备的特征就是必须具备next()方法。 至于可以使用Array.from转换成数组的类数组对象，部署iterator有一种很简单的方法，即直接使用数组的[Symbol.iterator]接口。 1fakeArray.prototype[Symbol.iterator] = Array.prototype[Symbol.iterator]; 用Generator函数来实现Symbol.iterator接口，事半功倍。 这也是看到第八章我要出来百度的原因,因为影响到了我正常的往下阅读了 12345678var yieldIterator = &#123;&#125;;yieldIterator[Symbol.iterator] = function* () &#123; yield 1; yield 2; yield 3;&#125;;[...yieldIterator] // [1, 2, 3] 注意，yield* 后面跟的是一个可遍历的结构，它会调用该结构的遍历器接口。 其次，其它调用到遍历器的操作还有解构赋值、扩展操作符、其它任何接受数组作为参数的场合，如： for…ofArray.from()Map(), Set(), WeakMap(), WeakSet()（比如）Promise.all()Promise.race() 一旦当你给你的结构部署了iterator接口，那么恭喜你，你可以使用for…of来遍历你的结构了！ 遍历器对象除了必须布置next方法以外，还有2个可选方法。return()和throw()。当一个解构在遍历的时候异常提前退出(比如break,continue或者出错)的时候，就会调用return方法，其次，return方法必须返回一个对象。 至于throw方法，则是用于抛出错误，Generator.prototype.throw for of循环有很多优点，比如不像for…in一样只遍历键名（甚至包括原型链上的键），而且不像foreach不能跳出循环。并且for…of为各种数据结构提供了一个统一的遍历方法。所以，尽量使用它吧~","categories":[{"name":"ES6标准入门阅读笔记","slug":"ES6标准入门阅读笔记","permalink":"https://github.com/ChangerHe/categories/ES6标准入门阅读笔记/"}],"tags":[{"name":"ES6标准入门阅读笔记","slug":"ES6标准入门阅读笔记","permalink":"https://github.com/ChangerHe/tags/ES6标准入门阅读笔记/"}]},{"title":"JavaScript躲坑指南（一）","slug":"JavaScript躲坑指南（一）","date":"2017-06-15T15:03:29.000Z","updated":"2017-09-14T14:37:46.143Z","comments":true,"path":"2017/06/15/JavaScript躲坑指南（一）/","link":"","permalink":"https://github.com/ChangerHe/2017/06/15/JavaScript躲坑指南（一）/","excerpt":"","text":"本系列将会写一些在正常工作中会遇到的一些坑,然后分析它们的产生原因及解决办法.本文的内容主要来自&lt;you don’t know JS&gt;及日常工作的问题的一些总结. 坑一: 关于parseInt()方法转换字符串的问题,神坑!1234567console.log(parseInt(1/0, 19)); //18//原因:1/0得到的结果是Infinity,而得到的Infinity本身其实也是一个字符串,所以parseInt会以19进制对其进行类型转换,首字母为I,则其结果则为18了.console.log(parseInt(.000009)) //0console.log(parseInt(.0000009)) //9console.log(parseInt(false, 16)) //250,判定&apos;false&apos;的字符串的&apos;fa&apos;为十六进制了console.log(parseInt(parseInt, 16)) //15//结果为15的原因是因为parseInt为函数,所以会被typeof为function, 坑二: 位运算符~的妙用:在许多编程语言中,查找值或函数执行过程中,大于等于0的值表示查找或执行成功,返回-1则表示查找或执行失败.因此当失败时,可以直接使用位运算符~进行判定,当为-1时, -(-1 + 1) 即为零,因此就可以直接进行布尔运算了. 1234var a = &quot;hello world&quot;;if(~a.indexof(&quot;lo&quot;))&#123; //查找不到值,则执行函数体中的内容&#125; 位运算的另一个巧妙用法:将值截除为一个32位整数 1234console.log(Math.floor(-.1)) //-1console.log(Math.floor(.1)) //0console.log(~~-.1) // 0console.log(~~.1) //0 坑三: 对于稀疏数组的输出差异在谷歌浏览器中,对于长度为三,无内容的稀疏数组显示为undefined*3,对于长度为三,但内容都赋值为undefined的数组,显示为[undefined, undefined, undefined].但是此情况在IE浏览器中显示的内容都是两个等号!不过在火狐中相对比较正常,输出的是文字”三个空的数组”和[undefined, undefined, undefined] 坑四: JSON.stringify的妙用:在序列化为JSON对象时,将该对象选择性输出,以得到想要的值; 123456var a = &#123; b: 42, c: &apos;41&apos;, d: [1,2,3]&#125;console.log(JSON.stringify(a, [&apos;b&apos;,&apos;d&apos;])) //&#123;&quot;b&quot;:42,&quot;d&quot;:[1,2,3]&#125; 当然,这个时候stringify还可以传递一个函数进去进行判断. 12345678var a = &#123; b: 42, c: &apos;41&apos;, d: [1,2,3]&#125;console.log(JSON.stringify(a, function(k, v)&#123; if(k !== &apos;c&apos;) return v;&#125;)) //&#123;&quot;b&quot;:42,&quot;d&quot;:[1,2,3]&#125; JSON.stringify()还有一个参数space,用来指定输出的缩进格式,space为数值时表示缩进的字符数,还可以是字符串,为字符串时最前面的十个字符用于每一级的缩进: 123456789101112131415var a = &#123; b: 42, c: &apos;41&apos;, d: [1,2,3]&#125;console.log(JSON.stringify(a, null, &quot;------------------&quot;));//&#123;//----------&quot;b&quot;: 42,//----------&quot;c&quot;: &quot;41&quot;,//----------&quot;d&quot;: [//--------------------1,//--------------------2,//--------------------3//----------]//&#125; 从上面来看,使用位运算得到的值和Math.floor() 的值不尽相同,使用位运算相当于直接去掉了数字的小数点. 坑五: 当在函数内部为变量指定新值后,并不影响传参的值.当函数内部制定了变量值后,输出的值是不一样的,我们来看一下例子: 12345678910function foo(x) &#123; x.push(4); console.log(x); //输出的是[1,2,3,4],没毛病 x = [4,5,6]; x.push(7); console.log(x); //输出[4,5,6,7]这个没毛病&#125;var a = [1,2,3];foo(a);console.log(a); //这个情况下,a的值其实是[1,2,3,4]; 其实主要的原因是这样的,当我们的a作为参数传到foo函数中的时候,foo中的参数x其实是获得了一个到a数组的指针,当x进行相应的数值处理操作的时候,会直接作用到a上面,但是当x的指针改变了,也就是x被重新赋值的时候,x的指针就指向新的[4,5,6]数组了,这个时候其实后面的push(7)的操作已经是对于新的数组,并没有对a数组进行相应的操作,故最后返回的a的值只是[1,2,3,4] 坑六: 为变量赋予常量值的问题一个很小的问题(其实涉及到的知识点和上面是类似的),当我为一个变量赋予了一个常量值,但通过函数对这个常量值进行更改,那么更改会不会体现到这个常量值中呢?1234567function foo(x) &#123; x = x + 1; console.log(x);&#125;var a = 2;foo(a);console.log(a); //此时a还是为2 坑七: 关于浅复制的一些小技巧(也是对上面问题的另一种出理方案)使用slice()方法对变量进行浅复制,达到不影响变量原来的值的目的. 1foo(slice() ) 坑八: new出的对象使用new方法new出来的变量都是属于对象,因此进行类型检测时都会显示为object型. 坑九: 关于隐式类型转换对new出来的对象来讲,对其进行判断会有一个自动的隐式类型转换过程,自动调用数组中的valueof()方法,因此就有了以下这样的奇葩现象: 12345678var a = 2;Number.prototype.valueOf = function() &#123; return a++;&#125;var b = new Number(2);if(b == 2 &amp;&amp; b ==3) &#123; console.log(&apos;WTF?&apos;) //WTF?&#125; 其实这个问题很好解释,每次对b进行判断都是会调用其valueof方法,而valueof方法中a会自增1,因此会有b又等于2,又等于3的情况.","categories":[{"name":"JavaScript躲坑指南","slug":"JavaScript躲坑指南","permalink":"https://github.com/ChangerHe/categories/JavaScript躲坑指南/"}],"tags":[{"name":"JavaScript躲坑指南","slug":"JavaScript躲坑指南","permalink":"https://github.com/ChangerHe/tags/JavaScript躲坑指南/"}]},{"title":"JavaScript躲坑指南（二）","slug":"JavaScript躲坑指南（二）","date":"2017-06-15T15:02:38.000Z","updated":"2017-09-14T14:37:53.212Z","comments":true,"path":"2017/06/15/JavaScript躲坑指南（二）/","link":"","permalink":"https://github.com/ChangerHe/2017/06/15/JavaScript躲坑指南（二）/","excerpt":"","text":"本系列将会写一些在正常工作中会遇到的一些坑,然后分析它们的产生原因及解决办法.本文的内容主要来自&lt;you don’t know JS&gt;及日常工作的问题的一些总结. 关于arguments的使用:arguments在ES6之前简直就是福音,因为在ES6之前是没有办法取到函数的参数组成的数组的. 但是arguments在使用的过程中还是有一些坑的,我们来看一下: 123456function foo(a) &#123; a = 42; console.log(arguments[0])&#125;foo(2); //42foo(); //undefined 在向函数传递参数的时候,arguments数组中的对应单元会和命名参数建立关联,以得到相同的值,但是当函数在调用的时候没有传递参数时,因为没有参数,自然arguments就无法和函数建立关联了,自然就是undefined. try/catch/finally的内容执行先后的问题finally中的代码总是会在try之后执行,如果有catch的话会在catch之后执行.其实也可以把finally中的代码当做一个回调函数.无论出现什么情况,最后一定会被调用. 12345678910function foo() &#123; try &#123; return 42; &#125; finally &#123; console.log(&apos;hello&apos;) &#125; console.log(&apos;never runs&apos;);&#125;console.log(foo());//输出结果: 先输出 hello 再输出返回的值hello 在这里return42先执行,并将foo()函数的返回值设置为42.try执行完毕后执行finally.console.log()显示的是函数的返回值. 对于这个问题还有一个很好玩的东西,就是当你在finally中进行抛出异常时,其实try中的返回值就不生效了. 123456789function foo() &#123; try &#123; return 42; &#125; finally &#123; throw &quot;oops!&quot; &#125; console.log(&apos;never runs&apos;);&#125;console.log(foo()); // Uncaught oops! 其实综上而言,不论try中执行的是什么东西,即使是return或者throw等让函数立即结束的语句,最后finally也会成功执行.但是当finally中抛出异常时,try中的代码其实就相当于无效了.也就是finally中的值会最终覆盖掉try中的值. 关于全局的DOM变量当我们在文档流中加入 &lt;div id=&quot;foo&quot;&gt;&lt;/div&gt; 时,我们在其下面的js文档中能否找到foo这个变量呢?答案是可以! 12//我们直接在文档的下面进行类型判定console.log(typeof foo); //输出结果是object, WTF? 关于属性的屏蔽当我们在原型链中为底层函数操作原型链中的属性进行算术运算时,属性被被底层函数给屏蔽掉. 1234567var anotherObject = &#123; a: 2&#125;var myObject = Object.create(anotherObject);console.log(myObject.a);myObject.a++;console.log(myObject.a,anotherObject.a); 其实想到原理就很简单,因为当我们把myObject中的a,也就是anotherObject中的a调用之后,相应的myObject.a会得到anotherObject中的a的值,也就是2.但是当我们对myObject执行其属性的自加操作之后,它的底层其实是这样的: 123myObject.__proto__.a = 2;myObject= &#123;a:myObject.__proto__.a&#125;;myObject.a = myObject.a + 1; 关于concat()方法连接数组和push()方法连接数组的区别首先我们看一个例子: 12345678var nums = [2, 3, 4, 5];console.log(nums.concat([1, 2]))//[2, 3, 4, 5, 1, 2]console.log(nums)//[2, 3, 4, 5]nums.push([1, 2])console.log(nums)[2, 3, 4, 5, [1, 2]] 其实看了这个例子大家应该都懂了,首先,concat的作用是链接两个数组,会将两个数组拼合成一个数组,并且不会改变之前的数组的值,而是返回一个新数组. 而push()则直接改变了数组的值,而且是直接将push()中传的参数直接接到了数组的后面,也就是当我们在push()中传参数组时,最后会得到一个嵌套的数组.","categories":[{"name":"JavaScript躲坑指南","slug":"JavaScript躲坑指南","permalink":"https://github.com/ChangerHe/categories/JavaScript躲坑指南/"}],"tags":[{"name":"JavaScript躲坑指南","slug":"JavaScript躲坑指南","permalink":"https://github.com/ChangerHe/tags/JavaScript躲坑指南/"}]},{"title":"JavaScript模块化编程-commonjs和AMD及CMD","slug":"JavaScript模块化编程-commonjs和AMD及CMD","date":"2017-06-15T15:00:36.000Z","updated":"2017-09-14T14:35:26.947Z","comments":true,"path":"2017/06/15/JavaScript模块化编程-commonjs和AMD及CMD/","link":"","permalink":"https://github.com/ChangerHe/2017/06/15/JavaScript模块化编程-commonjs和AMD及CMD/","excerpt":"","text":"commonjs2009年，美国程序员Ryan Dahl创造了node.js项目，将javascript语言用于服务器端编程。 这标志”Javascript模块化编程”正式诞生。因为老实说，在浏览器环境下，没有模块也不是特别大的问题，毕竟网页程序的复杂性有限；但是在服务器端，一定要有模块，与操作系统和其他应用程序互动，否则根本没法编程。 node.js的模块系统，就是参照CommonJS规范实现的。在CommonJS中，有一个全局性方法require()，用于加载模块。假定有一个数学模块math.js，就可以像下面这样加载。 var math = require(&#39;math&#39;); 然后就可以调用math.js中提供的各种接口API,在自己的程序中直接使用. 12var math = require(&apos;math&apos;);math.add(2, 3); //5 AMD和CMD有了服务器端模块以后，很自然地，大家就想要客户端模块。而且最好两者能够兼容，一个模块不用修改，在服务器和浏览器都可以运行。 但是，由于一个重大的局限，使得CommonJS规范不适用于浏览器环境。还是上一节的代码，如果在浏览器中运行，会有一个很大异步加载的问题. 还是刚刚的代码,当我的程序在使用commonjs规范的时候,因为整个require的请求是异步的,所以当我们使用require进行请求math.js时,必须要等math.js完全加载完毕后,才能够进行下一步的操作. 这对服务器端不是一个问题，因为所有的模块都存放在本地硬盘，可以同步加载完成，等待时间就是硬盘的读取时间。但是，对于浏览器，这却是一个大问题，因为模块都放在服务器端，等待时间取决于网速的快慢，可能要等很长时间，浏览器处于”假死”状态。 因此，浏览器端的模块，不能采用”同步加载”（synchronous），只能采用”异步加载”（asynchronous）。这就是AMD规范诞生的背景。 AMDAMD是”Asynchronous Module Definition”的缩写，意思就是”异步模块定义”。它采用异步方式加载模块，模块的加载不影响它后面语句的运行。所有依赖这个模块的语句，都定义在一个回调函数中，等到加载完成之后，这个回调函数才会运行。 AMD也采用require()语句加载模块，但是不同于CommonJS，它要求两个参数： 1require([module], callback); 第一个参数[module]，是一个数组，里面的成员就是要加载的模块；第二个参数callback，则是加载成功之后的回调函数。如果将前面的代码改写成AMD形式，就是下面这样： 123require([&apos;math&apos;], function (math) &#123; math.add(2, 3);&#125;); math.add()与math模块加载不是同步的，浏览器不会发生假死。所以很显然，AMD比较适合浏览器环境。 目前，主要有两个Javascript库实现了AMD规范：require.js和curl.js。 require.js最早的时候，所有Javascript代码都写在一个文件里面，只要加载这一个文件就够了。后来，代码越来越多，一个文件不够了，必须分成多个文件，依次加载。 这样的写法有很大的缺点。首先，加载的时候，浏览器会停止网页渲染，加载文件越多，网页失去响应的时间就会越长；其次，由于js文件之间存在依赖关系，因此必须严格保证加载顺序（比如上例的1.js要在2.js的前面），依赖性最大的模块一定要放到最后加载，当依赖关系很复杂的时候，代码的编写和维护都会变得困难。 !()[http://image.beekka.com/blog/201211/bg2012110701.png] 使用require.js的第一步，是先去官方网站下载最新版本。下载后，假定把它放在js子目录下面，就可以加载了。 1&lt;script src=&quot;js/require.js&quot;&gt;&lt;/script&gt; 有人可能会想到，加载这个文件，也可能造成网页失去响应。解决办法有两个，一个是把它放在网页底部加载，另一个是写成下面这样： 1&lt;script src=&quot;js/require.js&quot; defer async=&quot;true&quot; &gt;&lt;/script&gt; async属性表明这个文件需要异步加载，避免网页失去响应。IE不支持这个属性，只支持defer，所以把defer也写上。 加载require.js以后，下一步就要加载我们自己的代码了。假定我们自己的代码文件是main.js，也放在js目录下面。那么，只需要写成下面这样就行了： 1&lt;script src=&quot;js/require.js&quot; data-main=&quot;js/main&quot;&gt;&lt;/script&gt; data-main属性的作用是，指定网页程序的主模块。在上例中，就是js目录下面的main.js，这个文件会第一个被require.js加载。由于require.js默认的文件后缀名是js，所以可以把main.js简写成main。 require.js主模块的写法上一节的main.js，我把它称为”主模块”，意思是整个网页的入口代码。它有点像C语言的main()函数，所有代码都从这儿开始运行。主模块依赖于其他模块，这时就要使用AMD规范定义的的require()函数。 1234// main.jsrequire([&apos;moduleA&apos;, &apos;moduleB&apos;, &apos;moduleC&apos;], function (moduleA, moduleB, moduleC)&#123; // some code here&#125;); require()函数接受两个参数。第一个参数是一个数组，表示所依赖的模块，上例就是[‘moduleA’, ‘moduleB’, ‘moduleC’]，即主模块依赖这三个模块；第二个参数是一个回调函数，当前面指定的模块都加载成功后，它将被调用。加载的模块会以参数形式传入该函数，从而在回调函数内部就可以使用这些模块。 require()异步加载moduleA，moduleB和moduleC，浏览器不会失去响应；它指定的回调函数，只有前面的模块都加载成功后，才会运行，解决了依赖性的问题。","categories":[{"name":"JavaScript模块化编程","slug":"JavaScript模块化编程","permalink":"https://github.com/ChangerHe/categories/JavaScript模块化编程/"}],"tags":[{"name":"JavaScript模块化编程","slug":"JavaScript模块化编程","permalink":"https://github.com/ChangerHe/tags/JavaScript模块化编程/"}]},{"title":"JavaScript深入浅出-call/apply","slug":"JavaScript深入浅出-call-apply","date":"2017-06-15T14:51:48.000Z","updated":"2017-09-14T14:37:36.463Z","comments":true,"path":"2017/06/15/JavaScript深入浅出-call-apply/","link":"","permalink":"https://github.com/ChangerHe/2017/06/15/JavaScript深入浅出-call-apply/","excerpt":"","text":"本文中call和apply仅占小部分,主要还是关于自己在学习过程中踩到的坑的记录. 使用call方法将变量产生的数组进行转换1234567function foo(a, b, c) &#123; var arr1 = [].reverse.call(arguments); console.log(arr1); var arr2 = [].slice.call(arguments); console.log(arr2.reverse());&#125;foo(1,2,3) 以上使用了两种方法，arr1使用了数组的reverse方法，并将数组的reverse方法借用给arguments，也就是说arguments使用了数组中的方法，之前的arguments是没有这个方法的。其最终产生的效果是，arr1还是数组的集合。 第二种方法其实是首先将数组的slice方法的作用域赋予给arguments，那么arguments其实是使用了slice的方法进行了数组的序列化，最终产生的效果其实是arr2最终变成了一个数组，然后使用数组，也就是arr2的作用域链中的reverse方法进行了调换。 arrow函数 箭头函数其实是对于单调乏味且冗长的function关键词的简写，如： 1234var foo = a =&gt; &#123; console.log(a)&#125;foo(2); //2 其实在这个情况下，以上的程序是等价于以下的程序的： 1234var foo = function(a) &#123; console.log(a);&#125;foo(2); 那么问题来了，这个箭头函数到底表示的是函数表达式还是函数声明呢？，经过一个简单的测试，发现其实这个箭头函数就是一个简单的函数表达式，我们来测试以下它的函数提升过程： 1234foo(2);var foo = a =&gt; &#123; console.log(a); //TypeError: foo is not a function&#125; 严格模式下必报的this指向问题严格模式下，全局对象无法绑定到未进行修饰的函数声明，因此在全局作用域下，在函数内调用this时会造成报错： Cannot read property ‘a’ of undefined；12345(function foo() &#123; &quot;use strict&quot;; var a = 2; console.log(this.a); //Cannot read property &apos;a&apos; of undefined；&#125;)() 关于this的作用层级问题对象中只有引用链的最顶层或者说是作用者的最后一层会影响其调用位置，来看一下下面的这个代码，很奇怪的事情是this居然指向的是obj1 而不是obj2，原因就是因为作用者的最后一层就是obj1.123456789101112function foo() &#123; console.log(this.a);&#125;var obj1 = &#123; a: 1, foo: foo&#125;var obj2 = &#123; a: 2, obj1: obj1&#125;obj2.obj1.foo(); //输出的是1，也就是代表this其实指向的是obj1 引用类型常量的赋值问题当函数内部制定了变量值后,输出的值是不一样的,我们来看一下例子:function foo(x) { x.push(4); console.log(x); //输出的是[1,2,3,4],没毛病 x = [4,5,6]; x.push(7); console.log(x); //输出[4,5,6,7]这个没毛病}var a = [1,2,3];foo(a);console.log(a); //这个情况下,a的值其实是[1,2,3,4];12345其实主要的原因是这样的,当我们的a作为参数传到foo函数中的时候,foo中的参数x其实是获得了一个到a数组的指针,当x进行相应的数值处理操作的时候,会直接作用到a上面,但是当x的指针改变了,也就是x被重新赋值的时候,x的指针就指向新的[4,5,6]数组了,这个时候其实后面的push(7)的操作已经是对于新的数组,并没有对a数组进行相应的操作,故最后返回的a的值只是[1,2,3,4]# 引用类型常量的赋值问题再探讨一个很小的问题(其实涉及到的知识点和第五条是类似的),当我为一个变量赋予了一个常量值,但通过函数对这个常量值进行更改,那么更改会不会体现到这个常量值中呢? function foo(x) { x = x + 1; console.log(x);}var a = 2;foo(a);console.log(a); //此时a还是为2```","categories":[{"name":"JavaScript 学习笔记","slug":"JavaScript-学习笔记","permalink":"https://github.com/ChangerHe/categories/JavaScript-学习笔记/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://github.com/ChangerHe/tags/JavaScript/"}]},{"title":"深入理解JavaScript构造函数和原型对象","slug":"深入理解JavaScript构造函数和原型对象","date":"2017-06-15T14:16:09.000Z","updated":"2017-09-14T15:02:33.119Z","comments":true,"path":"2017/06/15/深入理解JavaScript构造函数和原型对象/","link":"","permalink":"https://github.com/ChangerHe/2017/06/15/深入理解JavaScript构造函数和原型对象/","excerpt":"","text":"对象？对象，是javascript中非常重要的一个梗，是否能透彻的理解它直接关系到你对整个javascript体系的基础理解，说白了，javascript就是一群对象在搞！！基！！ 常用的几种对象创建模式使用new关键字创建最基础的对象创建方式，无非就是和其他多数语言一样说的一样：所以俗话说得好，当我们程序猿们没对象的时候，我们应该“new”一个对象出来。123456var gf = new Object();gf.name = &quot;tangwei&quot;;gf.bar = &quot;c++&quot;;gf.sayWhat = function() &#123; console.log(this.name + &quot;said:love you forever&quot;);&#125; 使用字面量创建这样似乎妥妥的了，但是宅寂的geek们岂能喜欢如此复杂和low土的定义变量的方式，作为一门脚本语言那应该有和其他兄弟们一样的范儿，于是出现了对象字面量的定义方式：1234567var gf = &#123; name : &quot;tangwei&quot;, bar : &quot;c++&quot;, sayWhat : function() &#123; console.log(this.name + &quot;said:love you forever&quot;); &#125;&#125; 工厂模式实际上这是我们在实际中最常用的对象定义方式，但是我要有好多拥有相似属性的对象（想想都让人激动。。。）怎么办呢？那要是一个个的定义，就会产生大量的代码，何不建个工厂，批量的生产出我们的对象呢，于是，javascript世界中第一个充气娃。。。不，“工厂模式”诞生了！1234567891011function createGf(name, bar) &#123; var o = new Object(); o.name = name; o.bar = bar; o.sayWhat = function() &#123; alert(this.name + &quot;said:love you forever&quot;); &#125; return o;&#125;var gf1 = createGf(&quot;bingbing&quot;,&quot;d&quot;);var gf2 = createGf(&quot;mimi&quot;,&quot;a&quot;); 构造函数工厂模式解决了多个相似对象的创建问题，但是问题又来了，这些对象都是Object整出来的，怎么区分它们的对象具体类型呢？这时候我们就需要切换到另一种模式了，构造函数模式：123456789function Gf(name,bar)&#123; this.name = name; this.bar = bar; this.sayWhat = function()&#123; alert(this.name + &quot;said:love you forever&quot;); &#125;&#125;var gf1 = new Gf(&quot;vivian&quot;,&quot;f&quot;);var gf2 = new Gf(&quot;vivian2&quot;,&quot;f&quot;); 这里我们使用一个大写字母开头的构造函数替代了上例中的createGf，注意按照约定构造函数的首字母要大写。在这里我们创建一个新对象，然后将构造函数的作用域赋给新对象，调用构造函数中的方法。上面的方式似乎没什么不妥，但是我们可以发现，两个实例中调用的构造函数中的sayWhat方法不是同一个Function实例：1console.log(gf1.sayWhat == gf2.sayWhat); //false 调用同一个方法，却声明了不同的实例，实在浪费资源。我们可以优化一下将sayWhat函数放到构造函数外面声明：12345678function Gf(name,bar)&#123; this.name = name; this.bar = bar; this.sayWhat = sayWhat&#125;function sayWhat()&#123; alert(this.name + &quot;said:love you forever&quot;);&#125; 这样解决了，多个实例多次定义同一个方法实例的问题，但是新问题又来了，我们定义的sayWhat是一个全局作用域的方法，但这个方法其实是没法直接调用的，这就有点矛盾了。如何更优雅的定义一个具备一定封装性的对象呢？我们来看一下javascript原型对象模式。 原型对象模式当我们创建一个函数时，该函数就会具备一个prototype属性，这个属性指向通过构造函数创建的那个函数的原型对象。通俗点讲原型对象就是内存中为其他对象提供共享属性和方法的对象。在原型模式中，不必再构造函数中定义实例属性，可以将属性信息直接赋予原型对象：12345678910function Gf()&#123; Gf.prototype.name = &quot;vivian&quot;; Gf.prototype.bar = &quot;c++&quot;; Gf.prototype.sayWhat = function()&#123; alert(this.name + &quot;said:love you forever&quot;); &#125;&#125;var gf1 = new Gf();gf1.sayWhat();var gf2 = new Gf(); 和构造函数不同的是这里新对象的属性和方法是所有实例都可以共享的，换句话说gf1和gf2访问的是同一份属性和方法。原型对象中除了我们赋予的属性外，还有一些内置的属性，所有原型对象都具备一个constructor属性，这个属性是一个指向包含prototype属性函数的一个指针（敢不敢再绕点！）。通过一幅图我们来清楚的理一下这个绕口的流程：所有的对象都有一个原型对象（prototype），原型对象中有一个constructor属性指向包含prototype属性的函数，Gf的实例gf1和gf2都包含一个内部属性指向原型对象（在firefox浏览器中表现为私有属性proto），当我们访问一个对象中的属性时，首先会询问实例对象中有没有该属性，如果没有则继续查找原型对象。在前面的示例中，我们注意到在为原型对象添加属性时，需要每个都增加Gf.prototype，这个工作很重复，在上面对象的创建模式中，我们知道可以通过字面量的形式创建一个对象，这里我们也可以改进一下：12345678function Gf()&#123;&#125;Gf.prototype = &#123; name : &quot;vivian&quot;, bar : &quot;c++&quot;, sayWhat : function()&#123; alert(this.name + &quot;said:love you forever&quot;); &#125;&#125; 这里有一个地方需要特别注意，constructor属性不再指向对象Gf，因为每定义一个函数，就会同时为其创建一个prototype对象，这个对象也会自动获取一个新的constructor属性，这个地方我们使用Gf.prototype本质上覆写了原有的prototype对象，因此constructor也变成了新对象的constructor属性，不再指向Gf，而是Object:123var gf1 = new Gf();console.log(gf1.constructor == Gf);//falseconsole.log(gf1.constructor == Object)//true 一般情况下，这个微妙的改变是不会对我们造成影响的，但如果你对constructor有特殊的需求，我们也可以显式的指定下Gf.prototype的constructor属性：12345678910Gf.prototype = &#123; constructor : Gf, name : &quot;vivian&quot;, bar : &quot;c++&quot;, sayWhat : function() &#123; alert(this.name + &quot;said:love you forever&quot;); &#125;&#125;var gf1 = new Gf();console.log(gf1.constructor == Gf);//true 通过对原型对象模式的初步了解，我们发现所有的实例对象都共享相同的属性，这是原型模式的基本特点，但往往对于开发者来说这是把“双刃剑”，在实际开发中，我们希望的实例应该是具备自己的属性，这也是在实际开发中很少有人单独使用原型模式的主要原因。 构造函数和原型组合模式在实际开发中，我们可以使用构造函数来定义对象的属性，使用原型来定义共享的属性和方法，这样我们就可以传递不同的参数来创建出不同的对象，同时又拥有了共享的方法和属性。123456789101112function Gf(name,bar)&#123; this.name = name; this.bar = bar;&#125;Gf.prototype = &#123; constructor : Gf, sayWhat : function() &#123; alert(this.name + &quot;said:love you forever&quot;); &#125;&#125;var gf1 = new Gf(&quot;vivian&quot;, &quot;f&quot;);var gf2 = new Gf(&quot;vivian1&quot;, &quot;c&quot;); 在这个例子中，我们再构造函数中定义了对象各自的属性值，在原型对象中定义了constructor属性和sayWhat函数，这样gf1和gf2属性之间就不会产生影响了。这种模式也是实际开发中最常用的对象定义方式，包括很多js库（bootstrap等）默认的采用的模式。","categories":[{"name":"JavaScript 学习笔记","slug":"JavaScript-学习笔记","permalink":"https://github.com/ChangerHe/categories/JavaScript-学习笔记/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://github.com/ChangerHe/tags/JavaScript/"}]},{"title":"JavaScript深入浅出-闭包及闭包问题的解决办法","slug":"JavaScript深入浅出-闭包及解决办法","date":"2017-06-15T14:15:34.000Z","updated":"2017-09-14T14:38:05.948Z","comments":true,"path":"2017/06/15/JavaScript深入浅出-闭包及解决办法/","link":"","permalink":"https://github.com/ChangerHe/2017/06/15/JavaScript深入浅出-闭包及解决办法/","excerpt":"","text":"闭包是什么?在JS中可谓处处是闭包,也许你不知道这个概念,但是你一定自己手写过闭包,而且还碰到了闭包的问题. 闭包的最大作用还是解决了全局作用域中的变量被污染的问题. 但是闭包虽有好处,但是也不能滥用,因为闭包的调用机制使得垃圾回收机制(GC)在闭包使用完毕后,无法对其进行回收,使用过多的话会影响到性能.特别是在IE浏览器中,因为IE浏览器在IE8及之前的GC机制使用的是引用计数方式,所以使用闭包会产生内存泄露.万幸在IE9中更正了这个问题,现在绝大部分浏览器实现的是标记清除式的GC机制. 如果必须使用闭包的时候,笔者建议可在闭包使用完之后,可以将其引用变量设置为null,以便清除其占用的内存空间. 一个很简单的闭包例子123456789function add() &#123; var a = 100; return function() &#123; return a++; &#125;&#125;var a = add();console.log(a()); //100console.log(a()); //101 看,这就是闭包了,闭包的调用也很方便,直接执行函数中的函数,就可以了. 闭包产生的问题和解决方法其实闭包最大的危害就是在函数进行循环调用的时候以及使用回调函数的时候了,之前没懂闭包,做这类问题的时候是相当的头痛啊,这里我就简单介绍一下如何解决这类问题.下面以循环调用为例. 1234567891011121314function returnArr() &#123; var arr = []; for (var i = 0; i &lt; 5; i++) &#123; arr[i] = function() &#123; return i &#125; &#125; return arr;&#125;var a = returnArr();for (var i = 0; i &lt; 5; i++) &#123; console.log(a[i]()) //5 5 5 5 5&#125; 可能这个时候很多人会觉得很奇怪,这是什么情况啊,我明明是想要输出0 1 2 3 4的啊!这个时候,你其实已经写了一个闭包了. 闭包问题的产生原因在循环体中,当我们像平常一样调用函数中的函数的时候,其实这个时候循环体早就执行完毕了,所以这个时候输出的值是一个固定的值,在本题中输出的是5,因为循环一直到4时跳转,在循环到四之后最后还有一个4++的操作,最终输出的是5 解决闭包问题的方案1.将函数体转换为自执行函数,这个时候就可以在循环的同时将函数一起执行了,所以i的值可以正确地传入,但是因为自执行函数是一个封闭的作用域,所以在这个时候应该将i的值作为参数传递到这个封闭作用域中,最后可以得到想要的输出结果. 1234567891011function returnArr() &#123; var arr = []; for (var i = 0; i &lt; 5; i++) &#123; arr[i] = function(a) &#123; return a &#125;(i) &#125; return arr;&#125;var a = returnArr();console.log(a); //0 1 2 3 4 2.将函数中再嵌套一个函数,然后再执行以下函数中的函数,这样也可以解决闭包问题,但是为什么我在里面又嵌套了一个匿名函数,却没有再次产生闭包的问题呢?这是因为当我们传参给自执行函数时,其参数时直接驻留在自执行函数的内存中的. 123456789101112131415function returnArr() &#123; var arr = []; for (var i = 0; i &lt; 5; i++) &#123; arr[i] = function(a) &#123; return function() &#123; return a; &#125; &#125;(i) &#125; return arr;&#125;var a = returnArr();for (var i = 0; i &lt; 5; i++) &#123; console.log(a[i]())&#125; 闭包的时候的this指向问题产生闭包的时候,闭包里的this其实是指向window的. 12345678var box = &#123; getThis: function() &#123; return function() &#123; return this; &#125; &#125;&#125;console.log(box.getThis()()) //window 那么当我在使用闭包的时候,想让这个this再指回我们的调用对象怎么办呢?这个时候我们的call方法就派上用场了. 很多时候,call和apply的用法是类似的,只是传参不同而已,大部分情况下使用call也意味着可以使用apply.apply就不演示了.其实两者都是一样的. 12345678var box = &#123; getThis: function() &#123; return function() &#123; return this; &#125; &#125;&#125;console.log(box.getThis().call(box)) //box 当我们不想用call或者apply方法怎么办呢?ES5中新增了一种方法就是bind(),可以将函数的this硬绑定到一个对象上. 123456789var box = &#123; getThis: function() &#123; return function() &#123; return this; &#125; &#125;&#125;var a = box.getThis();console.log(a.bind(box)()) //box 觉得上面的方法复杂,不想用?别急还有一种暴力方法解决这个问题,就是直接在函数体中动刀. 123456789var box = &#123; getThis: function() &#123; var that = this; return function() &#123; return that; &#125; &#125;&#125;console.log(box.getThis()()) //box 利用闭包来模仿块级作用域包含自我执行的匿名函数,就可以创建私有作用域 12345678(function() &#123; (function() &#123; for (var i = 0; i &lt; 5; i++) &#123; &#125; &#125;)() console.log(i) //ReferenceError: i is not defined&#125;)() 那么根据以上,就可以引申出各种设计模式了.比如说单例模式啊,工厂模式啊.构造函数模式啊巴拉巴拉.这个在我的JavaScript高级程序设计复习笔记（三）这一篇博客里面有详细讲解.","categories":[{"name":"JavaScript 学习笔记","slug":"JavaScript-学习笔记","permalink":"https://github.com/ChangerHe/categories/JavaScript-学习笔记/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://github.com/ChangerHe/tags/JavaScript/"}]},{"title":" JavaScript笔试面试题收集（二）","slug":"JavaScript笔试面试题收集（二）","date":"2017-06-15T13:34:18.000Z","updated":"2017-09-14T14:38:56.029Z","comments":true,"path":"2017/06/15/JavaScript笔试面试题收集（二）/","link":"","permalink":"https://github.com/ChangerHe/2017/06/15/JavaScript笔试面试题收集（二）/","excerpt":"","text":"本系列主要在于对自己的日常学习的内容做一个归纳整理,同时分享一些平时遇到的一些比较好的面试题. 通过对笔试面试题的学习,强化自己的所学知识面. 话不多说，直接撸题吧：123456789101112131415161718192021222324252627282930function Parent() &#123; this.a = 1; this.b = [1,2,this.a]; this.c = &#123;demo: 5&#125;; this.show = function() &#123; console.log(this.a, this.b, this.c.demo) &#125;&#125;function Child() &#123; this.a = 2; this.change = function() &#123; this.b.push(this.a); this.a = this.b.length; this.c.demo = this.a++; &#125;&#125;Child.prototype = new Parent();var parent = new Parent();var child1 = new Child();var child2 = new Child();child1.a = 11;child2.a = 12;parent.show(); //1,[1,2,1],5child1.show(); //11,[1,2,11],5child2.show(); //12,[1,2,11],5child1.change(); child2.change(); parent.show(); // 1,[1,2,1],5child1.show(); //5,[1,2,1,11,12],5child2.show(); //6,[1,2,1,11,12],5 其实要解出上面的问题，了解以下几句话就好了： 1.每个构造函数，都有一个原型，指向构造函数的原型对象。2.每一个实例生成的时候，都会在内存中产生一块新的堆内存。3.每一个实例都有一个隐式原型指向构造函数的原型对象。4.this的指向，取决于this调用的位置，在这道题中，也可以理解为，谁调用这个方法，this就指向哪个对象。5.数组和字面量对象都是引用。6.原型链的查找原则： 就近原则。也就是说：当实例上存在属性时，用实例上的，如果实例不存在，则顺着原型链往上查找，如果存在，则使用原型链上的对象，如果不存在，则查找Object原型对象上的，如果都不存在，则为undefined。","categories":[{"name":"JavaScript笔试面试题","slug":"JavaScript笔试面试题","permalink":"https://github.com/ChangerHe/categories/JavaScript笔试面试题/"}],"tags":[{"name":"JavaScript笔试面试题","slug":"JavaScript笔试面试题","permalink":"https://github.com/ChangerHe/tags/JavaScript笔试面试题/"}]},{"title":"JavaScript笔试面试题收集（一）","slug":"JavaScript笔试面试题收集（一）","date":"2017-06-15T13:34:18.000Z","updated":"2017-09-14T14:38:39.890Z","comments":true,"path":"2017/06/15/JavaScript笔试面试题收集（一）/","link":"","permalink":"https://github.com/ChangerHe/2017/06/15/JavaScript笔试面试题收集（一）/","excerpt":"","text":"本系列主要在于对自己的日常学习的内容做一个归纳整理,同时分享一些平时遇到的一些比较好的面试题. 通过对笔试面试题的学习,强化自己的所学知识面. 出题的大师兄，草粉吗？123456789101112131415161718192021222324252627function Foo() &#123; getName = function () &#123; console.log(1); &#125;; return this;&#125;Foo.getName = function () &#123; console.log(2);&#125;;Foo.prototype.getName = function () &#123; console.log(3);&#125;;var getName = function () &#123; console.log(4);&#125;;function getName() &#123; console.log(5);&#125;;// 请写出以下输出结果：Foo.getName();getName();Foo().getName();getName();new Foo.getName();new Foo().getName();new new Foo().getName(); 题目只答对一半的宝宝表示很想哭啊。以下是解题思路：123456789101112131415161718192021222324252627Foo.getName(); // 2getName(); // 4Foo().getName(); // 1getName(); // 1new Foo.getName(); // 2// var a = new Foo.getName(); // var a = &#123;&#125;;// a.__proto = Foo.getName.prototype;// Foo.getName.call(a);new Foo().getName(); // 3// var b = new Foo().getName();// var b = &#123;&#125;;// b.__proto__ = Foo.prototype;// Foo.call(b);// b.getName();new new Foo().getName(); // 3// var c = new Foo().getName();// var c = &#123;&#125;;// c.__proto__ = Foo.prototype;// Foo.call(c);// var d = new c.getName();// var d = &#123;&#125;;// d.__proto__ = c.getName.prototype;// c.getName.call(d);","categories":[{"name":"JavaScript笔试面试题","slug":"JavaScript笔试面试题","permalink":"https://github.com/ChangerHe/categories/JavaScript笔试面试题/"}],"tags":[{"name":"JavaScript笔试面试题","slug":"JavaScript笔试面试题","permalink":"https://github.com/ChangerHe/tags/JavaScript笔试面试题/"}]},{"title":"JavaScript笔试面试题收集（三）","slug":"JavaScript笔试面试题收集（三）","date":"2017-06-15T13:34:18.000Z","updated":"2017-09-14T14:39:02.002Z","comments":true,"path":"2017/06/15/JavaScript笔试面试题收集（三）/","link":"","permalink":"https://github.com/ChangerHe/2017/06/15/JavaScript笔试面试题收集（三）/","excerpt":"","text":"本系列主要在于对自己的日常学习的内容做一个归纳整理,同时分享一些平时遇到的一些比较好的面试题. 通过对笔试面试题的学习,强化自己的所学知识面. 今天分享的题比较简单,主要是考察闭包的知识以及一些逻辑思维 123456789101112131415function fun(n,o)&#123; console.log(o) return &#123; fun:function(m)&#123; return fun(m,n) &#125;&#125;&#125;var a = fun(0); //undefineda.fun(1); //0a.fun(2); // 0a.fun(3); // 0var b = fun(0).fun(1).fun(2).fun(3); //undefined 0 1 2var c = fun(0).fun(1); // undefined 0c.fun(2); // 1c.fun(3); // 1 个人拙见:其实以上的代码主要还是一个闭包的问题,代码的逻辑判断清楚了就很好解.因为当我们传一个参的时候,第二个参数必然是undefined.这也是为什么abc一出来就执行的是undefined的原因.因为所有的函数执行都只传递了一个参数. 第二,当我们为返还的函数传参的时候,也就是给这个函数里面的函数fun的参数m传值的时候,会返回一个以m为第一个参数,其父函数的第一个参数作为第二个参数的函数. 其实说到这里就很好理解了,我们将函数看成一个很好玩的方法,我们传值进去的时候,它会记录两个值作为参数,并把第二个参数的值打印出来,再往里面传一个值的时候,就会把之前的第一个参数挪到后面作为第二个参数.以此类推.","categories":[{"name":"JavaScript笔试面试题","slug":"JavaScript笔试面试题","permalink":"https://github.com/ChangerHe/categories/JavaScript笔试面试题/"}],"tags":[{"name":"JavaScript笔试面试题","slug":"JavaScript笔试面试题","permalink":"https://github.com/ChangerHe/tags/JavaScript笔试面试题/"}]},{"title":"JavaScript笔试面试题收集（四）","slug":"JavaScript笔试面试题收集（四）","date":"2017-06-15T13:34:18.000Z","updated":"2017-09-14T14:39:05.304Z","comments":true,"path":"2017/06/15/JavaScript笔试面试题收集（四）/","link":"","permalink":"https://github.com/ChangerHe/2017/06/15/JavaScript笔试面试题收集（四）/","excerpt":"","text":"本系列主要在于对自己的日常学习的内容做一个归纳整理,同时分享一些平时遇到的一些比较好的面试题. 通过对笔试面试题的学习,强化自己的所学知识面. 关于形参的传参问题123(function(foo)&#123; return typeof foo.foo.bar; &#125;)(&#123; foo:&#123; bar: 1 &#125; &#125;) 答案: number解析: 其实这题考了我们闭包以及形参传参的问题,首先,我们将整体看成一个自执行函数,函数的变量是{ foo:{ bar: 1 } },那么我们可以把这一题简化一下:(当然,这个对象并不是存在于全局作用域的,我们只是把它拆开,做个比喻) 1234var baz = &#123; foo:&#123; bar: 1 &#125; &#125;(function(foo)&#123; return typeof foo.foo.bar;&#125;&#125;)(baz) 那么现在就很明显了,其实就是把baz作为参数传递到这个自执行函数中,理解了这第一步,那么我们要先了解一下”左值”的概念,就是当我们遇到foo.foo.bar这一串的时候,可能很多同学很疑惑,怎么传了两次参数,其实两次参数的作用是不同的,执行这段代码,那么会先查找左边的值,并传入这个参数. 那么我们再简化一下这一题 1234var baz = &#123; foo:&#123; bar: 1 &#125; &#125;(function(baz)&#123; return typeof baz.foo.bar;&#125;&#125;)(baz) 到这里,结果就很明显了,最后返回值就是 1typeof &#123; foo:&#123; bar: 1 &#125; &#125;.foo.bar 那么,自然结果就是number啦 关于作用域的问题12345var x = 1;if (function f()&#123;&#125;) &#123;x += typeof f;&#125;console.log(x) // 1undefined 这一题比较简单,但是考的是细节,我们需要了解function f(){}这个函数,其实在括号中,它的作用域就仅仅是在括号中了,但是平常我们不能这样做,因为这是不符合ES语法规范的. 关于闭包的问题1234567;(function(x)&#123; console.log(x) // 1 console.log(delete x) // false console.log(x) // 1 return x console.log(x) // 1&#125;)(1) 这一题主要是考察我们对闭包中形参和实参的处理问题. 这里给出一些个人理解,不一定正确: 首先,我们要明白,其实形参在其函数内,也是有一个在局部作用域中的函数定义的操作的.也就是隐式地声明了这个形参,然后才把这个形参进行赋值 12345678;(function(x)&#123; var x // 这里是打了个比方 x = 1 // 这里是打了个比方 console.log(delete x) ; console.log(x) return x console.log(x)&#125;)(1) 对于delete操作符,我们知道,如果成功删除,则会返回true,不成功则返回false. 同时,当我们使用var定义的变量,是无法使用delete操作符进行删除的 123var aa = 1delete a // false 关于闭包的参数问题123;(function f(f)&#123; return typeof f(); // number&#125;)(function()&#123; return 1; &#125;); 这一题还是关于自执行函数的传参,乍看可能有点懵逼,但是实际很简单,我们把这个自执行函数中打印出一个东西,你就明白了 1234;(function f(f)&#123; console.log(f) // function()&#123; return 1; &#125; return typeof f(); // number&#125;)(function()&#123; return 1; &#125;); 传进去的f就是一个函数,而在进行判断的时候是用的 typeof f() 我们会发现这个时候f已经被执行了,执行自然就会返回结果1,对1 进行类型判断,自然就是number了. 关于函数闭包的执行问题1234567891011function test() &#123; var i = 0; var f1 = function() &#123; return ++i &#125; return f1&#125;var fn1 = test();var fn2 = test();console.log(fn1 == fn2) // falseconsole.log(fn1() + fn2() + fn1() + fn2()) // 6 fn1和fn2其实都是对test中返回值的引用,打印这两个值,都是一个函数,也就是f1 但是,fn1和fn2都是对test()函数值的浅拷贝,因此二者并不相等,返回false fn1和fn2是两个完全不同的引用,引用的对象都是f1,所以我们每执行一次,i就会加一. 所以fn1执行一次,就会加一,fn1第一次是1,第二次执行是2,所以.fn1和fn2都执行两次,值就是6了","categories":[{"name":"JavaScript笔试面试题","slug":"JavaScript笔试面试题","permalink":"https://github.com/ChangerHe/categories/JavaScript笔试面试题/"}],"tags":[{"name":"JavaScript笔试面试题","slug":"JavaScript笔试面试题","permalink":"https://github.com/ChangerHe/tags/JavaScript笔试面试题/"}]},{"title":"JavaScript笔试面试题收集（五）","slug":"JavaScript笔试面试题收集（五）","date":"2017-06-15T13:34:18.000Z","updated":"2017-09-14T14:38:54.465Z","comments":true,"path":"2017/06/15/JavaScript笔试面试题收集（五）/","link":"","permalink":"https://github.com/ChangerHe/2017/06/15/JavaScript笔试面试题收集（五）/","excerpt":"","text":"本系列主要在于对自己的日常学习的内容做一个归纳整理,同时分享一些平时遇到的一些比较好的面试题. 通过对笔试面试题的学习,强化自己的所学知识面. 函数作用域的变量提升问题1234567var tmp = new Date()function f() &#123; console.log(tmp) // undefined if(false) &#123; var tmp = &apos;Hello World&apos; &#125;&#125; 此题涉及到了函数作用域的变量提升问题. 因为函数是没有块级作用域的,只有函数作用域 所以if判断即使为空,编译器预编译的阶段其内部变量声明也会提升到函数作用域的最顶端. 这个时候因为有了tmp的声明,所以tmp就不会往外面的作用域找值了,会直接返回一个undefined. let的作用域问题12345678function f1() &#123; let n = 5; if(true) &#123; let n = 10; &#125; console.log(n) // 5&#125;f1() let是es6成为国际标准的声明方式,由let声明的变量是可以有块级作用域的,所以即使我们使用了if判断语句,其里面的变量也是外面无法访问到的. 另外,es6还支持块级作用域的任意嵌套 1234567891011&#123; &#123; &#123; let a = 1; &#123; console.log(a) // 报错, a is not defined let a = 2; &#125; &#125; &#125;&#125; 以上的写法是没有错误的.还有一点要注意的是,因为不同的块级作用域是不同的,所以可以同时定义相同的变量","categories":[{"name":"JavaScript笔试面试题","slug":"JavaScript笔试面试题","permalink":"https://github.com/ChangerHe/categories/JavaScript笔试面试题/"}],"tags":[{"name":"JavaScript笔试面试题","slug":"JavaScript笔试面试题","permalink":"https://github.com/ChangerHe/tags/JavaScript笔试面试题/"}]},{"title":"JavaScript高级程序设计复习笔记（二）","slug":"JavaScript高级程序设计复习笔记（二）","date":"2017-06-15T12:53:14.000Z","updated":"2017-09-14T14:35:18.129Z","comments":true,"path":"2017/06/15/JavaScript高级程序设计复习笔记（二）/","link":"","permalink":"https://github.com/ChangerHe/2017/06/15/JavaScript高级程序设计复习笔记（二）/","excerpt":"","text":"Array类型的数组数量问题12var ar = [,,,];console.log(arr.length); //3（最后一个逗号后面不计数） 小技巧，利用length在数组的末尾添加新项12var colors = [&quot;red&quot;,&quot;blue&quot;];colors[color.length] = &quot;black&quot;; join()方法用于给数组提供分隔符以构建字符串123var colors = [&quot;red&quot;,&quot;green&quot;];console.log(colors.join(&quot;||&quot;));//输出 red||green，当直接调用join()时，使用默认的“，”分隔。 栈方法（LIFO):后进先出；队列方法(FIFO):先进先出方法类比： 方法名称 方法作用 push() 从数组后方依次添加 unshift() 从数组前方依次添加 pop() 从数组后方删除最后一个，并返回被删除值 shift() 从数组前删除第一个，并返回第一个被删除的值 重排序方法123var values = [0,1,2,10,15];values.sort();console.log(values); //0,1,10,15,2 原因：排序时sort将所有数组值均转化为字符串值再拍讯。解决方法：新建一个compare()方法进行比较12345678910111213function compare(value1,value2)&#123; if(value1 &lt; value2)&#123; return -1; &#125; else if (value1 &gt; value2)&#123; return 1; &#125; else &#123; return 0; &#125; &#125;var values = [0,1,5,10,15];values.sort(compare);console.log(values); //0,1,5,10,15 操作方法concat():链接两数组，若不传递参数，则只复制一份，不会额外向原数组增加内容。slice():复制当前数组，参数为开始和结束位置。12345var arr = [1,2,3,4,5];var arr1 = arr.slice(1);console.log(arr1); //2,3,4,5var arr2 = arr.slice(1,4);console.log(arr2); //2,3,4 注：当slice传参为负时，则要加上数组长度，以得到正确结果。splice()：有删除，插入，替换三个作用 删除：splice（要删除的第一项，删除的项数）； 插入：splice（起始位置，0，要插入的项）； 替换：splice（起始位置，要删除的项，要替换的项）； 迭代方法every():为数组每一次运行给定函数，每一项为true，则返回true。 fliter():为数组的每一项执行给定函数，返回true项组成的数组。 forEach():每一项执行函数，无返回值。 map():为每一项执行函数，返回每次调用结果组成的数组。 some():为每一项执行函数，任意项返回true，则返回true。 归并方法reduce():迭代数组所有项，构建一个最终返回值。 reduceRight():迭代数组所有项，从最后一个数开始。 函数声明提升解析器会在代码执行前进行一个函数声明提升的过程，读取并将函数声明添加到执行环境中。12345678console.log(num1(1,2)); //3console.log(num2(1,2)); //报错function num1(m , n)&#123; return m + n;&#125;num2 = function(m , n)&#123; return m + n;&#125; 注：要访问函数的指针而不执行函数，则需要在调用时去掉函数的圆括号进行调用。 使用arguments.callee()消除紧密耦合12345678//这是一个普通的递归函数function factioral(num)&#123; if(num &lt;= 1)&#123; return 1; &#125; else &#123; return num*arguments.callee(num - 1); &#125;&#125; 函数的prototype属性对于所有属性，prototype属性时保存他们的所有实例方法的真正所在，prototype属性包含两个非继承来的方法：apply()和call()。123456789101112131415function sum(num1,num2)&#123; return num1 + num2;&#125;function callSum1(num1,num2)&#123; return sum.apply(this.arguments); //传入arguments对象&#125;function callSum2(num1,num2)&#123; return sum.apply(this,[num1,num2]); //传入数组&#125;function callSum3(num1,num2)&#123; return sum.call(this,num1,num2);&#125;console.log(callSum1(10,10)); //20console.log(callSum2(10,10)); //20console.log(callSum3(10,10)); //20 call和apply的作用相同，当包含函数中接受数组时，apply更加合适。apply和call的最大用处，是可扩充函数赖以执行的作用域7.12345678window.color = &quot;red&quot;;var o = &#123;color : &quot;blue&quot;&#125;;function sayColor()&#123; alert(this.color);&#125;sayColor(); //redsayColor(o); //bluesayColor(window); //red 基本包装类基本包装类的自用创建的引用类型实例，会在代码执行后立即销毁。123var s1 = &quot;some test&quot;;s1.color = &quot;red&quot;;colsole.log(s1.color); //undefined 注：直接使用转型函数，则返回相应结果。使用构造函数，则返回相应函数的实例。12345var value = &quot;25&quot;;var number = Number(value); //使用转型函数console.log(typeof number); //numbervar obj = new Number(value); //使用构造函数console.log(typeof obj); //Object 注：new会创造一个object对象，new Boolean(false)可判定为true。 数值类型的转换.toFixed(n):表示转换为几位小数的值。.toExponential(n):表示转换为几位指数值.toPreoision(n):表示转换为n位最合适的数.charAt():输出当前字符串的第n位字符（从0开始）.charCodeAt():输出当前字符串的第n位字符的ASCII码.trim():删除前缀和后缀的空格，并返回结果.toLowerCase():转换为小写.toUpperCase():转换为大写.match():查找字符串相匹配的位置（search()）的作用相同.replace():传递两个参数，用后面的参数替换前面的参数.localeCompare():比较，返回-1,0,1的其中一种.fromCharCode():接收字符编码，转换为字符串.eval():相当于一个独立解析器，在其中创建任何变量或函数都不会被提升 typrof()和instanceof()得到的结果不同,如下：123456var numberObject = new Number(10);var numberValue = 10;console.log(typeof numberObject); //Objectconsole.log(typeof numberValue); //numberconsole.log(numberObject instanceof Number); //trueconsole.log(numberValue instanceof Number); //false 面向对象数据属性configurable:表示能否通过delete删除属性从而重新定义属性，默认为true。enumerable:表示能否通过for-in循环返回属性，默认为true。writable：表示能否修改属性值，默认为true。value：表示包含这个属性的数据值，默认为undefined。以上的属性，可以通过` Object.defineProperty()方法进行修改。但是一旦属性定义为不可配置，再调用该方法修改除writable以外的属性，都会导致错误。定义多个属性，可用Object.defineProperties()。Object.getOwnPropertyDescriptor()方法，可取得给定属性的描述符。 访问器属性访问器属性不包含属性值，但包含一对getter和setter函数，读取时调用getter，写入时调用setter。注：在某参数前加“_”表示该参数只能通过对象方法访问。 工厂模式抽象了创建具体对象的过程，用函数来封装以特定接口创建对象的细节。1234567891011function createPerson(name,age,job)&#123; var o = new Object(); o.name = name; o.age = age; o.job = job; o.sayName = function()&#123; alert(this.name); &#125; return o;&#125;var person1 = createPerson(&quot;changer&quot;,18,&quot;Engineer&quot;); 函数createPerson()能够根据接受的参数来构建一个包含所有必要信息的person对象，可无数次调用，工厂模式虽然解决了多个相似对象的问题，却没有解决对象识别的问题。 构造函数模式123456789function Person(name,age,job)&#123; this.name = name; this.age = age; this.job = job; this.sayName = function()&#123; alert(this.name); &#125;&#125;var person1 = Person(&quot;changer&quot;,&quot;18,&quot;Engineer&quot;); 构造函数始终都应以一个大写字母开头，非构造函数应以小写字母开头。构造函数的实例都有constructor()属性，该属性指向Person。构造函数的缺点：每个方法都要在每个实例上重新创建一遍，因此可将函数定义转移到函数外面以解决问题：123456789function Person(name,age,job)&#123; this.name = name; this.age = age; this.job = job;&#125;function sayName()&#123; alert(this.name);&#125;var person1 = Person(&quot;changer&quot;,&quot;18,&quot;Engineer&quot;); 以上做法解决了两个函数做同一件事的问题，但是在全局作用域中定义的函数实际上只能被某个对象调用，这让全局作用域名不副实，如果要定义多个方法，全部作为全局变量就毫无封装性可言了。 原型模式注：当原型中有某属性而且实例中也有该属性时，原型中的该属性值就用不到了，也无法被检测出来。123456789101112function Person()&#123;&#125;Person.prototype = &#123; name : &quot;Nicholas&quot;, age : 29, job : &quot;Software Engineer&quot;, sayName : function()&#123; alert(this.name); &#125;&#125;var friend = new Person();alert(friend instanceof Person); //truealert(friend.constructor == Person); //false 以上写法完全重写了默认的prototype对象，因此constructor属性也就变成了新对象的constructor属性，指向Object构造函数。在浏览器内核兼容ES5的情况下，可在下面增加：1234Object.defineProperty(Person.prototype,&quot;constructor&quot;,&#123; enumerable : false, value : Person&#125;) 该写法改进了在Person.prototype中设置导致enumerable属性被设置为true的问题。但是原型对象还存在问题：省略了构造函数传递初始化参数这一操作，会使所有实例在默认情况下取得相同值。 混成模式组合使用了构造函数模式和原型模式，构造函数模式用于定义实例属性，原型模式用于定义方法和共享的属性。12345678910111213function Person(name,age,job)&#123; this.name = name; this.age = age; this.job = job; this.friends = [&quot;aa&quot;,&quot;bb&quot;];&#125;Person.prototype = &#123; constructor : Person; sayName : function()&#123; alert(this.name); &#125;&#125;var person1 = new Person(&quot;changer&quot;,18,&quot;worker&quot;); 继承通过原型链实现继承时，不能使用对象字面量创建原型方法，这样做会重写原型链。123456789101112131415161718192021function SuperType()&#123; this.property = true;&#125;SuperType.prototype.getSuperValue = function()&#123; return this.property;&#125;function SubType()&#123; this.property = false;&#125;SubType.prototype = new SuperType;//为原型使用字面量添加新方法，会使之前的方法无效SubType.prototype = &#123; getSubValue : function()&#123; return this.subproperty; &#125; SomeOtherMeshod :funcion()&#123; return false; &#125;&#125;var instance = new SubType();alert(instance.gerSuperValue()); //错误，找不到该方法 原型链的问题：原型链上所有属性都被共享，原型链上的数据可由原型push进行增加。创建子类型的实例时，无法向超类型的构造函数中传递参数。 借用构造函数在子类型构造函数的内部调用超类型构造函数1234567891011function SuperType()&#123; this.colors = [&quot;red&quot;,&quot;blue&quot;,&quot;green&quot;];&#125;function SubType()&#123; SuperType.call(this);&#125;var instance1 = new SubType();instance1.colors.push(&quot;black&quot;);console.log(instance1,colors); //red,blue,green,blackvar instance2 = new SubType();console.log(instance2.colors); //red,blue,green 由此可见，因为call()方法创造了一个新的SuperType的作用域，使得两个实例在不同的作用域中进行，从而产生了不同的colors结果。","categories":[{"name":"JavaScript 学习笔记","slug":"JavaScript-学习笔记","permalink":"https://github.com/ChangerHe/categories/JavaScript-学习笔记/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://github.com/ChangerHe/tags/JavaScript/"}]},{"title":"JavaScript高级程序设计复习笔记（一）","slug":"JavaScript高级程序设计复习笔记（一）","date":"2017-06-15T12:31:19.000Z","updated":"2017-09-14T14:36:22.803Z","comments":true,"path":"2017/06/15/JavaScript高级程序设计复习笔记（一）/","link":"","permalink":"https://github.com/ChangerHe/2017/06/15/JavaScript高级程序设计复习笔记（一）/","excerpt":"","text":"今天重新看了一遍JS高程的第一到四章，查漏补缺记录了一些容易出错的地方，做笔记如下： 变量的作用域问题123456function test()&#123; message = &quot;Hi&quot;; //此时因为未进行变量声明，message默认为全局变量&#125;test(); //调用函数console.log(message); //Hi 变量未声明，且循环定义的循环变量，都是在全局的作用域中。 typeof()方法123var message;console.log(message); //undefinedconsole.log(age); //undefined 注：Null类型表示一个空对象指针，因此使用typeof检测时会返回object。（undefined派生自Null，因此二者相等）NaN与任何值都不相等，包括NaN本身 Number()方法进行数值转换123456var num3 = Number(0xa); //10var num2 = Number(011); //11（不会判定为八进制）var num1 = Number(11); //11var num6 = parseInt(011); //9(判断为八进制,ES5以上不适用，返回11)var num5 = parseInt(011,8)；//9var num4 = parseInt(&quot;AF&quot;,16);//175(转换为16进制) 按位操作(根据数值的二进制进行操作)12345678var result1 = 3 &amp; 1;console.log(result1); //1(按位与)var result2 = 1 | 3;console.log(result2); //3(按位或)var result3 = ~result2;console.log(result3); //-4(按位非，求反码)var result4 = 4 ^ 3;console.log(result4); //7(按位异或) 变量的赋值技巧1var num = num1 || num2; 当num1有值是，num被赋值为num1，否则被赋值为num2. switch操作符switch的语句中可以使用任何数据类型，这在其他的很多语言中是没有的，且switch支持表达式。注：switch使用的是全等操作符，因此“10”和10 是不相等的。 arguments[]对象arguments[]对象可在函数调用时使用，arguments[0]表示第一个参数，arguments[1]表示第二个参数，以此类推。12345function anyArgs()&#123; console.log(arguments.length);&#125;anyArgs(&quot;string&quot;,1); //2anyArgs(); //0 JS方法不存在重载，因此不可同时var两个相同函数名的函数基本类型和引用类型的变量赋值基本类型：相当于在堆中创建了一个新空间，并在该空间中为新变量赋予相同的值。1234var num1 = 5;var num2 = num1;num1 = 4;console.log(num2); //5 引用类型：在堆中的引用空间是不变的，新的变量值与老的变量值指向同一个堆空间。1234var obj1 = new Object();var obj2 = new Object();obj1.name = &quot;Changer&quot;;console.log(obj2.name); //Changer 传参问题向参数传递基本类型值时，被传递的值会被复制给一个局部变量，其本身的值及属性不会改变。12345678var num1 = 1;function count(num)&#123; num++; return num;&#125;count(num1);cinsole.log(num1); //1console.log(count(num1)); //2 当给引用类型传参时，引用类型变量传递到函数中会复制到变量中，在函数内部，变量和引用类型常量实际上引用的是同一个对象，因此在函数内部为常量添加属性后，在外也可调用。（这句话，我有点儿没看懂）123456789101112131415function setName(obj)&#123; obj.name = &quot;Nicholas&quot;;&#125;var person = new Object();setName(person);console.log(person.name); //Nicholas//另有一例，用于说明局部变量的传参问题function setName(obj)&#123; obj.name = &quot;Nicholas&quot;; obj = new Object(); obj.name = &quot;Greg&quot;;&#125;setName(person);console.log(person.name); //Nicholas//原因：局部变量作用域仅在函数中，使用后即被销毁。 延长作用域链1234567function buildUrl()&#123; var qs = &quot;?debug=true&quot;; with(location)&#123; var url = href + qs; &#125; return url;&#125; 此函数有效，原因（个人认为）S函数无块级作用域，因此可在with外调用。 JS的垃圾回收机制标记清除当变量进入环境时，就将这个变量标记为“进入环境”状态，当变量离开环境时，则将其标记为“离开环境”状态，它会去掉环境中的变量及被环境中变量引用的变量的标记。大部分浏览器采用此策略。 引用计数跟踪记录每个值被引用的次数，当声明了一个变量并将一个引用类型值赋值给该变量时，该值的引用次数则为1，当再次被引用时加一，相反，当引用的变量取消引用时，减一，减为0后将被回收。但是该方法存在一个很严重的性能问题：123456function problem()&#123; var objectA = new Object(); var objectB = new Object(); objectA.otherObject = objectB; objectB.anotherObject = objectA;&#125; 运行上例时，其引用次数将永远不为0，若此函数被大量调用，则其垃圾将永远不会回收。解决方案（这也是采用标记清除方法的垃圾回收最佳方案）：当不需要使用该变量时，为其设置值为null。12objectA.otherObject = null;objectB.anotherObject = null; 另：在IE中，可食用window.CollectGarbage()方法立即执行垃圾回收。","categories":[{"name":"JavaScript 学习笔记","slug":"JavaScript-学习笔记","permalink":"https://github.com/ChangerHe/categories/JavaScript-学习笔记/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://github.com/ChangerHe/tags/JavaScript/"}]},{"title":"JavaScript高级程序设计复习笔记（三）","slug":"JavaScript高级程序设计复习笔记（三）","date":"2017-06-15T12:20:09.000Z","updated":"2017-09-14T14:36:26.737Z","comments":true,"path":"2017/06/15/JavaScript高级程序设计复习笔记（三）/","link":"","permalink":"https://github.com/ChangerHe/2017/06/15/JavaScript高级程序设计复习笔记（三）/","excerpt":"","text":"昨天看了一遍javascript的面向对象，感觉javascript的面向对象比java难懂很多啊，主要还是原型链继承这块的东西。本篇内容主要讲在学习javascript中很容易搞不清楚的call()方法和apply()方法。 apply和call的区别在哪里apply:方法能劫持另外一个对象的方法，继承另外一个对象的属性.Function.apply(obj,args)方法能接收两个参数obj：这个对象将代替Function类里this对象args：这个是数组，它将作为参数传给Function（args–&gt;arguments）call:和apply的意思一样,只不过是参数列表不一样.Function.call(obj,[param1[,param2[,…[,paramN]]]])obj：这个对象将代替Function类里this对象params：这个是一个参数列表12345678910111213141516/*定义一个人类*/ function Person(name,age) &#123; this.name=name; this.age=age; &#125; /*定义一个学生类*/ functionStudent(name,age,grade) &#123; Person.apply(this,arguments); this.grade=grade; &#125; //创建一个学生类 var student=new Student(&quot;zhangsan&quot;,21,&quot;一年级&quot;); //测试 alert(&quot;name:&quot;+student.name+&quot;\\n&quot;+&quot;age:&quot;+student.age+&quot;\\n&quot;+&quot;grade:&quot;+student.grade); 大家可以看到测试结果name:zhangsan age:21 grade:一年级学生类里面我没有给name和age属性赋值啊,为什么又存在这两个属性的值呢,这个就是apply的神奇之处.分析: Person.apply(this,arguments);this:在创建对象在这个时候代表的是studentarguments:是一个数组,也就是[“zhangsan”,”21”,”一年级”];也就是通俗一点讲就是:用student去执行Person这个类里面的内容,在Person这个类里面存在this.name等之类的语句,这样就将属性创建到了student对象里面。 什么情况下用apply,什么情况下用call在给对象参数的情况下,如果参数的形式是数组的时候,比如apply示例里面传递了参数arguments,这个参数是数组类型,并且在调用Person的时候参数的列表是对应一致的(也就是Person和Student的参数列表前两位是一致的) 就可以采用 apply , 如果我的Person的参数列表是这样的(age,name),而Student的参数列表是(name,age,grade),这样就可以用call来实现了,也就是直接指定参数列表对应值的位置(Person.call(this,age,name,grade)); Function.apply()在提升程序性能方面的技巧我们先从 Math.max() 函数说起， Math.max后面可以接任意个参数，最后返回所有参数中的最大值。12alert(Math.max(5,8)) //8alert(Math.max(5,7,9,3,1,6)) //9 但是在很多情况下，我们需要找出数组中最大的元素。12var arr=[5,7,9,1]alert(Math.max(arr)) 这样却是不行的。一定要这样写1234567function getMax(arr)&#123; var arrLen=arr.length; for(var i=0,ret=arr[0];i&lt;arrLen;i++)&#123; ret=Math.max(ret,arr[i]); &#125; return ret;&#125; 这样写麻烦而且低效。如果用 apply呢，看代码：123function getMax2(arr)&#123; return Math.max.apply(null,arr)&#125; 两段代码达到了同样的目的，但是getMax2却优雅，高效，简洁得多。 看性能测试:getMax性能测试1234567891011121314151617181920212223242526272829303132333435&lt;script&gt;var myArr=new Array()function fillRnd(arrLen)&#123; //填入 arrLen个1-10的随机数字到数组 for(var i=0,arr=[];i&lt;arrLen;i++)&#123; arr[i]=Math.ceil(Math.random()*10) &#125; return arr&#125;function getMax(arr)&#123; var arrLen=arr.length; for(var i=0,ret=arr[0];i&lt;arrLen;i++)&#123; ret=Math.max(ret,arr[i]); &#125; return ret;&#125;function getMax2(arr)&#123; return Math.max.apply(null,arr)&#125;myArr=fillRnd(20*10000) //生成20万个随机数填到数组var t1=new Date()var max1=getMax(myArr)var t2=new Date()var max2=getMax2(myArr)var t3=new Date()if (max1!==max2) alert(&quot;error&quot;)alert([t3-t2,t2-t1]) //在我机器上 96,464 .不同的机器,结果可能有差异&lt;/script&gt; 通过20万个数据的比较， getMax2 时间为 96ms 而 getmax时间为464。 两者相差5倍 再比如数组的push方法。var arr1=[1,3,4];var arr2=[3,4,5];如果我们要把 arr2展开，然后一个一个追加到 arr1中去，最后让 arr1=[1,3,4,3,4,5]arr1.push(arr2) 显然是不行的。 因为这样做会得到 [1,3,4, [3,4,5] ] 我们只能用一个循环去一个一个的push当然也可以用 arr1.concat(arr2) 但是concat方法并不改变 arr1本身自从有了 Apply ,事情就变得如此简单1Array.prototype.push.apply(arr1,arr2)","categories":[{"name":"JavaScript 学习笔记","slug":"JavaScript-学习笔记","permalink":"https://github.com/ChangerHe/categories/JavaScript-学习笔记/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://github.com/ChangerHe/tags/JavaScript/"}]},{"title":"SASS学习进阶","slug":"SASS学习进阶","date":"2017-06-15T11:37:41.000Z","updated":"2017-09-14T14:35:40.658Z","comments":true,"path":"2017/06/15/SASS学习进阶/","link":"","permalink":"https://github.com/ChangerHe/2017/06/15/SASS学习进阶/","excerpt":"","text":"sass学习进阶@if语句@if是一个SassScript，它可以根据条件来处理样式快，如果条件为true则返回一个样式块，反之false返回另一个样式块。在sass中除了@if单独使用以外，还可以配合@else if 和@else 一起使用。12345678910111213141516@mixin blockOrHidden($boolean: true)&#123; @if $boolean&#123; @debug &quot;$boolean is #&#123;$boolean&#125;&quot;; //@debug指令用于调试 display: block; &#125; @else &#123; @debug &quot;$boolean is #&#123;$boolean&#125;&quot;; //@debug指令用于调试 display: none; &#125;&#125;.block &#123; @include blockOrHidden;&#125;.hidden &#123; @include blockOrHidden(false);&#125; 编译出的css为123456.block &#123; display: block;&#125;.hidden &#123; display: none;&#125; for循环在制作网格系统的时候，我们都需要使用到.col1~.col12这样的类名，在css中需要一个个去写，但是在sass 中可以很容易地使用@for循环来完成。for循环有两种实现方式1234@for $i from &lt;start&gt; through &lt;end&gt; //$i表示变量 start表示起始值 end表示结束值@for $i form &lt;start&gt; to &lt;end&gt; //二者区别是，关键字through表示包括end这个数，而to表示不包括end这个数 @for循环在网格系统生成每个格子的class代码1234567891011121314$grid-prefix: span;$grid-width: 60px;$grid-gutter: 20px;%grid &#123; float: left; margin-left: $grid-gutter /2; margin-right: $grid-gutter /2;&#125;@for $i form 1 through 12 &#123; .#&#123;$grid-prefix&#125;#&#123;$i&#125;&#123; width: $grid-width * $i + $grid-gutter * ($i - 1); @extend %grid; &#125;&#125; 编译出的css为1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253.span1, .span2, .span3, .span4, .span5, .span6, .span7, .span8, .span9, .span10, .span11, .span12 &#123; float: left; margin-left: 10px; margin-right: 10px;&#125;.span1 &#123; width: 60px;&#125;.span2 &#123; width: 140px;&#125;.span3 &#123; width: 220px;&#125;.span4 &#123; width: 300px;&#125;.span5 &#123; width: 380px;&#125;.span6 &#123; width: 460px;&#125;.span7 &#123; width: 540px;&#125;.span8 &#123; width: 620px;&#125;.span9 &#123; width: 700px;&#125;.span10 &#123; width: 780px;&#125;.span11 &#123; width: 860px;&#125;.span12 &#123; width: 940px;&#125; 将上面的实例做一些修改，将@for through方式换成@for to：：123456@for $i from 1 to 13 &#123; .#&#123;$grid-prefix&#125;#&#123;$i&#125;&#123; width: $grid-width * $i + $grid-gutter * ($i - 1); @extend %grid; &#125;&#125; @while循环@while指令也需要SassScript表达式，并且会生成不同的代码块，直到表达式值为false时停止循环。12345678$types: 4;$type-width: 20px;@while $types &gt; 0&#123; //等价于while( types = 4 , types &gt; 0); .while-#&#123;$types&#125;&#123; //等价于.while-types&#123; width: $types-width + $types; //等价于width： 20px - types； &#125; $types: $types - 1; //等价于 4--；&#125; @each循环@each循环就是去遍历一个列表，然后从列表中取出对应的值。@each命令的形式：1@each $var in &lt;list&gt; $var 是一个变量名，list是一个列表，用于进行引用。12345678910111213141516171819202122$list: adam john wynn mason kuroir; //列出列表，供下面进行引用@mixin author-images &#123; @each $author in $list &#123; .photo-#&#123;$author&#125;&#123; background: url(&quot;images/avatars/#&#123;$author&#125;.png&quot;) no-repeat; &#125; &#125;&#125;.author-bio &#123; @include author-images;&#125;//编译出的css为.author-bio .photo-adam &#123; background: url(&quot;/images/avatars/adam.png&quot;) no-repeat; &#125;.author-bio .photo-john &#123; background: url(&quot;/images/avatars/john.png&quot;) no-repeat; &#125;.author-bio .photo-wynn &#123; background: url(&quot;/images/avatars/wynn.png&quot;) no-repeat; &#125;.author-bio .photo-mason &#123; background: url(&quot;/images/avatars/mason.png&quot;) no-repeat; &#125;.author-bio .photo-kuroir &#123; background: url(&quot;/images/avatars/kuroir.png&quot;) no-repeat; &#125; sass函数字符串函数sass的字符串函数主要包括两个1234unquote($string); //删除字符串中的引号，如果字符串中没有引号，将返回原始字符串。注：unquote()函数只能删除字符串最前和最后的引号，无法删除字符串中间的引号。quote($string); //给字符串添加引号，如果字符串中间有引号或空格时，需要用单引号或者双引号括起，否则编译时会报错。 字符串函数To-upper-case()和To-lower-case()12To-upper-case():将字符串的小写字母转换成大写字母To-lower-case():将字符串的啊写字母转换成小写字母 数字函数12345678percentage($value)：将一个不带单位的数转换成百分比值；round($value)：将数值四舍五入，转换成一个最接近的整数； 0.4999视为0ceil($value)：将大于自己的小数转换成下一位整数； 0.0001视为1floor($value)：将一个数去除他的小数部分； 0.0001视为0abs($value)：返回一个数的绝对值； min($numbers…)：找出几个数值之间的最小值；max($numbers…)：找出几个数值之间的最大值；random(): 获取随机数 列表函数列表函数主要包括一些对列表参数的函数使用，主要包括以下几种：123456length($list)：返回一个列表的长度值； //括号内的值算一个nth($list, $n)：返回一个列表中指定的某个标签值，$n表示第几个join($list1, $list2, [$separator])：将两个列给连接在一起，变成一个列表；append($list1, $val, [$separator])：将某个值放在列表的最后；zip($lists…)：将几个列表结合成一个多维的列表；index($list, $value)：返回一个值在列表中的位置值。以1开始 Introspection函数Introspection函数包括了几个判断型函数：1234type-of($value)：返回一个值的类型unit($number)：返回一个值的单位unitless($number)：判断一个值是否带有单位comparable($number-1, $number-2)：判断两个值是否可以做加、减和合并 sass Maps函数借助于map功能，为同一量下，多个有名字的变量进行处理。1234567map-get($map,$key)：根据给定的 key 值，返回 map 中相关的值。map-merge($map1,$map2)：将两个 map 合并成一个新的 map。map-remove($map,$key)：从 map 中删除一个 key，返回一个新 map。map-keys($map)：返回 map 中所有的 key。map-values($map)：返回 map 中所有的 value。map-has-key($map,$key)：根据给定的 key 值判断 map 是否有对应的 value 值，如果有返回 true，否则返回 false。keywords($args)：返回一个函数的参数，这个参数可以动态的设置 key 和 value。 sass的@规则sass支持所有css3的@规则，以及一些sass专属的规则，也被成为指令。这些规则在sass 中具有不同的功效。 @import规则sass扩展了css的@import规则，使其能够引入scss和sass文件。所有引入的scss文件和sass文件都会被合并输出一个单一的css文件。被导入的文件中所定义的变量或mixins都可以在主文件中使用。sass会在当前目录下寻找其他sass文件，也可以通过:load_paths选项或在命令行中使用–load-path 选项来制定额外的搜索目录。@import根据文件名引入。默认情况下，它会寻找sass文件并直接引入，但是在少数几种情况下，它会被编译成css的@import规则：1234如果文件的扩展名是 .css。如果文件名以 http:// 开头。如果文件名是 url()。如果 @import 包含了任何媒体查询（media queries）。 如果上述情况都没有出现，且扩展名是.sass或者是.scss，则该名称的sass或scss文件就会被引入。 @media规则sass中的@media规则和css中的使用规则类似，但它有另外一个功能，可以嵌套在css规则中。有点类似于JS中的冒泡功能一样。如果使用@media指令，他将冒泡到外面。123456789101112131415.sidebar &#123; width: 300px; @media screen and (orientation: landscape)&#123; width: 500px; &#125;&#125;//编译结果.sidebar &#123; width: 300px; @media screen and (orientation: landscape)&#123; .sidebar&#123; width: 500px; &#125; &#125;&#125; @extend规则sass中的@extend是用来扩展选择器或占位符（类似于继承） @at-root规则@at-root规则从字面上解释就是跳出根元素。当你选择器嵌套多层之后，想让某个选择器跳出，此时就可以使用@at-root。12345678910111213141516171819202122232425.a &#123; color: red; .b &#123; color: orange; .c &#123; color:yellow; @at-root .d &#123; color: green; &#125; &#125; &#125;&#125;//编译之后.a &#123; color: red;&#125;.a .b&#123; color: orange;&#125;.a .b .c &#123; color:yellow;&#125;.d &#123; color: green;&#125; @debug规则@debug在sass中是用来调试的，当你在sass的源码中使用了@debug规则之后，sass代码在编译出错时，在命令终端会输出你设置的提示bug：123@debug 10em + 12em;//输出内容Line 1 DEBUG: 22em; @warn规则@warn 和@debug 类似，用来帮助我们很好的调试sass。 @error@error 和@debug、@warn 类似，用来帮助我们很好的调试sass。","categories":[{"name":"SASS 学习笔记","slug":"SASS-学习笔记","permalink":"https://github.com/ChangerHe/categories/SASS-学习笔记/"}],"tags":[{"name":"SASS","slug":"SASS","permalink":"https://github.com/ChangerHe/tags/SASS/"}]},{"title":"SASS学习笔记","slug":"SASS学习笔记","date":"2017-06-15T07:37:18.000Z","updated":"2017-09-14T14:35:35.933Z","comments":true,"path":"2017/06/15/SASS学习笔记/","link":"","permalink":"https://github.com/ChangerHe/2017/06/15/SASS学习笔记/","excerpt":"","text":"Sass语法Sass 有两种语法。 第一种被称为 SCSS (Sassy CSS)，是一个 CSS3 语法的扩充版本。也就是说，所有符合CSS3语法的样式表也都是具有相同语法意义的SCSS文件。另外，SCSS理解大多数CSShacks以及浏览器专属语法，例如IE古老的filter 语法。这种语种语法的样式表文件需要以.scss扩展名。第二种比较老的语法成为缩排语法（或者就称为 “Sass”），提供了一种更简洁的CSS书写方式。它不使用花括号，而是通过缩排的方式来表达选择符的嵌套层级，而且也不使用分号，而是用换行符来分隔属性。很多人认为这种格式比SCSS更容易阅读，书写也更快速。缩排语法具有Sass的所有特色功能,虽然有些语法上稍有差异；这些差异在{file:INDENTED_SYNTAX.md所排语法参考手册}中都有描述。使用此种语法的样式表文件需要以.sass作为扩展名。 sass的转换12345# 将 Sass 转换为 SCSS$ sass-convert style.sass style.scss# 将 SCSS 转换为 Sass$ sass-convert style.scss style.sass Sass 有三种使用方式： 命令行工具、独立的 Ruby 模块，以及包含 Ruby on Rails 和 Merb 作为支持 Rack 的框架的插件。 所有这些方式的第一步都是安装 Sass gem：1gem install sass 如果你使用的是 Windows， 就需要先安装 Ruby。 如果要在命令行中运行 Sass ,只要输入1sass input.scss output.css 你还可以命令 Sass 监视文件的改动并更新 CSS ：1sass --watch input.scss:output.css 如果你的目录里有很多 Sass 文件，你还可以命令 Sass 监视整个目录：1sass --watch app/sass:public/stylesheets sass编译命令行编译单文件转换命令1sass style.scss style.css 单文件监听命令1sass --watch style.scss:style.css 文件夹监听命令1sass --watch sassFileDirectory:cssFileDirectory css文件转成sass/scss文件（在线转换工具css2sass）12sass-convert style.css style.sass sass-convert style.css style.scss 编译格式我们一般常用的有–style，–sourcemap，–debug-info等。1234sass --watch style.scss:style.css --style compactsass --watch style.scss:style.css --sourcemapsass --watch style.scss:style.css --style expanded --sourcemapsass --watch style.scss:style.css --debug-info –style表示解析后的css是什么格式，有四种取值分别为：nested，expanded，compact，compressed。–sourcemap表示开启sourcemap调试。开启sourcemap调试后，会生成一个后缀名为.css.map文件。–debug-info表示开启debug信息，升级到3.3.0之后因为sourcemap更高级，这个debug-info就不太用了。 sass混合宏混合宏的关键词在sass中通过@mixin关键词声明一个混合宏，那么在实际调用中，其匹配了一个关键词@include来调用声明好的混合宏。1234567@mixin border-radius&#123; //对混合宏进行声明 -webkit-border-radius: 3px; border-radius: 3px;&#125;button&#123; @include border-radius: 3px; //对声明出的混合宏进行使用关键字@include调用&#125; 此时编译出的css为12345678button&#123; -webkit-border-radius: 3px; border: 3px;&#125;## 混合宏的传参sass有一个强大的混合宏功能：传参。混合宏传参有以下几种情形：### 1.传一个不带值的参数 @mixin border-radius($radius){ -webkit-border-radius: $radius; border-radius: $radius;}1在调用是，给这个混合宏进行参数传递，即可。如，当我想传递给radius传参3px时。代码如下： .box{ @include border-radius(3px);}此时编译出的结果为：1234.box&#123; -webkit-border-radius: 3px; border-radius: 3px;&#125; 2.传一个带值的参数在sass中可以给参数带一个默认的值，在调用时，就可以直接使用此默认值进行编译，这种情况适用于比较多地方使用默认值的时候，此时可设置一个默认值。1234@mixin border-radius($radius: 3px)&#123; -webkit-border-radius: $radius; border-radius: $radius;&#125; 3.传递多个参数sass中不仅可以传递一个参数，还可传递多个参数1234567@mixin size($width,$height)&#123; width: $width; height: $height;&#125;.box-center&#123; @include size(500px,300px);&#125; sass扩展sass继承sass可以继承类中的样式代码块，在sass中是通过关键字@extend来继承已经存在的类样式块的。123456789101112131415.btn&#123; border: 1px solid #ccc; padding: 6px 10px; font-size: 14px;&#125;.btn-primary&#123; background: #f36; color: #fff; @extend: .btn;&#125;.btn-second&#123; background: orange; color: #fff; @extend .btn;&#125; 编译出的结果是精简的写法，不想之前通过@include进行编译的一样，通过@include编译出来的是没有简化写法的。12345678910111213.btn,.btn-primary,.btn-second&#123; border: 1px solid #ccc; padding: 6px 10px; font-size: 14px;&#125;.btn-primary&#123; background: #f36; color: #fff;&#125;.btn-second&#123; background: orange; color: #fff;&#125; sass占位符（%placeholder）占位符（%placeholder）声明的代码，如果不被@extend调用的话，不会产生任何代码。123456%mt5&#123; margin-top: 5px;&#125;%pt5&#123; padding-top: 5px;&#125; 以上代码若不被@extend调用，则不会产生任何代码块，但是当调用的时候，该代码块才会生效。1234.btn&#123; @extend %mt5; @extend %pt5;&#125; 此时解析出的结果为：1234.btn&#123; margin-top: 5px; padding-top: 5px;&#125; 使用混合宏，继承，占位符的方式和使用对象比较!(PIC)[http://img.mukewang.com/55263aa30001913307940364.jpg] sass插值#{}12345678910@mixin firefox-message($selector)&#123; body.firefox #&#123;$selector&#125;:before&#123; content : &quot;Hi, firefox users!&quot;; &#125;&#125;@include firefox-message(&quot;.header&quot;);//编译结果为body.forefox .header:before&#123; content: &quot;Hi,firefox users!&quot;;&#125; sass运算加法123.box&#123; width: 20px + 8in;&#125; 减法12345$full-width: 960px;$sidebar-width: 200px;.content&#123; width: $full-width - $sidebar-width;&#125; 乘法乘法只能乘以一个数字，不能乘以一个数字加上单位，否则会报错123.box&#123; width: 10px *2px; //报错“20px*px isn&apos;t a valid CSS value.”&#125; 除法除法在应用时，需要加上括号1234567.box&#123; width: (100px / 2);&#125;//编译后等价于.box&#123; width: 50px;&#125; 当使用变量或者其他运算常亮进行计算时，可以不加括号。 字符运算在sass中可以使用符号+来实现字符串的链接。123456789$content: &quot;hello&quot; + &quot; &quot; + &quot;sass!&quot;;.box: before&#123; ontent: &quot;#&#123;$content&#125;&quot;;&#125;//编译后等价于.box: before&#123; content: &quot;hello sass!&quot;;&#125;除了在变量中做字符连接运算以外，还可以直接通过加号把字符连在一起 div{ cursor: e + -resize;}//编译后等价于div{ cursor: e-resize;}```注意，如果有引号的字符串被添加了一个没有引号的字符串，结果会是一个有引号的字符串。同样的，如果一个没有引号的字符串被添加了一个有引号的字符串，结果将是一个没有引号的字符串。","categories":[{"name":"SASS 学习笔记","slug":"SASS-学习笔记","permalink":"https://github.com/ChangerHe/categories/SASS-学习笔记/"}],"tags":[{"name":"SASS","slug":"SASS","permalink":"https://github.com/ChangerHe/tags/SASS/"}]},{"title":"jQuery.extend和jQuery.fn.extend的区别","slug":"jQuery-extend和jQuery-fn-extend的区别","date":"2017-06-15T07:27:53.000Z","updated":"2017-09-14T14:38:16.909Z","comments":true,"path":"2017/06/15/jQuery-extend和jQuery-fn-extend的区别/","link":"","permalink":"https://github.com/ChangerHe/2017/06/15/jQuery-extend和jQuery-fn-extend的区别/","excerpt":"","text":"在jQuery的API手册中,jQuery.extend和jQuery.fn.extend,是挂载在jQuery和jQuery.fn上的两个方法,挂载对象不同,但是jQuery的内部实现中是相同的,只是功能不太一样. 官方的解释是这样的 jQuery.extend(): Merge the contents of two or more objects together into the first object.(把两个或者更多的对象合并到第一个当中)； jQuery.fn.extend():Merge the contents of an object onto the jQuery prototype to provide new jQuery instance methods.(把对象挂载到jQuery的prototype属性，来扩展一个新的jQuery实例方法) 理解jQuery.extend我们先把jQuery看成一个类,jQuery.extend是扩展的jQuery这个类 假设我们把jQuery这个类看成是人类,能吃饭喝水能跑能跳,我们现在用extend方法给人类扩展一个能说话(speak)的技能,这样的话所有的人类,都能继承这个技能. 12345JQuery.extend(&#123; speak:function()&#123; alert(&quot;how are you!&quot;); &#125;&#125;); 那么,我们需要使用这个技能的时候,直接使用$.speak()就可以成功调用这个方法了. 这说明,$.speak变成了jQuery这个类本身的方法,现在人类都能说话了 所以,这个扩展也就是所谓的静态方法, 只跟这个类本身有关,跟你具体的实例化对象是没有关系的. 理解jQuery.fn.extend从字面理解,这个扩展的是jQuery.fn的方法,那么jQuery.fn是什么呢? 在jQuery源码的开通部分,有这样的一段代码 12345jQuery.fn = jQuery.prototype = &#123; init:funtion(selector,context)&#123; //..... &#125;&#125; 所以显而易见,jQuery,fn其实扩展的就是jQuery这个对象原型上面的方法. 也就是说,这个方法必须使用在jQuery实例化的对象上,就不能直接使用jQuery.xxx() 这样调用了,而是必须指明实例化的对象,然后在对象上面调用. 1$(&apos;person1&apos;).speak() 两者区别的总结两者调用方式不同：jQuery.extend(),一般由传入的全局函数来调用，主要是用来拓展个全局函数，如$.init()，$.ajax(); Query.fn.extend(),一般由具体的实例对象来调用，可以用来拓展个选择器，例如$.fn.each(); 两者的主要功能作用不同： jQuery.extend(object); 为扩展jQuery类本身，为自身添加新的方法。 jQuery.fn.extend(object);给jQuery对象添加方法 大部分插件都是用jQuery.fn.extend()JQuery的extend扩展方法：Jquery的扩展方法原型是:1extend(dest,src1,src2,src3...); 作用是将src1 src2 … 合并到dest上,然后返回,返回值是合并之后的dest,也就是说这个时候dest是被修改了的. 如果我们不想修改dest的值,可以这样 1extend([],src1,src2,src3...); 这样的话,就不会有值会被改变了 jQuery中extend的内部实现jQuery的内部多次使用了其自己定义的merge方法,作用就是将后面的值往前面的值身上加,这种方法在extend方法上得到了很好的实现.","categories":[{"name":"jQuery 学习笔记","slug":"jQuery-学习笔记","permalink":"https://github.com/ChangerHe/categories/jQuery-学习笔记/"}],"tags":[{"name":"jQuery","slug":"jQuery","permalink":"https://github.com/ChangerHe/tags/jQuery/"}]},{"title":"JavaScript深入浅出-表达式和运算符","slug":"JavaScript深入浅出-表达式和运算符","date":"2017-06-15T06:10:18.000Z","updated":"2017-09-14T14:35:46.638Z","comments":true,"path":"2017/06/15/JavaScript深入浅出-表达式和运算符/","link":"","permalink":"https://github.com/ChangerHe/2017/06/15/JavaScript深入浅出-表达式和运算符/","excerpt":"","text":"表达式是能计算出值的任何业务单元。原始表达式：常量，直接量、关键字、变量原始表达式和原始表达式可以通过运算符链接成符合表达式函数表达式：属性访问表达式：对定义好的表达式的属性进行访问调用表达式：调用函数，等堆箱创建表达式： 运算符常用于表达式之间进行运算三元运算符1var a = c ? a : b; delete运算符，删除对象。但是当定了了对象的configurable时，是无法删除的。123456var obj = &#123;&#125;&apos;Object.defineProperty(obj,&quot;x&quot;,&#123;configurable: false,value: 1&#125;);delete obj.x; //falseobj.x; //1 in 运算符12window.x = 1;&quot;x&quot; in window; //true; instanceof tyoeof运算符12&#123;&#125; instanceof Object； //truetypeof 100 === &apos;number&apos;; //true new 运算符1234567function Foo()&#123; Foo.prototype.x = 1; var obj = new Foo(); obj.x; obj.hasOwnProperty(&quot;x&quot;); //判断x是不是属于自己的对象 obj._proto_.hasOwnProperty(&quot;x&quot;); //判断是不是原型中的对象&#125; this 运算符void 运算符var 语句当使用循环时，循环使用的变量i在循环结束后仍然可以调用，即它为全局变量。12345for (var i = 0; i &lt; 5; i++) &#123; console.log(i); //0 1 2 3 4&#125;console.log(&quot;-------------&quot;) //-------------console.log(i); //5 当我们使用var a = b = 0来进行变量定义时，如果在局部变量中进行这样的定义，请注意，定义出的b = 0是全局变量。12345function() &#123; var a = b = 0; console.log(a + &quot;,&quot; + b); //0,0&#125;console.log(b); //0 try-catch 语句对方不想和你说话，并想向你抛出一段异常。```try{ try{ throw new Error(“oops”); } finally{ console.log(“finally”); }}catch(ex){ console.error(“outer”,ex.message);}","categories":[{"name":"JavaScript 学习笔记","slug":"JavaScript-学习笔记","permalink":"https://github.com/ChangerHe/categories/JavaScript-学习笔记/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://github.com/ChangerHe/tags/JavaScript/"}]},{"title":"浅谈框架模式的MVC/MVP/MVVM","slug":"浅谈框架模式的MVC-MVP-MVVM","date":"2017-06-15T04:16:09.000Z","updated":"2017-09-14T15:02:57.268Z","comments":true,"path":"2017/06/15/浅谈框架模式的MVC-MVP-MVVM/","link":"","permalink":"https://github.com/ChangerHe/2017/06/15/浅谈框架模式的MVC-MVP-MVVM/","excerpt":"","text":"框架模式不是一门写代码的学问，而是一门管理与组织代码的学问。其本质是一种软件开发的模型。与设计模式不同，设计模式是在解决一类问题时总结抽象出的公共方法，如（工厂模式、单例模式。。等等），他们与某种具体的技术栈无关。一种框架模式往往使用了多种设计模式。下面来说一下框架设计的诞生原因及演化。 第一代：脚本式设计（无架构设计）下面这样的代码，就是没有任何设计模式的产物：123456789const a = document.createElement(&quot;a&quot;);a.innerHTML = &quot;www.google.com&quot;;a.href = &quot;//www.google.com&quot;;a.style.position = &quot;absolute&quot;;a.style.top = 100;a.onclick = function()&#123; console.log(&quot;google&quot;);&#125; document.body.appendChild(a); 这种搞法虽有不少缺点，但麻雀虽小五脏俱全，所有功能一应俱全。早些年由于UI程序还处在一个懵懂期， 逻辑不算太复杂，代码量也不会太多。这样的搞法似乎也没有什么问题。 毕竟到达A B两点最短的距离就是直线，上述代码可以说是实现某功能的最短路径。 典型的例子就是 ASM (虽然汇编语言不是用来写UI的)，他们共有的缺点是 :入口单一 功能简单 不可维护。 我们来修改一下上面的逻辑：123456789101112131415161718function doCss(a) &#123; a.style.position = &quot;absolute&quot;; a.style.top = 100;&#125;function doEvent(a) &#123; a.onclick = function()&#123; alert(&quot;google&quot;); &#125;&#125;function doAttribute(a)&#123; a.innerHTML = &quot;www.google.com&quot;; a.href = &quot;//www.google.com&quot;;&#125;const a = document.createElement(&quot;a&quot;);doCss(a);doEvent(a);doAttribute(a)document.body.appendChild(a); 这里我们将一个功能拆分成了3个部分，即 外观 事件 和属性。 函数将他们重新分离成一个个独立的逻辑块，这样一定程度上达到了分离复用的目的，比如你想修改外观，就去doCss函数里去找。。。 就像有钱人追求更多的财富，权贵追求更多权利一样。 人类总在思考同一个问题， 我们能不能做得更好。。 直到有一天。。。 第二代：代码文件分离(CodeBehind)HTML是视图文件，而对应的。csS文件是他的相关逻辑处理文件 事件驱动模式下，框架帮我们完成了基本的事件类型，我们要做的是在事件下完成相关业务逻辑。12345678&lt;html&gt;&lt;head&gt; &lt;link href=&quot;style.css&quot; rel=&quot;stylesheet&quot; /&gt;&lt;/head&gt;&lt;body&gt; &lt;script src=&quot;bundle.js&quot; &gt;&lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 各文件各司其职，编写的时候分离，在运行的时候合并。这样进一步降低了功能之间的耦合度。 视图看起来非常”清爽”，对应的逻辑也被分离成一个个文件， 交由相应的开发人员处理。 如果你涉猎的技术范围很广，你会发现其实这种技术已经出现在诸多成熟的技术栈中。。。。 但是，没过多久伊甸园欢乐的笑声被下面这个需求打破。。。1234567891011`购买苹果按钮`绑定事件如下:1.int 苹果数变量 + 1;2.显示苹果数控件的值 = 苹果数变量; `购买梨按钮`绑定事件如下:1.int 梨数变量 + 1;2.显示梨数控件的值 = 梨数变量; ...`吃苹果` ...`吃梨` 这里比较困难的是 第2步 就是如果显示苹果数的控件是另一个程序员开发的黑盒， 如何修改其值? 于是程序员A 去找 程序员B 寻求是否存在对应的 get/set 方法。 程序员B说有， “有” 字还没落地， 开发买梨的程序员C 又踹门进来了，问了同样的问题， 后来才知道 开发吃苹果功能的程序员D正在路上。。。 于是程序员B 不得不把接口的详细信息写到 wiki中， 于是 程序员CDEFGHIJKMLN 都看了wiki 懂了。 完成这件事 程序员B 写wiki 花了 10分钟， 程序员CDEFGHIJKMLN 看wiki每人花 1分钟，一共团队成本 20分钟。 于是 wiki中这个 get/set 接口函数出现在了每一个被绑定的函数里。一共4个button 出现4次 ps: 这个get/set接口本质上就是一个view刷新接口 事情仍在在酝酿: 产品大爷发话了，需求改了！ 多了一个求和。 于是伪代码变成了这样:12345`购买苹果按钮`绑定事件如下:1.int 苹果数变量 + 1;2.int 总和变量 = 苹果数变量 + 梨数变量;2.显示苹果数控件的值 = 苹果数变量;3.显示总和控件的值 = 总和变量; 这次 程序员B为了人身安全，提前把 get/set 接口发布到了 wiki上。。 于是 总和控件的值 = 总和变量 这行代码出现了 4次。 产品存在的意义，就是将程序狗虐到极致:qq 于是需求改成了这样: q2 只是删了一行。 于是 4个函数中 所有相关代码都被删除。。。 共影响 4行代码。。 段子讲完了，其核心问题在于，按照事件进行的业务模块划分，有时候是不合理的，事件是用户行为的入口，但不是程序逻辑的入口。 一个button的click就可能横跨N个领域， 需要N个人来进行协作， 这部分逻辑到最后还是会耦合在一起，通过各种函数封装进行解耦，无疑是扬汤止沸，而我们需要的是釜底抽薪 M-V-C:(模型，视图，控制器)现在网上有很多关于mvc的介绍，让人纠结的是他们各不相同，而且有的根本就说的不对， 对于框架模式这东西，没有一个严格的规定说这样搞是 mvc 那样就不是。 甚至连mvc本身也有很多变种，我们只要从根源上理解这个东西就行。 我就不扒祖坟了，咱们只需要知道它已经存在了 30多年就行了。 我们思考一下 UI(图形化用户界面) 的本质: 为什么要有UI， 在计算机眼中 一切即数据，其实要是深挖这个问题，数据与操作其实都是 0 1 组成的机器码，只不过 CPU运行的时候用指定寄存器的数据当做指令罢了，也就是说 决定一个数据到底是数据还是指令 只取决于他所在的寄存器位置。(好了好了 扯远了，往回跑。。) 数据的操作是抽象的，是专业人士干的事情， 计算机为了走进千家万户， 必须提供一种傻瓜式的操作方式，于是UI诞生了。。。 用一句话解释UI就是:他是数据到图像的一种映射程序; 刚才说了它是一种映射程序，用户通过操作图像上的按钮，来达到操作数据的目的，数据被用户改变后，肯定需要从新生成映射。 Model View Controller 是干什么的:1.View: 放置视图相关的代码，原则上里面不应该有任何业务逻辑。 2.Controller: 放置视图与模型之间的映射，原则上这里应该很薄，他只放一些事件绑定相关的代码(router)，但并不实现真正的功能，他只是一个桥梁。 3.Model: 这里的model不是说 实体类， 他是主要实现逻辑的地方。 那还是上面 买水果的例子，那么在MVC下该如何设计呢: 概念 解释 view层 放置界面代码，以及一些刷新逻辑 如数据中的 0 1 转成 男 女 controller层 放置一些绑定逻辑。完成router，不实现函数体。 model层 接收view的注册，当自身数据变化时，执行view的刷新函数。 业务逻辑都在这里 他是这样一个流程: 1.创建显示苹果数量的控件。 2.将上面控件注册到model中。(设置关联的数据，–苹果数变量) 3.修改model中 苹果数变量 。 4.由于苹果数变量被修改，触发所有绑定在上面的控件(view)从新执行刷新函数。 5.显示苹果数量的控件被更新。 这样便解决了大部分界面与逻辑耦合的问题，但是它并不完美: View 和 Model 并不是完全脱离的，还是有一些逻辑耦合，因为需要根据修改后的model从新刷新view。 难免view里面沾染一点model的结构。 代码量膨胀。 不方便进行更精细的颗粒化控制。(因为view只知道 model被改了，但不知道谁改的!) model在对应多个view的时候，很难都伺候到位。于是。。。 M-V-P:(模型，视图，派发器)针对mvc的一些问题，在mvp模式下， 斩断了 view 与 model的关系， 当m 改变时，m 通知 p 去改变v， 所以v变得更纯洁(刷新逻辑被移动到了p层)， 为了保证m可以最大程度的复用 一部分业务逻辑也从 m 转移到了p所以 mvp下 p 非常厚实。 mvp中最后改变v的是p那么在 v与p 之间会有一个接口，解决怎么转换以及传值的问题。 M-V-VM:(模型，视图，抽象视图)mvvm 与 mvp 的最大区别就是它使用 数据绑定(Data Binding)、依赖属性(Dependency Property)、命令(Command)、路由事件(Routed Event) 来搞定与view层的交互， 但是这种绑定是与某种具体技术栈相关的， ViewModel从Model中抽象而来，但更贴近于业务模型， 比如你Model中某字段是 true false， ViewModel中可能就是 “黑”，”白”等 这种更贴近业务场景的描述。 ViewModel中的属性直接与某具体控件的属性相绑定。 也就是说当某具体控件发生变化，ViewModel中的 某个字段就会跟着变化，然后Model中的字段也会进一步变化。 (以上文章摘自网络)","categories":[{"name":"JavaScript框架模式","slug":"JavaScript框架模式","permalink":"https://github.com/ChangerHe/categories/JavaScript框架模式/"}],"tags":[{"name":"JavaScript框架模式","slug":"JavaScript框架模式","permalink":"https://github.com/ChangerHe/tags/JavaScript框架模式/"}]},{"title":"HTTP相关知识（一）","slug":"HTTP相关知识","date":"2017-06-15T04:16:09.000Z","updated":"2017-09-14T15:01:41.842Z","comments":true,"path":"2017/06/15/HTTP相关知识/","link":"","permalink":"https://github.com/ChangerHe/2017/06/15/HTTP相关知识/","excerpt":"","text":"URL，英文名为（Uniform Resource Locator)，统一资源定位符。统一资源定位符是对可以从互联网上得到的资源的位置和访问方法的一种简洁的表示，是互联网上标准资源的地址。互联网上的每个文件都有一个唯一的URL，它包含的信息支出文件的位置及浏览器该怎么处理它。 基本URL包含模式（或称协议），服务器名称（或IP地址），路径和文件名。1协议://授权/路径?查询 完整的，带有授权部分的普通统一资源定位符语法看上去如下：1协议://用户名:密码@子域名.域名.顶级域名:端口号/目录/文件名.文件后缀?参数=值#标志 HTTP状态码HTTP状态码现在在记录的的种类就达40多种，再加上各类拓展，数量可达六十余种。但实际上真正频繁使用的，也就14中。 状态码的不同类别 类别 原因短语 1XX Informational(信息性状态码) 接收的请求正在处理 2XX Success(成功状态码) 请求正常处理完毕 3XX Redirection(重定向状态码) 需要进行附加操作以完成请求 4XX Client Error(客户端错误状态码) 服务器无法处理请求 5XX Sever Error(服务器错误状态码) 服务器处理请求出错 1XX类状态码——正在处理中以上列表，主要表示请求的状态或者接收的请求正在处理。这个没什么可说的。 2XX类状态码——处理成功看到2XX，你就可以开心啦，2XX类状态码基本为处理成功的状态，具体情况如下： 200 OK表示从客户端发来的请求在服务器端被正常处理了。 204 No Content表示状态码代表服务器接收的请求已经成功处理，但在返回的响应报文中不含实体的主体部分。另外，也不允许返回任何实体的主体。一般只需要从客户端往服务器发送信息，而对客户端不需要发送新信息内容的情况下使用。 206 Partical Content该状态码表示客户端进行了范围请求，而服务器成功执行了这部分的GET请求。响应报文中包含由Content-Range指定范围的实体内容。3XX类状态码——重定向3XX响应结果表示浏览器需要执行某些特殊的处理以正确处理请求。 301 Moved Permanently永久性重定向，改状态码请求的资源已经被分配了新的URI，以后应使用资源现在所指的URI。还有一种情况，当你的输入路径最后忘记添加斜杠 /时，也会产生301状态码。 1http://example.com/sample 302 Found临时性重定向。该状态码表示请求的资源已经被分配了新的URI，希望用户能使用新的URI访问。和状态码301类似，但是302状态码表示的资源不是永久移动，只是临时的。 303 See Other该状态码表示由于请求对应的资源存在着另一个URI，应使用GET方法进行定向获取请求的资源。303状态码和302状态码有着相同的功能，但303状态码明确表示客户端应当次用GET方法获取资源，这点与302状态码有区别。 304 Not Modefied该状态码表示客户端发送附带条件的请求时，服务器端允许请求访问资源，但因发生请求未满足条件的情况后，直接返回304.该状态码返回时不包含任何响应的主题部分。也就是虽然304被划分在3XX系列，但是似乎和重定向没有关系，反倒和接下来介绍的4XX系列有些类似了。 307 Temporary Redirect临时重定向。该状态码与302有着类似的含义。4XX类状态码——客户端错误这也许是所有程序猿和媛们最讨厌的一个系列了，该返回表明客户端是发生错误的原因所在。 400 Bad Request该状态码表示请求报文中存在语法错误。当错误发生时，需要修改请求的内容之后再次发送。而且，浏览器会像200 ok那样子对待该状态码。 401 Unauthorized该状态码表示发送的请求需要有通过HTTP认证的认证信息。如果之前已经做过一次请求的话，则表示用户校验失败。返回含有401的响应必须包含一个适用于被请求资源的 WWW-Authenticate 首部用以质询用户信息。当用户初次接收到401，会弹出认证用的对话窗口。 403 Forbidden表明请求资源的访问被浏览器拒绝了。未获得文件系统的访问授权，访问权限出现问题，都会返回403状态码。 404 Not Found该状态码绝对是4XX系列中我们最常见的了。表示服务器上无法找到请求的资源。除此之外，也可以在服务器端拒绝请求且不想说明理由时使用。5XX类状态码——服务器错误 500 Internal Server Error该状态码表示服务器端在执行请求时发生了错误，也有可能是web应用存在的BUG或某些临时的故障。 503 Service Unavailable该状态码表示服务器暂时处于超负载或正在进行停机维护，现在无法处理处理请求。如果事先得知解除以上状况需要的时间，最好写入 Retry-After 首部字段再返回给客户端。 知识拓展：URIURI（Uniform Resource Identifier）,统一资源标识符。URI是有某个协议方案表示的资源的定位标识符。协议方案是指访问资源所使用的协议类型名称。采用HTTP协议时，协议方案就是HTTP。标准的URI协议方案有30种左右。URI用字符串标识某一互联网资源，而URL标识资源的地点，可见，URL是URI的子集。","categories":[{"name":"HTTP 相关知识","slug":"HTTP-相关知识","permalink":"https://github.com/ChangerHe/categories/HTTP-相关知识/"}],"tags":[{"name":"HTTP相关知识","slug":"HTTP相关知识","permalink":"https://github.com/ChangerHe/tags/HTTP相关知识/"}]},{"title":"JavaScipt中sort()方法的底层原理及妙用","slug":"JavaScipt中sort-方法的底层原理及妙用","date":"2017-06-15T02:16:09.000Z","updated":"2017-09-30T02:30:10.688Z","comments":true,"path":"2017/06/15/JavaScipt中sort-方法的底层原理及妙用/","link":"","permalink":"https://github.com/ChangerHe/2017/06/15/JavaScipt中sort-方法的底层原理及妙用/","excerpt":"","text":"众所周知，JavaScript中的sort()方法可对数组进行排序。平时我们使用就是简单的执行一个sort()方法，但是其实这个方法是带有参数的。语法为：arrayObject.sort(sortby);其中，参数sortby，必须为函数！这点要注意，之前试过传值的方法一直都不奏效，后面才发现，只能传递一个参数。 未传参情况下的排序当没有为该方法传参时，则默认对数组进行从大到小排序，排序的依据是数组中每个元素的首个字符的ASCII码，因此当你想要对数组[2,10,3]排序时，直接排序的结果为[10,2,3]，因为在sort()的底层，比较时会自动为数组中的值进行toString()方法的转换，比较时比较的是字符。 传参情况下的排序JS高程中介绍了传递比较函数的方法。123456var a = [10,3,12]; var line = function(a,b)&#123; return b -a; &#125; a.sort(line) console.log(a) //3,10,12 但是有个问题，这个数东西就只能针对数组额，但是如果我想要对数组对象进行排序呢？ 其实方法类似，万变不离其宗。如下： 12345678910111213 var arr = [ &#123;name: &quot;aaa&quot;, age: 0&#125;, &#123;name: &quot;bbb&quot;, age: 18&#125;, &#123;name: &quot;ccc&quot;, age: 8&#125; ];function compare(property)&#123; return function(a,b)&#123; var value1 = a[property]; //获取a的 var value2 = b[property]; return value1 - value2; &#125;&#125;console.log(arr.sort(compare(&apos;age&apos;))); 逆向排序那么问题来了，如果都是从小到大排序，那就不好玩了，能不能有办法在不使用reverse()方法的情况下，实现增加一个参数，来决定他们是从大到小排序，还是从小到大排序呢？当然问题还是有解决方案的。1234567891011121314151617181920sortBy:function(attr,rev)&#123; if(rev == undefined)&#123; rev = 1; //当未传递参数时，默认为从小到大排序，即undefined时，为1 &#125;else&#123; rev = (rev)? 1 : -1; &#125; return function(a,b)&#123; a = a[attr] b = b[attr] if(a &lt; b)&#123; return rev * -1; &#125; else if(a = b)&#123; return 0; &#125; else &#123; return 1; &#125; &#125;&#125;someArray.sort(sortBy(&quot;number&quot;,false)); 底层原理以上是研究出的部分结果，但是对sort()的底层排序机制，还是不太理解，到底是用的冒泡排序，还是堆排序，还是更牛逼的高级算法？这就不得而知了，这里引用一下segmenfault上大神们的解释：不同的浏览器，对sort()方法的实现机制是不同的。Mozilla、Firefox这两个浏览器是使用的归并排序方法。使用V8引擎，对数组长度小于等于22的用插入排序，其他的使用快速排序。webkit这个浏览器底层使用了C++库中的qsort()方法。```","categories":[{"name":"JavaScript 学习笔记","slug":"JavaScript-学习笔记","permalink":"https://github.com/ChangerHe/categories/JavaScript-学习笔记/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://github.com/ChangerHe/tags/JavaScript/"}]},{"title":"JavaScriptDOM编程艺术查漏补缺(一)","slug":"JavaScriptDOM编程艺术查漏补缺(一)","date":"2017-06-15T01:16:09.000Z","updated":"2017-10-12T11:38:28.103Z","comments":true,"path":"2017/06/15/JavaScriptDOM编程艺术查漏补缺(一)/","link":"","permalink":"https://github.com/ChangerHe/2017/06/15/JavaScriptDOM编程艺术查漏补缺(一)/","excerpt":"","text":"标识符什么是标识符 变量、函数、属性的名字、或者函数的参数 标识符的命名规则 由字母、数字、下划线_或美元符号$组成 不能以数字开头 不能使用关键字、保留字等作为标识符 变量ECMAScript的变量是松散类型，每个变量仅仅是一个用于保存值得占位符而已 松散类型： 可以用来保存任何类型的数据 变量声明 1234567891011121314//先声明，再赋值var myName; myName = \"logan\";//声明同时赋值var myName = \"logan\";//一次声明多个变量var myName = \"logan\", myAge = 24, address; 省略var声明的变量是全局变量 JavaScript的数据类型typeof 功能： 监测变量类型 语法： typeof 变量或者typeof(变量) 返回值： string/number/boolean/object/undefined/function undefinedundefined类型只有一个值，即特殊的undefined null null值表示一个空对象指针 如果定义的变量准备在将来用于保存对象，那么最好将变量初始化为null undefined值是派生自null值的，所以undefined == null的返回结果是true number表示整数和浮点数 NaN 即非数值(Not a Number)，是一个特殊的数值 任何涉及NaN的操作，都会返回NaN NaN与任何值都不相等，包括NaN本身 isNaN() 语法： isNaN(n) 参数可以是任何类型 功能： 检测参数n是否是“非数值” 返回值： boolean isNaN()对接收的参数，先尝试转换为数值，再检测是否为非数值 12isNaN(\"258\"); //falseisNaN(\"a\" + 10); //true 数值转换 有三个函数可以把非数值转换为数值 Number() 参数可以是任何类型，强制转换为数值 12345Number(\"16\"); //16typeof(Number(\"16\")); //numberNumber(\"16px\"); //NaNtypeof(Number(\"16px\")); //number parseInt() 用于把字符串转换为整数数值parseInt()会忽略字符串前的空格parseInt()会忽略前导的零parseInt()转换空字符串返回NaN parseInt()函数提供第二个参数，即转换时使用的基数（即多少进制2-36） 123456parseInt(\"28px\"); //28parseInt(\"28.5px\"); //28parseInt(\" 28px\"); //28parseInt(\"a28px\"); //NaNparseInt(\"\"); //NaNparseInt(\"1f\",16); //返回 31 (16+15) parseFloat() 用于把字符串转换为整数或者浮点数数值parseFloat()第一个小数点有效，直至遇到一个无效的浮点数字符为止parseFloat()会忽略字符串前的空格parseFloat()会忽略前导的零parseFloat()转换空字符串返回NaN 123456parseFloat(\"28px\"); //28parseFloat(\"28.5px\"); //28.5parseFloat(\"28.5.2px\"); //28.5parseFloat(\" 28px\"); //28parseFloat(\"a28px\"); //NaNparseFloat(\"\"); //NaN stringstring类型用于表示由零个或者多个16位Unicode字符组成的字符序列，即字符串，字符串可以由双引号&quot;&quot;或者单引号&#39;&#39;表示 字符串转换 toString() x.toString() 无法转换null和undefined 12345678910111213141516171819//数组var array = [\"CodePlayer\", true, 12, -5];array.toString(); // CodePlayer,true,12,-5// 日期var date = new Date();date.toString(); // Wed Sep 13 2017 22:07:48 GMT+0800 (中国标准时间)// 数字var num = 15.26540;num.toString(); // 15.2654// 布尔var bool = true;bool.toString(); // true// Objectvar obj = &#123;name: \"张三\", age: 18&#125;;obj.toString(); // [object Object]// HTML DOM 节点var eles = document.getElementsByTagName(\"body\");eles.toString(); // [object NodeList]eles[0].toString(); // [object HTMLBodyElement] String() String()能够将任何类型的值转换为字符串，在不知道要转换的值是不是null和undefined的情况下，可以使用String() 123456789101112// 数字var a=123;String(a); //123//布尔值var b=true;String(b); //true//undefinedvar c;String(c); //undefined//nullvar d=null;String(d); //null boolean用于表示真假的类型，true表示真，false表示假 布尔型转换 Boolean() 除0之外的所有数字，转换为布尔型都为true 除&quot;&quot;空字符串之外的所有字符串，转换为布尔型都为true null和undefined转换为布尔型都为false 1234567Boolean(0); //falseBoolean(5); //trueBoolean(\"\"); //falseBoolean(\"abc\"); //trueBoolean(null); //falseBoolean(undefined); //falseBoolean(NaN); //false 表达式 将同类型的数据（如常量、变量、函数等），用运算符号按一定的规则连接起来的、有意义的式子称为表达式 操作符算数操作符 + 加 - 减 * 乘 / 除 % 取余 ++a与a++ 递增 ++a返回递增之后的a的值a++先返回a的原值，再返回递增之后的值 --a与a-- 递减，与递增同理 123456var x1 = 20, x2 = 30, x3 = --x1 + x2--;x1; //19x2; //29x3; //19+30 49 赋值操作符 = += -= *= /= %= 123456789var a = 10;a += 5; //15a -= 1; //14a *= 2; //24a /= 4; //6a %= 5; //1var b = \"hello \";b += \"world\"; //hello world 比较操作符 &gt; &lt; &gt;= &lt;= == === != !== == 只比较值是否相等=== 比较值的同时比较数据类型是否相等！= 只比较值是否不相等=== 比较值的同时比较数据类型是否不相等返回值： boolean型 12345678var a = 15, b = \"15\";a == b; //truea === b; //falsea != b; //falsea !== b; //truenull == undefined; //truenull === undefined; //false 三元操作符 语法 条件 ? 执行代码1 : 执行代码2 说明 可以代替简单的if语句如果条件成立，执行代码1，否则执行代码2 逻辑操作符 &amp;&amp; 与 只要有一个条件不成立，就返回false 在有一个操作数不是布尔值的情况下，逻辑与&amp;&amp;操作就不一定返回布尔值，此时它遵循以下规则： 如果第一个操作数隐式类型转换后为true，则依次后推至false的操作数并返回 如果第一个操作数隐式类型转换后为false，则返回第一个操作数 如果操作数中有null，则返回null 如果操作数中有NaN，则返回NaN 如果操作数中有undefined，则返回undefined 1234562 &amp;&amp; 3 &amp;&amp; \"hello\"; //\"hello\"0 &amp;&amp; 3 &amp;&amp; \"hello\"; //00 &amp;&amp; null &amp;&amp; NaN &amp;&amp; undefined; //03 &amp;&amp; null &amp;&amp; NaN &amp;&amp; undefined; //null3 &amp;&amp; NaN &amp;&amp; null &amp;&amp; undefined; //NaN3 &amp;&amp; undefined &amp;&amp; NaN &amp;&amp; null; //undefined || 或 只要有一个条件成立，就返回true 在有一个操作数不是布尔值的情况下，逻辑或||操作就不一定返回布尔值，此时它遵循以下规则： 如果第一个操作数隐式类型转换后为true，则返回第一个操作数 如果第一个操作数隐式类型转换后为false，则依次后推至true的操作数并返回 如果操作数都是null，则返回null 如果操作数都是NaN，则返回NaN 如果操作数都是undefined，则返回undefined 123452 || 3 || \"hello\"; //20 || 3 || \"hello\"; //30 || null || NaN || undefined; //undefined0 || undefined || null || NaN; //NaN0 || undefined || NaN || null; //null ! 非 无论操作数是什么类型，逻辑非!都会返回一个布尔值 !!同时使用两个逻辑非操作符时 第一个逻辑非操作符会基于操作数返回一个布尔值 第二个逻辑非操作符则对该布尔值求反 12345678910!0 //true!1 //false!\"\" //true!\"hello\" //false!NaN //true!null //true!undefined //true!!\"\" //false!!\"hello\" //true","categories":[{"name":"Javascript","slug":"Javascript","permalink":"https://github.com/ChangerHe/categories/Javascript/"}],"tags":[{"name":"Javascript","slug":"Javascript","permalink":"https://github.com/ChangerHe/tags/Javascript/"},{"name":"JavaScriptDOM编程艺术","slug":"JavaScriptDOM编程艺术","permalink":"https://github.com/ChangerHe/tags/JavaScriptDOM编程艺术/"}]},{"title":"JavaScriptDOM编程艺术查漏补缺(三)","slug":"JavaScriptDOM编程艺术查漏补缺(三)","date":"2017-06-15T01:16:09.000Z","updated":"2017-10-12T11:39:30.485Z","comments":true,"path":"2017/06/15/JavaScriptDOM编程艺术查漏补缺(三)/","link":"","permalink":"https://github.com/ChangerHe/2017/06/15/JavaScriptDOM编程艺术查漏补缺(三)/","excerpt":"","text":"content{:toc} 函数作用 通过函数可以封装任意多条语句，而且可以在任何地方、任何时候调用执行 语法 123function functionName([argument1,argument2...])&#123; 这里是要执行的代码&#125; 实例 123function myFunction(name,job)&#123; alert(\"Welcome \" + name + \", the \" + job);&#125; 函数调用 1functionName([argument1,argument2...]); 带有返回值的函数 12345function add(num1,num2)&#123; var sum = num1 + num2; return sum;&#125;document.write(add(2,5)); 函数会在执行完return语句之后停止并立即退出 return语句也可以不带任何的返回值，用于提前停止函数执行又不需要返回值的情况 1234function double(num)&#123; if(isNaN(num)) return; return num*2;&#125; 函数的参数argumentsECMAScript中的参数在内部用一个数组来表示，在函数体内通过arguments对象来访问这个数组参数 arguments对象只是与数组类似，并不是Array的实例 arguments[i]来访问它的每一个元素 arguments.length是传递参数的个数 实例：求任意一组数的平均值 12345678function getAverage()&#123; var sum = 0; for(var i = 0, len = arguments.length; i &lt; len; i++)&#123; sum += arguments[i]; &#125; return sum/len;&#125;console.log(getAverage(1,5,6,8,45,14));","categories":[{"name":"Javascript","slug":"Javascript","permalink":"https://github.com/ChangerHe/categories/Javascript/"}],"tags":[{"name":"Javascript","slug":"Javascript","permalink":"https://github.com/ChangerHe/tags/Javascript/"},{"name":"JavaScriptDOM编程艺术","slug":"JavaScriptDOM编程艺术","permalink":"https://github.com/ChangerHe/tags/JavaScriptDOM编程艺术/"}]},{"title":"JavaScriptDOM编程艺术查漏补缺(二)","slug":"JavaScriptDOM编程艺术查漏补缺(二)","date":"2017-06-15T01:16:09.000Z","updated":"2017-10-12T11:39:06.326Z","comments":true,"path":"2017/06/15/JavaScriptDOM编程艺术查漏补缺(二)/","link":"","permalink":"https://github.com/ChangerHe/2017/06/15/JavaScriptDOM编程艺术查漏补缺(二)/","excerpt":"","text":"content{:toc} if分支语句 if语句可以嵌套使用 单分支控制 语法： 123if(条件)&#123; 只有当条件为 true 时执行的代码&#125; 实例 1234var time = new Date().getHours();if(time &gt; 22)&#123; document.write('晚安');&#125; 双分支控制 语法： 123456if (条件)&#123; 当条件为 true 时执行的代码&#125;else&#123; 当条件不为 true 时执行的代码&#125; 实例 123456var time = new Date().getHours();if(time &gt; 22)&#123; document.write('晚安');&#125;else&#123; document.write('还没到睡觉时间');&#125; 多分支控制 语法： 123456789if (条件 1)&#123; 当条件 1 为 true 时执行的代码&#125;else if (条件 2)&#123; 当条件 2 为 true 时执行的代码&#125;else&#123; 当条件 1 和 条件 2 都不为 true 时执行的代码&#125; 实例 12345678var score = 88;if(score &lt; 60)&#123; document.write('不及格');&#125;else if(score &lt; 80)&#123; document.write('继续加油');&#125;else&#123; document.write('成绩很好，保持');&#125; switch分支语句多分支控制 语法： 123456789101112131415switch(表达式)&#123;case 值1: 执行代码块 1 break;case 值2: 执行代码块 2 break;...case 值n: 执行代码块 n break;default: 与 case值1 、 case值2...case值n 不同时执行的代码&#125; 实例： 123456789101112131415161718192021222324252627var day=new Date().getDay(), x;switch (day)&#123;case 0: x=\"Today is Sunday\"; break;case 1: x=\"Today is Monday\"; break;case 2: x=\"Today is Tuesday\"; break;case 3: x=\"Today is Wednesday\"; break;case 4: x=\"Today is Thursday\"; break;case 5: x=\"Today is Friday\"; break;case 6: x=\"Today is Saturday\"; break;&#125;document.write(x); case有几个都行，default可以没有。当case1~n都不满足的时候，则default。default并不一定要在最后在case所执行的语句后添加上一个break语句。否则就直接继续执行下面的case中的语句 for 循环语句for 循环语法： 123for(循环初值;循环条件;步长)&#123; 被执行的代码块&#125; 实例： 12345//1+2+....+99的值var sum = 0;for(var i = 0;i &lt; 100;i++)&#123; sum += i;&#125; 循环嵌套规则 外层为假时内层不执行 先执行外层再执行内层，直至内层条件为假时再返回外层去执行 for/in 循环 用来遍历对象的属性 实例： 12345678910var x;var txt=\"\";var person=&#123;fname:\"Bill\",lname:\"Gates\",age:56&#125;; for (x in person)&#123;txt += person[x];&#125;document.write(txt); //BillGates56 while 循环语句while 循环 While 循环会在指定条件为真时循环执行代码块 语法： 123while (条件)&#123; 需要执行的代码&#125; 实例： 12345var i = 0;while (i&lt;5)&#123; document.write(i); //01234 i++;&#125; 如果忘记改变条件中所用变量的值，该循环永远不会结束，可能导致浏览器崩溃 do/while 循环语法： 123do&#123; 需要执行的代码&#125;while (条件); 实例： 12345var i = 0;do&#123; document.write(i); //01234 i++;&#125;while (i&lt;5); do/while循环至少会执行一次，即使条件是 false for循环适合已知循环次数的循环体while循环适合未知循环次数的循环体 break 退出循环123456for (i=0;i&lt;10;i++)&#123; if (i==3)&#123; break; &#125; document.write(i); //012&#125; continue 退出本次循环123456for (i=0;i&lt;10;i++)&#123; if (i==3)&#123; continue; &#125; document.write(i); //012456789&#125;","categories":[{"name":"Javascript","slug":"Javascript","permalink":"https://github.com/ChangerHe/categories/Javascript/"}],"tags":[{"name":"Javascript","slug":"Javascript","permalink":"https://github.com/ChangerHe/tags/Javascript/"},{"name":"JavaScriptDOM编程艺术","slug":"JavaScriptDOM编程艺术","permalink":"https://github.com/ChangerHe/tags/JavaScriptDOM编程艺术/"}]},{"title":"调试Javascript-断点设置","slug":"调试Javascript-断点设置","date":"2017-06-15T01:16:09.000Z","updated":"2017-10-12T11:25:09.966Z","comments":true,"path":"2017/06/15/调试Javascript-断点设置/","link":"","permalink":"https://github.com/ChangerHe/2017/06/15/调试Javascript-断点设置/","excerpt":"","text":"如何设置断点 使用断点来暂停JavaScript代码，审查变量的值和在特定时刻所调用的堆栈。 一旦你设置了断点，你应该学习如何遍历你的代码，并审查你的变量和调用堆栈。 设置断点的最基本的方法是在特定的代码行上手动添加一个断点。您也可以将这些断点配置为仅在满足特定条件时触发。 您还可以设置在满足一般条件时触发的断点，例如事件，DOM更改或未捕获异常。 在代码特定行上设置断点 要在特定代码行上设置断点，首先打开Sources(源文件)面板，并在左侧的File Navigator(文件导航器)窗格中选择该脚本。如果找不到File Navigator(文件导航器)，按下Toggle file navigator(切换文件导航器)按钮（隐藏/显示文件导航器按钮）。 提示: 如果你使用缩略的代码，点击pretty print(代码美化)按钮{}使其可读。 在源代码的左侧，您可以看到行号。这个区域称为line number gutter(行号槽)。单击行号槽中的行号，就会在该行代码上添加一个断点。 提示: 如果一个表达式占了多行，并且你把一个行断点放在这个表达式的中间，DevTools会在下一个表达式上设置断点。 使一个行号断点有条件右键单击尚未设置断点的行号，然后点击Add conditional breakpoint(添加条件断点)来创建一个条件断点。如果你已经在一行代码上添加了断点，并且希望使断点有条件，右键单击该断点，并点击Edit breakpoint(编辑断点)。 在文本字段中输入你的条件，并按 Enter 键。 删除或禁用一个行号断点如果你想临时忽略一个断点，然后禁用它。右键单击line number gutter(行号槽)中该断点，并选择Disable breakpoint(禁用断点)。 如果你不再需要一个断点，然后删除它。右键单击line number gutter(行号槽)中该断点，并选择Remove breakpoint(删除断点)。 您还可以在Sources(源文件)面板上的Breakpoints(断点)窗格中管理所有脚本中的所有行号断点。 要从Breakpoints(断点)窗格界面中删除断点，右键单击该断点，并选择Remove breakpoint(删除断点)。 要从此窗格中禁用断点，请取消勾选其复选框。 要禁用所有断点，右键单击该窗格,并选择Deactivate breakpoints(停用断点)。这个产生的效果与Disable All Breakpoints(禁用所有断点)选项是相同的。 您也可以在Sources(源文件)面板上,通过点击Deactivate breakpoints(停用断点)按钮(停用断点按钮)来禁用所有断点。 设置监测DOM变化的断点 添加DOM change breakpoints(DOM变化断点) 在需要检测的DOM元素上右键单击，然后选择Inspect(检查)。DevTools将这个节点突出显示为蓝色。您可以通过双击它来展开节点，以便您可以查看其内容。这样可以验证你在正确的节点上。 右键单击突出显示的节点，然后选择Break on&gt;Subtree Modifications(子树修改)。节点左侧的蓝色图标 DOM断点图标 表示在该节点上设置了DOM断点。 DevTools监测到变化时会暂停该页面，转到Sources(源文件)面板，并突出显示脚本中导致更改的代码行。 点击Resume script execution(恢复脚本执行)按钮，可以恢复脚本执行。 要想暂时关闭这个断点： 在DevTools中回到Elements(元素)面板。 单击DOM Breakpoints(DOM断点)窗格。 取消勾选Subtree Modifications(子树修改)旁边的复选框。 要想删除这个断点： 转到DOM Breakpoints(DOM断点)窗格。 右键单击要删除的断点，然后选择Remove breakpoint(删除断点)。 更多关于DOM change breakpoints(DOM变化断点)类型以下是有关每种类型的DOM change breakpoints(DOM变化断点)具体触发时间和触发方式的详细信息： Subtree Modifications(子树修改) - 当当前选定节点的子节点被删除，添加或子节点的内容发生更改时触发。当子节点属性改变时，或当前选择的节点发生任何改变，都不会触发该类型的断点。 Attributes modifications(属性修改) - 当在当前选定的节点上添加或删除属性时,或当属性值改变时触发。 Node Removal(节点删除) -当当前选定的节点被删除时触发。 在XHR上中断有两种方法可以触发XHR上的断点：当任何XHR到达XHR生命周期的某个阶段时（readystatechange，load等），或者当XHR的URL与某个字符串匹配时。 如果你想在XHR生命周期的某个阶段时中断，请在事件侦听器断点窗格中查看XHR目录。 要在XHR的URL与某个字符串匹配时中断，请使用Sources(源文件)面板上的XHR Breakpoints(XHR断点)窗格。 点击“+”(加号)按钮添加一个新的断点模式。在文本字段中输入你的字符串，并按Enter键保存。 提示：点击“+”(加号)，然后立即按Enter键，可以在发送任何XHR之前触发断点。 当一个事件触发时中断 当某事件（例如，click(点击)）或事件类别（例如，任何mouse(鼠标)事件）被触发时，使用Sources(源文件)面板上的Event Listener Breakpoints(事件侦听器断点)窗格中断。 在未捕获的异常上中断 如果你的代码抛出异常，你不知道他们来自哪里，点击Sources(源文件)面板上的pause on exception(在异常上暂停)按钮（在异常上暂停按钮）。 DevTools在抛出异常的行自动中断。","categories":[{"name":"Javascript","slug":"Javascript","permalink":"https://github.com/ChangerHe/categories/Javascript/"}],"tags":[{"name":"Javascript","slug":"Javascript","permalink":"https://github.com/ChangerHe/tags/Javascript/"},{"name":"调试","slug":"调试","permalink":"https://github.com/ChangerHe/tags/调试/"}]},{"title":"JAVA代码执行顺序解析","slug":"代码执行顺序解析","date":"2017-06-14T14:58:57.000Z","updated":"2017-09-14T14:21:28.061Z","comments":true,"path":"2017/06/14/代码执行顺序解析/","link":"","permalink":"https://github.com/ChangerHe/2017/06/14/代码执行顺序解析/","excerpt":"","text":"今天的博客记录一道题目，求出以下代码，所打印出的顺序，代码如下：123456789101112131415161718192021222324252627282930313233343536public class App&#123; private static App d = new App(); private SubClass t = new SubClass(); static &#123; System.out.println(3); &#125; public App() &#123; System.out.println(4); &#125; public static void main(String[] args) &#123; System.out.println(&quot;Hello World!&quot;); &#125;&#125;class SuperClass&#123; SuperClass() &#123; System.out.println(&quot;SuperClass 构造器&quot;); &#125;&#125;class SubClass extends SuperClass&#123; static &#123; System.out.println(1); &#125; public SubClass() &#123; System.out.println(2); &#125;&#125; 此题主要考察构造器，类及静态变量、非静态变量，父类，子类在JVM中的调用顺序。答案在我第一次做的时候确实是意想不到：1234561SuperClass 构造器243Hello World! JVM代码块加载原则1.优先加载主类以外，与主类相关的其他类，方便主类进行调用。2.如果代码块有static修饰，则优先加载进JVM进行执行。3.子类中的构造器自带一个super（）；方法，且在构造器的第一行代码中，因此当父类的构造器为无参数构造器时，子类将优先调用父类的无参数构造器的内容。 题目中的加载顺序分析1.第一个为什么是1，因为主类中的main方法会在其他相关的父类和子类优先调用之后，再进行调用，因此优先进行调用SuperClass和SubClass，在这两个类中，SubClass又是SuperClass的子类，理论上应先行调用父类，但子类中包含静态代码块，因此优先调用static修饰的静态字码快中的内容，从而优先输出“1”；2.为什么第二个是“SuperClass 构造器”，上面优先打印1的原理讲明白了，第二个也就好理解了，子代码块中的构造器自带一个super();的方法，会优先进行调用父类中的无变量构造器。因此打印出“SuperClass 构造器”。3.为什么第三个是数字2，构造器的运行顺序是自顶向下的，因此执行完super();后，就开始执行下一字段，也就是2；4.为什么第四个是数字4？非主类中的其他类已经加载完毕，那么现在开始加载主类，主类中又有一个static修饰的代码块，因此主类优先执行了App();中的打印4，操作5.同样，根据自顶向下原色，执行了打印3的操作。6.也就是最后，打印了main方法中的“Hello World!”。","categories":[{"name":"JAVA 学习笔记","slug":"JAVA-学习笔记","permalink":"https://github.com/ChangerHe/categories/JAVA-学习笔记/"}],"tags":[{"name":"JAVA","slug":"JAVA","permalink":"https://github.com/ChangerHe/tags/JAVA/"}]},{"title":"斐波那契数列和九九乘法表在JAVA中的实现","slug":"Java-Learning","date":"2017-06-14T14:16:09.000Z","updated":"2017-09-14T15:00:51.049Z","comments":true,"path":"2017/06/14/Java-Learning/","link":"","permalink":"https://github.com/ChangerHe/2017/06/14/Java-Learning/","excerpt":"","text":"今日成功完成斐波那契数列及九九乘法表在JAVA中的实现，哈哈哈哈没看教程就了解了一下语法然后自己撸出来的，有点儿小自豪。 斐波那契数列（Fibonacci sequence）斐波那契数列又称黄金分割数列、因数学家列昂纳多·斐波那契（Leonardoda Fibonacci）以兔子繁殖为例子而引入，故又称为“兔子数列”，指的是这样一个数列：1、1、2、3、5、8、13、21、34、……在数学上，斐波纳契数列以如下被以递归的方法定义：F(0)=0，F(1)=1, F(n)=F(n-1)+F(n-2)（n&gt;=2，n∈N*）在现代物理、准晶体结构、化学等领域，斐波纳契数列都有直接的应用，为此，美国数学会从1963起出版了以《斐波纳契数列季刊》为名的一份数学杂志，用于专门刊载这方面的研究成果。解决该问题JAVA实现的主要思路是：先确定斐波那契数列第一项和第二项值，然后使用递归方式，将方法进行嵌套，通过函数执行，就可以实现斐波那契数列啦！1234567891011121314151617//求斐波那契数列的第n项值public class FebNachi&#123; static int FebNachi(int i)&#123; switch ( i ) &#123; case 1 : return 0; case 2 : return 1; default : return FebNachi(i -1) + FebNachi(i - 2); &#125; &#125; public static void main(String[] args)&#123; System.out.println(FebNachi(4)); &#125;&#125; 九九乘法表（MultiplicationTable）这个就不多说了，小学都背过，主要实现方式是通过循环的嵌套，结合if判断语句，进行输出即可。123456789101112131415161718192021222324//使用Java输出九九乘法表public class MultiplicationTable&#123; public static void main(String[] args) &#123; int i; int j; for ( i = 1; i &lt;= 9 ; i++ ) &#123; for ( j = 1; j &lt;= 9 ; j++) &#123; if ( i == j) &#123; break; &#125; System. out. print(i+&quot; + &quot;+j+&quot; = &quot;+(i + j)+&quot;\\t&quot;); &#125; System. out. println(); &#125; &#125;&#125; 另外，今天是学习JAVA的第二天，感觉这个和JS真的很像啊，再奉上今天学到的“锚”方法，在return或break时，对return或break的对象进行定向：123456789101112131415public static void main(String[] args)&#123; outter: for( int line = 1; line &lt;= 9; i++) &#123; for( int i = 1; i &lt;= line; i++) &#123; if( line == 5) &#123; break outter; //此时并非结束此次i的for循环，而是直接跳出所有循环 &#125; System. out. print( i + &quot;*&quot; + line + &quot;=&quot; + ( i + line ) + &quot;\\t&quot;); //输出九九乘法表 &#125; System. out. println(); //输出换行符 &#125;&#125;","categories":[{"name":"JAVA 学习笔记","slug":"JAVA-学习笔记","permalink":"https://github.com/ChangerHe/categories/JAVA-学习笔记/"}],"tags":[{"name":"JAVA 学习笔记","slug":"JAVA-学习笔记","permalink":"https://github.com/ChangerHe/tags/JAVA-学习笔记/"}]},{"title":"jQuery 学习笔记——选择器","slug":"jQuery-学习笔记","date":"2017-06-14T14:16:09.000Z","updated":"2017-09-14T15:01:49.220Z","comments":true,"path":"2017/06/14/jQuery-学习笔记/","link":"","permalink":"https://github.com/ChangerHe/2017/06/14/jQuery-学习笔记/","excerpt":"","text":"JQuery基本介绍jQuery是一个前端必备的js脚本库，使用时只许进行引用即可，网上有大量的cdn可直接引用。 jQuery的版本问题jQuery主要的版本为1.x版和2.x版，主要的区别在于2.x版放弃了对IE老版本浏览器的支持，减少了大量代码，因此2.x版本比jQuery的1.x版本更小。如果比较在意老版本IE的话，可以使用jQuery在1.9的版本。jQuery的系列分为开发版和压缩版，压缩版是直接拿来引用的，开发版用于开发者进行代码调试等。 jQuery的使用笔记1.类比于window.onload，jQuery有一个$(document).ready(function(){}2.类比于var p = document.getElementById(“imooc”);p.innerHTML = “aaa”;p.style.color = ‘red’;原生的写法具有过多的代码量，但是使用jQuery，只需要一行代码即可。var $p = $(‘#imooc’);$p.html(‘aaa’).css(‘color’,’red’); jquery对象转化为DOM对象以下面的例子进行示范，将三个div中第一个div的文字换位红色12345678910111213141516//HTML 代码&lt;div&gt;111&lt;/div&gt;&lt;div&gt;222&lt;/div&gt;&lt;div&gt;333&lt;/div&gt;// JS原生获取写法var Div = document.getElementsByClassName(&apos;div&apos;);var div1 = Div[0]Div[0].style.color = &apos;red&apos;;//jQuery写法1var $div = $(&apos;div&apos;);var div = $div[0];div.style.color = &apos;red&apos;;//jQuery写法2var $div = $(&apos;div&apos;);var div = $div.get(0); //通过get方法转化为dom对象div.style.color = &apos;red&apos;; jquery的ID选择器$(“#id”)注： id是唯一的，每个id值在一个页面中只能使用一次。如果多个元素分配了相同的id，将只匹配该id选择集合的第一个DOM元素。但这种行为不应该发生;有超过一个元素的页面使用相同的id是无效的 jQuery的class选择器$(“.class”)注： 该方法进行了隐式循环处理，因此在调用时不需要进行循环操作。 元素选择器$(“element”)注： 该方法进行了隐式循环处理，因此在调用时不需要进行循环操作。 全选择器“*”$(“*”) 层级选择器 基本筛选选择器 内容筛选选择器注：1.contains和has都有查找的意思，但是contains查找包含指定文本的元素，has查找包含指定元素的元素。2.如果contains匹配的文本包含在元素的子元素中，同样认为是符合条件的。3.parent与empty是相反的，两者设计的子元素包括文本节点。 可见性筛选选择器 属性筛选选择器 子元素筛选选择器注：jQuery实现:nth-child(n)是严格来自CSS规范，所以n值是“索引”，也就是说，从1开始计数，:nth-child(index)从1开始的，而eq(index)是从0开始的。 表单元素选择器 对象属性筛选选择器 特殊选择器this12345$(&apos;p&apos;).click(function()&#123; //把p元素转化成jQuery的对象 var $this= $(this) $this.css(&apos;color&apos;,&apos;red&apos;)&#125;) 通过$()方法传入当前元素对象的引用this，然后把这个this加工成jQuery对象，我们就可以用jQuery提供的快捷方法处理样式了。注：this，表示当前的上下文对象是一个html对象，可以调用html对象所拥有的属性和方法。$(this),代表的上下文对象是一个jquery的上下文对象，可以调用jQuery的方法和属性值。","categories":[{"name":"jQuery 学习笔记","slug":"jQuery-学习笔记","permalink":"https://github.com/ChangerHe/categories/jQuery-学习笔记/"}],"tags":[{"name":"jQuery","slug":"jQuery","permalink":"https://github.com/ChangerHe/tags/jQuery/"}]},{"title":"PHP菜鸟入门不完全指南","slug":"PHP菜鸟入门笔记","date":"2017-06-14T14:16:09.000Z","updated":"2017-09-14T15:02:22.565Z","comments":true,"path":"2017/06/14/PHP菜鸟入门笔记/","link":"","permalink":"https://github.com/ChangerHe/2017/06/14/PHP菜鸟入门笔记/","excerpt":"","text":"PHP是作用于服务器端的语言，偏前端的朋友们会称他为后端语言。而专门做后端的朋友们则会说，PHP是一种前端的弱类型语言。当然，这个语言的定位不是最重要的，重要的是，PHP到底是不是最好的语言？ PHP的适用范围生成动态页面内容创建，打开，读取，写入，删除及关闭服务器上的文件。接收表单数据，发送并取回cookies添加，删除，修改数据库中的数据限制用户访问网站中的某个页面PHP结构以&lt;?php开头，以 ?&gt; 结尾，默认文件扩展名是 .php ,语句不同于javascript，必须要以分号结尾。 12&lt;?php echo &quot;hi&quot;.&quot;changer&quot;; ?&gt; //hichanger//PHP不同于其他语言的以“+”链接两字符串的方式，而是以“.”进行连接。 PHP基本语法变量的定义必须以字母或下划线开头，如&quot;$_name&quot;/&quot;$name&quot;/&quot;$name2&quot;等。 变量名只能由字母数字及下划线组成，可以包含汉字，但不推荐这样做。 变量名不允许包含空格，因此当变量名由多个单词组成，建议使用下划线分隔，或者使用驼峰命名法。变量名严格区分大小写。 smallTips: 使用memory_get_usage获取当前PHP消耗的内存 PHP标量类型布尔类型整型浮点型字符串 smallTips: 当双引号包含变量时，变量会引入，单引号包含变量时，变量不引入。12345$love = &quot;I love you!&quot;;$string1 = &quot;Changer , $love&quot;;$string2 = &apos;Changer , $love&apos;;echo $string1; //Changer, I love you!echo $string2; //Changer, $love smallTips: 当字符串很长时，可使用定界符进行表示123$string = &lt;&lt;&lt;GOD //中间放大量内容GOD; PHP特殊类型资源由专门函数来建立和使用，我们可对资源进行操作（创建，使用，释放），任何资源在不使用时应被及时释放。如果我们忘记释放资源，系统会自动启动垃圾回收机制，在页面执行完毕后回收资源。12345&lt;?php $file = fopen(&quot;f.txt&quot;,&quot;r&quot;); //打开文件 $con = mysql_connect(&quot;localhost&quot;,&quot;root&quot;,&quot;root&quot;); //链接数据库 $img = imagecreate(100,100); //图形画布?&gt; 空类型对大小写不敏感，null类型只有一个取值，表示一个变量没有值，当被赋值NULL或未被赋值或被unset()时，变量为NULL。 smalltips: error_reporting(0); //禁止显示PHP警告提示 PHP常量12345bool define(string $constant_name, mixed $value[,$case_sensitive = true])//参数 constant_name: 常量名称，常量命名规则与变量一致，可不带$符号。// value :常量的值// case_sensitive: (可选项）表示是否对大小写敏感，默认为false，敏感。// string ：表示字符串类型，mixed表示参数类型可接受为多种不同类型。 PHP系统常量1.FILE:指PHP程序文件名，可帮助我们获取当前文静在服务器的物理位置。2.LINE:指PHP程序文件行数，可告诉我们当前代码在第几行。3.PHP_VERSION:当前PHP解析器的版本号。4.PHP_OS:执行当前PHP版本的操作系统名称。 smallTips:判断常量是否被定义bool defined(string constants_name) PHP赋值运算符等号 “=” ：表示把右边表达式的值赋值给左边的运算数，两者为不同内存空间。和符号 “&amp;” : 表示引用赋值，两者相等，引用的是同一块内存空间。 smallTips：在PHP比较时，“！=”和“&lt;&gt;”是等价的，但用数据库时，后者的兼容性更好。 PHP逻辑运算符 逻辑运算符 表示的含义 $a and $b 与 $a or $b 或 $a xor $b 异或 !$a 非 $a &amp;&amp; $b 与 $a &#124;&#124; $b 或 smallTips: .rand(1,50); 表示1-50之间的随机数","categories":[{"name":"PHP 学习笔记","slug":"PHP-学习笔记","permalink":"https://github.com/ChangerHe/categories/PHP-学习笔记/"}],"tags":[{"name":"PHP","slug":"PHP","permalink":"https://github.com/ChangerHe/tags/PHP/"}]},{"title":"jQuery 学习笔记——属性与样式","slug":"jQuery学习笔记——属性与样式","date":"2017-06-14T14:16:09.000Z","updated":"2017-09-14T15:01:55.705Z","comments":true,"path":"2017/06/14/jQuery学习笔记——属性与样式/","link":"","permalink":"https://github.com/ChangerHe/2017/06/14/jQuery学习笔记——属性与样式/","excerpt":"","text":"第二篇的jQuery笔记记录jQuery的属性和样式。每个元素都有一个或者多个特性,这些特性的用途就是给出相应元素或者其内容的附加信息。如：在img元素中，src就是元素的特性，用来标记图片的地址。 attr()和removeAttr()操作特性的DOM方法主要有三个：getAttribute（）、setAttribute（）、removeAttribute（）。而且就算在实际操作中还是会存在很多问题，而jQuery中用一个attr（）和removeAttribute（）就可以搞定以上，而且能实现兼容。 attr（）有4个表达式：12341.attr(传入属性名)：获取属性的值2.attr(属性名，属性值)：设置属性的值3.attr(属性名，函数值)：设置属性的函数值4.attr(attributes)：给指定元素设置多个属性值 removeAttr()删除方法```.removeAttr(attributeName):为匹配的元素集合中的每个元素中移除一个属性（attribute） 优点attr、removeAttr都是jQuery为了属性操作封装的，直接在一个jQuery对象上调用该方法，很容易对属性进行操作，也不需要去特意理解浏览器的属性名不同的问题。注：dom中有个概念的区分：Attribute和Property翻译出来都是“属性”，《js高级程序设计》书中翻译为“特性”和“属性”。简单理解，Attribute就是dom节点自带的属性。也就是说：获取Attribute就要用attr，获取Property就要用prop。 html()和text()读取。修改元素的HTML结构或者元素的文本内容是常见的DOM操作。这方面jQuery提供了两种方法：html()和text()。 html()方法获取集合中第一个匹配元素的HTML内容或设置每一个匹配元素的HTML内容。具体用法如下：1.html()不传入值，就是获取集合中第一个匹配元素的HTML内容。2.html(htmlString)设置每一个匹配元素的HTML内容。3.html(function(index,oldhtml))用来返回设置HTML内容的一个函数。注：.html()方法内部使用的是DOM的innerHTML属性来处理的，所以在设置与获取上需要注意的一个最重要的问题，这个操作是针对整个HTML内容（不仅仅只是文本内容） text()方法得到匹配匀速集合中每个元素的文本内容集合，包括他们的后代。或者设置匹配元素集合中每个元素的文本内容为指定的文本内容。具体用法如下：1.text()得到匹配元素集合中每个元素的合并文本，包括其后代。2.text(textString)用于设置匹配元素内容的文本。3.text(function(index,text))用来返回设置文本内容的一个函数。注：text()结果返回一个字符串，包含所有匹配元素的合并文本。 .html与.text的异同:1..html与.text的方法操作是一样，只是在具体针对处理对象不同2..html处理的是元素内容，.text处理的是文本内容3..html只能使用在HTML文档中，.text 在XML 和 HTML 文档中都能使用4.如果处理的对象只有一个子文本节点，那么html处理的结果与text是一样的5.火狐不支持innerText属性，用了类似的textContent属性，.text()方法综合了2个属性的支持，所以可以兼容所有浏览器 val()该方法主要用于处理表单元素的值，具体用法如下：1.val()无参数，获取匹配的元素集合中第一个元素的当前值2.val( value )，设置匹配的元素集合中每个元素的值3.val( function ) ，一个用来返回设置值的函数 html(),text()和val()的差异总结：1.html(),text(),val()三种方法都是用来读取选定元素的内容；只不过html()是用来读取元素的html内容（包括html标签），text()用来读取元素的纯文本内容，包括其后代元素，val()是用来读取表单元素的”value”值。其中.html()和.text()方法不能使用在表单元素上,而.val()只能使用在表单元素上；另外.html()方法使用在多个元素上时，只读取第一个元素；.val()方法和.html()相同，如果其应用在多个元素上时，只能读取第一个表单元素的”value”值，但是.text()和他们不一样，如果.text()应用在多个元素上时，将会读取所有选中元素的文本内容。2.html(htmlString),text(textString)和val(value)三种方法都是用来替换选中元素的内容，如果三个方法同时运用在多个元素上时，那么将会替换所有选中元素的内容。3.html(),text(),val()都可以使用回调函数的返回值来动态的改变多个元素的内容。","categories":[{"name":"jQuery 学习笔记","slug":"jQuery-学习笔记","permalink":"https://github.com/ChangerHe/categories/jQuery-学习笔记/"}],"tags":[{"name":"jQuery","slug":"jQuery","permalink":"https://github.com/ChangerHe/tags/jQuery/"}]},{"title":"jQuery 学习笔记——Review","slug":"jQuery查漏补缺","date":"2017-06-14T14:16:09.000Z","updated":"2017-09-14T15:01:58.966Z","comments":true,"path":"2017/06/14/jQuery查漏补缺/","link":"","permalink":"https://github.com/ChangerHe/2017/06/14/jQuery查漏补缺/","excerpt":"","text":"整体地看了一遍《锋利的jQuery》这本书，老师对jQuery这个脚本库进行了非常详细的解答，通俗易懂，但是感觉对AJAX我还是云里雾里，过两天有网了还是要撸一下AJAX。同时，我对里面的API还是不够熟悉，过一段时间，还要再看一遍！再对着上面的代码再敲一遍才好。等JS高程全部搞懂了，一定要把JQ的源码撸一遍！今天看了张鑫旭大神的博客,狠狠地抽醒了我，作为一个大学的时候玩HTML、css、JS玩的飞起的人，在毕业后做了九个月切图仔，又去自己闭关自学了九个月才能到现在的大神水平，而且他还是计算机专业的985院校毕业生，所以我一个二流野鸡大学的非科班毕业生，凭什么不努力呢？虽然是碗毒鸡汤，但我干了，大家随意。回到正文，对今天学到的一些自己的易忘点，易错点进行回顾： jQuery对象和DOM对象的相互转换：12345var variable1 = jQuery对象； //新定义一个jQuery对象var variable2 = DOM对象； //新定义一个DOM对象//将jQuery对象转为DOM对象var cr = $(&quot;#cr&quot;);var cr = $cr[0]; //或使用 var cr = $cr.get[0]; 多个JS库争夺符号“$”控制权的解决办法在其他库加载完毕后，可以在任何时候调用jQuery.noConflict()方法来将变量”$”的控制权移交给其他的JS库，同时，当需要使用jQuery库中的方法时，可直接调用jquery()方法即可。当然，此时也可使用变量对其进行替代，需要调用时，直接使用变量就好了。1var $j = jquery.noConflict(); jQuery的对象检查方式jQuery在搜索对象时，即使该对象不存在，jQuery也不会报错，因此当直接使用调用的对象进行布尔运算时，会一直显示为true，因此，在判断该对象是否存在时，应当使用如下方法：123if( $content.length)&#123; //Do something&#125; 注：当jQuery的id对象有多个时，调用$(“#id”);永远显示的是第一个id对象。 子元素和后代元素的区别子元素 Ex: $(&quot;parent &gt; child&quot;);后代元素：Ex: $(&quot;parent dessemdant&quot;);区别： 子元素选择的是parent元素的儿子辈，而后代元素选择的是parent元素的子、孙、曾孙加上以后的辈。 选取规则选取紧接在prev元素后的next元素（仅选择一个元素）1$(&quot;prev + next&quot;); //等价于 $(&quot;prev&quot;).next(&quot;next&quot;); 选取prev元素后的所有sibling元素1$(&quot;prev ~ siblings&quot;); //等价于 $(&quot;prev&quot;).nextAll(&quot;siblings&quot;) 选取含有文本内容为“我”的元素1$(&quot;div:contains(&quot;我&quot;)&quot;)； 选取含有选择器所匹配的元素的元素1$(&quot;div:has(p)&quot;) remove()方法的特殊属性当节点使用remove()方法被删除后，该节点包含的所有后代节点都将同时被删除，这个方法的返回值是一个指向已被删除的节点的引用，因此可以在之后再次使用。 css()方法的命名规则在css()方法中，若属性带有“-”连接符，则此时官方建议使用驼峰命名法进行代替，否则直接引用带”-“的属性时，需要加上引号。1$(&quot;p&quot;).css(&#123;fontSize: &quot;30px&quot;,&quot;background-color&quot;: &quot;#888&quot;&#125;) 关于height()方法和css()中的css(“height”)方法两者无较大区别，但是当给height()方法设置值时，默认的单位为px，若使用其他单位，则需要加上引号。height()方法获得的是页面的实际高度，而css()获取的高度根据设置的值的单位决定，也有可能为auto。 判断当前元素是否处于动画状态判断当前元素是否处于动画状态，是写动画时常常需要的一个判断方法，可以防止在多次点击按钮后，页面不停跳转的问题。123if(!$(&quot;element&quot;).is(&quot;:animated&quot;))&#123; //若当前无动画，则进行新动画&#125;","categories":[{"name":"jQuery 学习笔记","slug":"jQuery-学习笔记","permalink":"https://github.com/ChangerHe/categories/jQuery-学习笔记/"}],"tags":[{"name":"jQuery","slug":"jQuery","permalink":"https://github.com/ChangerHe/tags/jQuery/"}]},{"title":"九宫格自适应布局的页面重构","slug":"nine-block-mission","date":"2017-06-14T14:16:09.000Z","updated":"2017-09-14T15:00:56.171Z","comments":true,"path":"2017/06/14/nine-block-mission/","link":"","permalink":"https://github.com/ChangerHe/2017/06/14/nine-block-mission/","excerpt":"","text":"为什么要这么“作死”本文使用JS方法，对之前本来比较简单的九宫格布局方法，进行了“暴力”重构代码主要的构思1.毋庸置疑，第一步，在meta中设定显示宽度为设备的宽度，缩放比例为1:1。2.要想实现页面的高为100%,因页面存在继承属性，html继承了浏览器的高度，因此需要在设置盒子的高度为100%之前，设置html和body的高度为100%，才能实现子盒子的高度为100%。3.最开始我的考虑是实现宽高为100%，然后子盒子再继续以百分比进行设置，虽然实现了九宫格，但是页面实在是太吃藕了，所以思考着添加JS方法，对页面进行重构。 使用JS方法的重构思路1.获取浏览器的宽度2.比较大盒子的宽高，并取出宽高中较小的值，并将较小值赋值给大盒子的宽和高，这就实现了大盒子是个正方形且刚刚好接近覆盖整个页面。3.此时的页面靠左，因此需考虑一个办法将页面居中，这里面再次使用了“暴力”方法进行了居中，居中方式如下：1con.style.marginLeft=cWidth/2-con.offsetWidth/2+'px'; 即是将浏览器宽度减去大盒子宽度除二，便是左边的margin的宽度啦。4.对小盒子进行设置，小盒子的宽高是相对大盒子的，这就比较好设置了，进行遍历，设置它们的宽高相等就好啦。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970&lt;!doctype html&gt;&lt;html lang=\"en\"&gt;&lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;title&gt;Nine-Block Layout&lt;/title&gt; &lt;meta name=\"viewport\" content=\"width=device-width,initial-scale=1.0\"&gt; &lt;style&gt; *&#123; margin: 0; padding: 0; &#125; html,body&#123; width: 100%; height: 100%; &#125; .container&#123; height:100%; width: 100%; &#125; .box&#123; height:29%; width: 29%; background: #ff0; float:left; margin:2%; border-radius: 10px; &#125; &lt;/style&gt; &lt;script&gt; window.onload=function()&#123; var con=document.getElementsByClassName('container')[0]; //获取容器 var box=document.getElementsByClassName('box'); //获取小盒子 //console.log(con.offsetHeight&gt;con.offsetWidth); var cWidth=document.body.clientWidth; //设置cWidth值为屏幕宽度 //console.log(cWidth) function compare()&#123; //比较大盒子宽高大小，取小值 if (con.offsetHeight&gt;con.offsetWidth) &#123; return con.offsetWidth; &#125; else &#123; return con.offsetHeight; &#125;&#125; con.style.height=con.style.width=compare()+'px'; //将大盒子的宽高设置为较小值 con.style.marginLeft=cWidth/2-con.offsetWidth/2+'px'; //将坐外边距设置为屏幕宽减去大盒子宽度的一半 //console.log(con.style.width); //console.log(con.style.height); for (var i = 0; i &lt; box.length; i++) &#123; //将小盒子的宽高设为相等 box[i].style.width=box[0].offsetHeight+'px'; &#125; &#125; &lt;/script&gt;&lt;/head&gt;&lt;body&gt;&lt;div class=\"container\"&gt; &lt;div class=\"box\"&gt;&lt;/div&gt; &lt;div class=\"box\"&gt;&lt;/div&gt; &lt;div class=\"box\"&gt;&lt;/div&gt; &lt;div class=\"box\"&gt;&lt;/div&gt; &lt;div class=\"box\"&gt;&lt;/div&gt; &lt;div class=\"box\"&gt;&lt;/div&gt; &lt;div class=\"box\"&gt;&lt;/div&gt; &lt;div class=\"box\"&gt;&lt;/div&gt; &lt;div class=\"box\"&gt;&lt;/div&gt;&lt;/div&gt;&lt;/body&gt;&lt;/html&gt;","categories":[{"name":"HTML & CSS 学习笔记","slug":"HTML-CSS-学习笔记","permalink":"https://github.com/ChangerHe/categories/HTML-CSS-学习笔记/"}],"tags":[{"name":"HTML & CSS","slug":"HTML-CSS","permalink":"https://github.com/ChangerHe/tags/HTML-CSS/"}]},{"title":"不同排序算法的JAVA实现及性能比较","slug":"不同排序算法的JAVA实现及性能比较","date":"2017-06-14T14:16:09.000Z","updated":"2017-09-14T15:01:16.439Z","comments":true,"path":"2017/06/14/不同排序算法的JAVA实现及性能比较/","link":"","permalink":"https://github.com/ChangerHe/2017/06/14/不同排序算法的JAVA实现及性能比较/","excerpt":"","text":"排序现在已学的有两种，冒泡排序（BubbleSort）和选择排序（SelectionSort），两种方法各有不同； 冒泡排序冒泡排序是将数组中的元素进行逐一比较，并将两者比较之后的较大值与后面第三位元素进行比较。进行循环后，第一次可得到数组中的最大值，且最大值在数组的最后一个位置上。通过JAVA进行实现的大概思路是：将第一位元素与第二位进行比较，将较大值赋给第二位元素，较小值赋给第一位元素，然后再将第二位元素与第三位元素进行比较，照此进行循环，最终可将最大数移至数组最后一位。进行第二次运算，则使用相同的计算方式，得到第二大的元素，并赋予给倒数第二个元素。进行运算后，可得到顺序排列的数组。因此，冒泡排序要实现排序，如果有一个数组有N个元素，需要经过N！次，才能得到顺序排列的数组，且每次循环都要进行数组调换，大大影响了排序性能。123456789101112131415161718192021222324252627282930313233//冒泡排序的算法class BubbleSort &#123; public static void main(String[] args) &#123; int[] arr = &#123;2 ,6 ,9 ,1 ,4 ,7&#125;; int a; for ( int i = 0; i &lt; arr.length-1 ; i++ ) &#123; for ( int j = 0 ; j &lt; arr.length-1-i ; j++ ) &#123; if ( arr[j] &gt; arr[j+1]) &#123; a = arr[j]; arr[j] = arr[j+1]; arr[j+1] = a; &#125; &#125; &#125; String PrintArr = &quot;[&quot;; //打包成字符输出 for ( int i = 0; i &lt; arr.length ; i++ ) &#123; PrintArr = PrintArr + arr[i]; if ( i == arr.length-1 ) &#123; break; &#125; PrintArr = PrintArr + &quot;,&quot;; &#125; PrintArr = PrintArr + &quot;]&quot;; System.out.println(PrintArr); &#125;&#125; 选择排序选择排序的方法是将数组中的第一个元素和数组的其他元素逐一进行比较，将比较之后的较小值赋予给第一个元素。遍历一次后，数组的第一个元素可获得数组中的最小值。第二次遍历从第三个元素开始，将其与第二个元素进行比较，较小值赋予给第二个元素。以此类推，可知选择排序的比较次数依旧为N！次。但选择排序时不需将元素进行多次的调换，因此性能方面较冒泡排序有些许提升。123456789101112131415161718192021222324252627282930313233//选择排序的算法class SelectionSort&#123; public static void main(String[] args) &#123; int[] arr = &#123;2 ,6 ,9 ,1 ,4 ,7&#125;; int a; for ( int i = 0; i&lt; arr.length ; i++ ) &#123; for ( int j = i; j &lt; arr.length ; j++ ) &#123; if ( arr[i] &gt; arr[j] ) &#123; a = arr[i]; arr[i] = arr[j]; arr[j] = a; &#125; &#125; &#125; String PrintArr = &quot;[&quot;; //打包成字符输出 for ( int i = 0; i &lt; arr.length ; i++ ) &#123; PrintArr = PrintArr + arr[i]; if ( i == arr.length-1 ) &#123; break; &#125; PrintArr = PrintArr + &quot;,&quot;; &#125; PrintArr = PrintArr + &quot;]&quot;; System.out.println(PrintArr); &#125;&#125; 选择排序还可进行算法优化，每次遍历只与便利到的最小值进行交换，这样可以再减少一些数值交换次数，但笔者尚未实现，待实现完毕再更新。","categories":[{"name":"JAVA 学习笔记","slug":"JAVA-学习笔记","permalink":"https://github.com/ChangerHe/categories/JAVA-学习笔记/"}],"tags":[{"name":"JAVA","slug":"JAVA","permalink":"https://github.com/ChangerHe/tags/JAVA/"}]},{"title":"GIT配置不需密码即可push的方法","slug":"GIT配置不需密码即可push的方法","date":"2017-06-14T14:16:09.000Z","updated":"2017-09-14T15:01:46.148Z","comments":true,"path":"2017/06/14/GIT配置不需密码即可push的方法/","link":"","permalink":"https://github.com/ChangerHe/2017/06/14/GIT配置不需密码即可push的方法/","excerpt":"","text":"为什么要写这篇博客？今天学了点node.js，被慕课网狂拽酷炫的操作所折服，故决定投身sublime的怀抱。安装了package control以及各大插件后，最后安装git插件测试时，使用git：push命令始终没办法将代码push到我的github，想想也真是日了Justin Beiber了。没办法，谁叫我天生丽质爱学习呢，然后我在网上找了各种办法，发现百度上的方法真的是水平太低，标准不一，基本雷同，更坑爹的是错都是差不多错一样的。我一个用github用了好几个月的人，你还叫我配置公钥？真是想说： 真正的解决办法网上有很多办法，其实已经快说到点子上了，但是都是隔着被子瘙痒——没什么卵用，配置的时候看到那些博客，始终是摸不着头脑。注：以下的配置方法，默认你已经安装好了git客户端，且熟悉基本的git操作命令，在远程代码库拥有了自己的仓库，且使用密码提交代码是成功的。 好，那么话不多说，开干我们最主要的目的，是将提交时的http协议地址，直接改成类似于1git@github.com:ChangerHe/My-code.git 这样的地址，当然，ChanerHe是我的github名，My-code是我想要push到的远程仓库名。更改之后，push的时候就会自动push到自己的仓库，不需要输入代码了，同时可以开心地在sublime上进行使用git插件了！那么，现在我们现在打开我们我的git bash，在gitbash中输入1git remote -v 输入之后可查看到自己的输出的branch，此时默认是origin。此时如果未设置成功，bash中的输出是这样子的：12origin https://github.com/ChangerHe/My-code (fetch)origin https://github.com/ChangerHe/My-code (push) 这个时候你的push地址是https路径，所以会导致此时需要输入账号密码，我们现在再执行：1git remote set-url origin git@github.com:ChangerHe/My-code.git 上面这段代码的意思就是，把git的默认push和fetch地址，改为以上相应地址。 同样的，ChangerHe是我的ID，My-code是我要提交的远程仓库名称，这段代码中，这两处需要改为你自己的。以上是我查到的很多资料，没有提到的地方，导致我白白浪费掉了一个小时的时间，哎~自学最大的难处就在这里。以上，设置好之后，会发现你的路径方式变了12origin https://github.com/ChangerHe/My-code (fetch)origin https://github.com/ChangerHe/My-code (push) 此时即配置成功，现在就可以开心地不用密码进行push啦。","categories":[{"name":"GitHub 优化","slug":"GitHub-优化","permalink":"https://github.com/ChangerHe/categories/GitHub-优化/"}],"tags":[{"name":"GitHub","slug":"GitHub","permalink":"https://github.com/ChangerHe/tags/GitHub/"}]},{"title":"使用Canvas绘制七巧板","slug":"使用Canvas绘制七巧板","date":"2017-06-14T14:16:09.000Z","updated":"2017-09-14T15:03:01.378Z","comments":true,"path":"2017/06/14/使用Canvas绘制七巧板/","link":"","permalink":"https://github.com/ChangerHe/2017/06/14/使用Canvas绘制七巧板/","excerpt":"","text":"中午登上慕课网，偶然发现慕课网改版了，这倒是其次，惊奇的是页面居然出现了不显示我的观看记录和观看百分比的BUG！还准备说要给慕课网反馈一下来着，晚上一登，居然修复了，不得不佩服慕课网工程师们惊人的处突能力啊。 回到正题，相信大家都见到过七巧板，本文使用简单的HTML5新特性Canvas的2d图形绘制功能，绘制了一个简单的七巧板。 Canvas是HTML5的新特性，相比于其他的HTML标签来说，Canvas给前端工程师们提供了更多的操作可能性，也为页面的生动化效果做出了不菲的贡献。canvas的3d绘图的出现，加上JS对HTML页面的强大动态渲染能力，加上各大浏览器厂商对于Flash的抛弃，相信日后canvas将在HTML页面展示，HTML游戏，HTML动画上大有可为。 canvas的2d绘图非常简单，整体的操作感觉非常的人性化，主要是要区分，移动到点位（moveTo）和划线到点位（lineTo）的区别，canvas对于页面的色彩和轮廓方面也加入了相应的边框（stroke）和填充（fill）功能，下面让我们一起来看一下七巧板的canvas实现吧。 HTML方面这块我就写了一个canvas的标签，同时制定它的宽高等属性，有一点要注意，其宽高最好不要使用px作为单位，而是使用默认值作为单位（简单点说就是不要写宽高的单位），否则在后期绘图会出现绘图区的一些问题。 1&lt;canvas id=&quot;canvas&quot; width=&quot;800&quot; height=&quot;800&quot; style=&quot;border: 1px solid #eee&quot;&gt;Your broser can&apos;t support canvas&lt;/canvas&gt; JS方面学过canvas的同学肯定知道，2d绘图简直就是小儿科，用来用去也就那么几个API，照本宣科就是了。 123456789101112131415161718192021222324var canvas = document.getElementById(&quot;canvas&quot;);var context = canvas.getContext(&quot;2d&quot;);var arr = [ &#123;position: [&#123;x: 0,y: 0&#125;,&#123;x: 400,y: 400&#125;,&#123;x: 800,y: 0&#125;,&#123;x: 0,y: 0&#125;],color: &quot;#caff67&quot;&#125;, &#123;position: [&#123;x: 0,y: 0&#125;,&#123;x: 400,y: 400&#125;,&#123;x: 0,y: 800&#125;,&#123;x: 0,y: 0&#125;],color: &quot;#67becf&quot;&#125;, &#123;position: [&#123;x: 0,y: 800&#125;,&#123;x: 400,y: 400&#125;,&#123;x: 800,y: 800&#125;,&#123;x: 0,y: 800&#125;],color: &quot;#ef3d61&quot;&#125;, &#123;position: [&#123;x: 400,y: 400&#125;,&#123;x: 800,y: 400&#125;,&#123;x: 600,y: 600&#125;,&#123;x: 400,y: 400&#125;],color: &quot;#f9f51a&quot;&#125;, &#123;position: [&#123;x: 400,y: 400&#125;,&#123;x: 800,y: 400&#125;,&#123;x: 800,y: 0&#125;,&#123;x: 400,y: 400&#125;],color: &quot;#a594c0&quot;&#125;, &#123;position: [&#123;x: 600,y: 600&#125;,&#123;x: 800,y: 600&#125;,&#123;x: 800,y: 400&#125;,&#123;x: 600,y: 600&#125;],color: &quot;#fa8ecc&quot;&#125;, &#123;position: [&#123;x: 600,y: 600&#125;,&#123;x: 800,y: 600&#125;,&#123;x: 800,y: 800&#125;,&#123;x: 600,y: 600&#125;],color: &quot;#caff67&quot;&#125;];console.log(arr[0].color)for( var i = 0; i &lt; arr.length; i++) &#123; context.beginPath(); context.moveTo(arr[i].position[0].x,arr[i].position[0].y); for( var j = 1; j &lt; arr[i].position.length; j++) &#123; context.lineTo(arr[i].position[j].x,arr[i].position[j].y); &#125; context.closePath(); context.lineWidth = &quot;2&quot;; context.stroke(); context.fillStyle = arr[i].color; context.fill();&#125; 代码为以上，欢迎批评指正。","categories":[{"name":"Canvas学习笔记","slug":"Canvas学习笔记","permalink":"https://github.com/ChangerHe/categories/Canvas学习笔记/"}],"tags":[{"name":"Canvas学习笔记","slug":"Canvas学习笔记","permalink":"https://github.com/ChangerHe/tags/Canvas学习笔记/"}]},{"title":"JavaScript计时器的优化","slug":"JavaScript计时器的优化","date":"2017-06-14T14:16:09.000Z","updated":"2017-09-14T15:02:44.752Z","comments":true,"path":"2017/06/14/JavaScript计时器的优化/","link":"","permalink":"https://github.com/ChangerHe/2017/06/14/JavaScript计时器的优化/","excerpt":"","text":"首先，要对我的脑子进行严格而深刻的批判，写个简单的计时器，花了一个小时的时间才写完。 “脑子是个好东西，我希望我自己也能有一个。” ——某位将要成为前端大佬的菜鸟如是说 情况分析：在HTML文件中写入相应的代码，实现计时效果，因此需要用到定时器，代码如下，我是将代码直接写在timer中了：12345678910111213141516171819setInterval(function timtSetter()&#123; s++; var S,m,M,h,H; S = s % 60; m = Math.floor(s/60); M = m % 60; h = Math.floor(m/60); H = h % 24; if( S &lt; 10)&#123; S = &quot;0&quot; + S; &#125; if( M &lt; 10)&#123; M = &quot;0&quot; + M; &#125; if( H &lt; 10)&#123; H = &quot;0&quot; + H; &#125; timer.innerHTML = H + &quot;:&quot; + M + &quot;:&quot; + S;&#125;,1000);","categories":[{"name":"JavaScript 学习笔记","slug":"JavaScript-学习笔记","permalink":"https://github.com/ChangerHe/categories/JavaScript-学习笔记/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://github.com/ChangerHe/tags/JavaScript/"}]},{"title":"在GitHub账户中搭建静态博客的同时另开一个代码展示页面的方法","slug":"在GitHub账户中搭建静态博客的同时另开一个代码展示页面的方法","date":"2017-06-14T14:16:09.000Z","updated":"2017-09-14T15:01:34.754Z","comments":true,"path":"2017/06/14/在GitHub账户中搭建静态博客的同时另开一个代码展示页面的方法/","link":"","permalink":"https://github.com/ChangerHe/2017/06/14/在GitHub账户中搭建静态博客的同时另开一个代码展示页面的方法/","excerpt":"","text":"无意间想尝试了一下GitHub在我创建了hexo博客之后，使用另一个仓库进行搭建自己的代码展示页面的事情，凑巧，被我还试成功了，操作的方式很简单。拿出来分享一下： 1.和之前一样，新建一个仓库 2.为自己的仓库命名，并确定 3.回到你的个人情况页，并进入到你新建的仓库中 4.点击该仓库的设置setings，然后往下拉，找到github pages 5.进行如下设定：select branch，设置为你的第一个，当然，如果你刚设置好这个仓库，还没有往里放东西的话，这个选项是灰色的，这个时候你可以使用gitbash或者github客户端把这个页面git clone下来到自己的本地仓库。提交一些东西上去就可以显示了。 6.选择好之后，有没有看到一个小提示：Your site is published at XXX?那么好，你的代码展示页面就做好啦，那么现在就可以开心的上传自己做的东西了，当然，我在自己操作的时候遇到了一个坑，就是自己网页域名的坑，是这样子的，比如，我的网站1Your site is published at https://changerhe.github.io/demo-show/ 那么你要进入到自己的代码页面的话，就要在后面加上你传的文件的路径，就可以正常浏览这个代码了，比如我上传了修真院的任务七文件夹，文件夹中有一个index.html是我的demo页面，那么我的网页路径应该是这样的： 1https://changerhe.github.io/demo-show/ITxiuzhenyuan-Mission7/index.html 好，大功告成！","categories":[{"name":"GitHub 优化","slug":"GitHub-优化","permalink":"https://github.com/ChangerHe/categories/GitHub-优化/"}],"tags":[{"name":"GitHub","slug":"GitHub","permalink":"https://github.com/ChangerHe/tags/GitHub/"}]},{"title":"CSS样式书写规范","slug":"CSS样式书写规范","date":"2017-06-14T14:16:09.000Z","updated":"2017-09-14T15:02:50.972Z","comments":true,"path":"2017/06/14/CSS样式书写规范/","link":"","permalink":"https://github.com/ChangerHe/2017/06/14/CSS样式书写规范/","excerpt":"","text":"(以下文章转载自伯乐在线,仅供以后方便查阅使用)可能不同团队都有各自的规范，又或者很多人在写 CSS 的时候还是想到什么就写什么，不存在太多的约束。 我觉得 CSS 代码规范还是有存在的必要的，尤其是在团队配合，多人协作下，规范就显得尤为重要。 本文的所列是实践当中得出的一套比较不错的 CSS 书写规范，并不希望大家完全采用，而是希望可以结合自己的团队需要，发展出一套适合自己的 CSS 代码规范。 不同的规范都有各自的长处与缺陷，对待所谓的规范最好的方式不是人云亦云，拿来就用，而是应该结合实际情况及需求，取长补短，取其精华去其糟粕。 编码设置采用 UTF-8 编码，在 CSS 代码头部使用： 1@charset &quot;utf-8&quot;; 注意，必须要定义在 CSS 文件所有字符的前面（包括编码注释），@charset 才会生效。 例如，下面的例子都会使得 @charset 失效： 12345678/* 字符编码 */@charset &quot;utf-8&quot;;html,body &#123; height: 100%;&#125; @charset &quot;utf-8&quot;; 命名空间规范 布局：以 g 为命名空间，例如：.g-wrap 、.g-header、.g-content。状态：以 s 为命名空间，表示动态的、具有交互性质的状态，例如：.s-current、s-selected。 工具：以 u 为命名空间，表示不耦合业务逻辑的、可复用的的工具，例如：u-clearfix、u-ellipsis。 组件：以 m 为命名空间，表示可复用、移植的组件模块，例如：m-slider、m-dropMenu。 钩子：以 j 为命名空间，表示特定给 JavaScript 调用的类名，例如：j-request、j-open。 命名空间思想没有选择 BEM 这种命名过于严苛及样式名过长过丑的规则，采取了一种比较折中的方案。 不建议使用下划线 _ 进行连接 节省操作，输入的时候少按一个 shift 键 能良好区分 JavaScript 变量命名 字符小写定义的选择器名，属性及属性值的书写皆为小写。 选择器当一个规则包含多个选择器时，每个选择器独占一行。 、+、~、&gt; 选择器的两边各保留一个空格。 .g-header &gt; .g-header-des,.g-content ~ .g-footer { } 命名短且语义化良好 对于选择器的命名，尽量简洁且具有语义化，不应该出现 g-abc 这种语义模糊的命名。 规则声明块 当规则声明块中有多个样式声明时，每条样式独占一行。 在规则声明块的左大括号 { 前加一个空格。 在样式属性的冒号 : 后面加上一个空格，前面不加空格。 在每条样式后面都以分号 ; 结尾。 规则声明块的右大括号 } 独占一行。 每个规则声明间用空行分隔。 所有最外层引号使用单引号 ‘ 。 当一个属性有多个属性值时，以逗号 , 分隔属性值，每个逗号后添加一个空格，当单个属性值过长时，每个属性值独占一行。 完整示例如下： 12345678910111213141516.g-footer,.g-header &#123; position: relative;&#125; .g-content &#123; background: linear-gradient(135deg, deeppink 25%, transparent 25%) -50px 0, linear-gradient(225deg, deeppink 25%, transparent 25%) -50px 0, linear-gradient(315deg, deeppink 25%, transparent 25%), linear-gradient(45deg, deeppink 25%, transparent 25%); &#125; .g-content::before &#123; content: &apos;&apos;;&#125; 数值与单位 当属性值或颜色参数为 0 – 1 之间的数时，省略小数点前的 0 。color: rgba(255, 255, 255, 0.5)color: rgba(255, 255, 255, .5); 当长度值为 0 时省略单位。margin: 0px automargin: 0 auto 十六进制的颜色属性值使用小写和尽量简写。color: #ffcc00color: #fc0 样式属性顺序单个样式规则下的属性在书写时，应按功能进行分组，并以 Positioning Model &gt; Box Model &gt; Typographic &gt; Visual 的顺序书写，提高代码的可读性。 如果包含 content 属性，应放在最前面；Positioning Model 布局方式、位置，相关属性包括：position / top / right / bottom / left / z-index / display / float / … Box Model 盒模型，相关属性包括：width / height / padding / margin / border / overflow / … Typographic 文本排版，相关属性包括：font / line-height / text-align / word-wrap / … Visual 视觉外观，相关属性包括：color / background / list-style / transform / animation / transition / … Positioning 处在第一位，因为他可以使一个元素脱离正常文本流，并且覆盖盒模型相关的样式。盒模型紧跟其后，因为他决定了一个组件的大小和位置。其他属性只在组件内部起作用或者不会对前面两种情况的结果产生影响，所以他们排在后面。 合理使用使用引号在某些样式中，会出现一些含有空格的关键字或者中文关键字。 font-family 内使用引号 当字体名字中间有空格，中文名字体及 Unicode 字符编码表示的中文字体，为了保证兼容性，都建议在字体两端添加单引号或者双引号： 123body &#123; font-family: &apos;Microsoft YaHei&apos;, &apos;黑体-简&apos;, &apos;\\5b8b\\4f53&apos;;&#125; background-image 的 url 内使用引号 如果路径里面有空格，旧版 IE 是无法识别的，会导致路径失效，建议不管是否存在空格，都添加上单引号或者双引号： 123div &#123; background-image: url(&apos;...&apos;);&#125; 避免使用 !important除去某些极特殊的情况，尽量不要不要使用 !important。 !important 的存在会给后期维护以及多人协作带来噩梦般的影响。 当存在样式覆盖层叠时，如果你发现新定义的一个样式无法覆盖一个旧的样式，只有加上 !important 才能生效时，是因为你新定义的选择器的优先级不够旧样式选择器的优先级高。所以，合理的书写新样式选择器，是完全可以规避一些看似需要使用 !important 的情况的。 代码注释单行注释星号与内容之间必须保留一个空格。 多行注释星号要一列对齐，星号与内容之间必须保留一个空格。 规则声明块内注释使用 // 注释，// 后面加上一个空格，注释独立一行。 文件注释文件顶部必须包含文件注释，用 @name 标识文件说明。星号要一列对齐，星号与内容之间必须保留一个空格，标识符冒号与内容之间必须保留一个空格。 123456789/*** @name: 文件名或模块名* @description: 文件或模块描述* @author: author-name(mail-name@domain.com)* author-name2(mail-name2@domain.com)* @update: 2015-04-29 00:02*///@description为文件或模块描述。//@update为可选项，建议每次改动都更新一下。 当该业务项目主要由固定的一个或多个人负责时，需要添加@author标识，一方面是尊重劳动成果，另一方面方便在需要时快速定位责任人。 SASS 使用建议嵌套层级规定使用 SASS 、 LESS 等预处理器时，建议嵌套层级不超过 3 层。 组件/公用类的使用方法组件/公用类使用 %placeholders 定义，使用 @extend 引用。如： 123456789%clearfix &#123; overflow: auto; zoom: 1;&#125; .g-header &#123; @extend %clearfix;&#125; 组件类的思考使用 SASS ，经常会预先定义好一些常用公用组件类，譬如清除浮动，水平垂直居中，文字 ellipsis。又或者多个元素具有同样的样式，我们希望能够少写这部分代码，公共部分抽离出来只写一次，达到复用。 但是复用的方式在 SASS 中有多种，那么是使用单独使用一个类定义，给需要的标签添加，还是使用 @include 或者 @extend在定义的类中引入一个 @mixin，或者一个 @function 呢？ 基于让 CSS 更简洁以及代码的复用考虑，采用上面的使用 %placeholders 定义，使用 @extend 引用的方案。 %placeholders，只是一个占位符，只要不通过 @extend 调用，编译后不会产生任何代码量 使用 @extend 引用，则是因为每次调用相同的 %placeholders 时，编译出来相同的 CSS 样式会进行合并（反之，如果使用 @include 调用定义好的 @mixin，编译出来相同的 CSS 样式不会进行合并） 这里的组件类特指那些不会动态改变的 CSS 样式，注意与那些可以通过传参生成不同数值样式的 @mixin 方法进行区分 尽量避免使用标签名使用 SASS ，或者说在 CSS 里也有这种困惑。 假设我们有如下 html 结构： 12345678&lt;span&gt; &lt;div class=&quot;g-content&quot;&gt; &lt;ul class=&quot;g-content-list&quot;&gt;&lt;li class=&quot;item&quot;/&gt; &lt;li class=&quot;item&quot;/&gt; &lt;li class=&quot;item&quot;/&gt; &lt;li class=&quot;item&quot;/&gt; &lt;/ul&gt;&lt;/div&gt;&lt;/span&gt; 在给最里层的标签命名书写样式的时候，我们有两种选择： 1234567.g-content &#123; .g-content-list &#123; li &#123; ... &#125; &#125;&#125; 或者是 1234567.g-content &#123; .g-content-list &#123; .item &#123; ... &#125; &#125;&#125; 也就是，编译之后生成了下面这两个，到底使用哪个好呢？ .g-content .g-content-list li { } .g-content .g-content-list .item { } 基于 CSS 选择器的解析规则（从右向左），建议使用上述第二种 .g-content .g-content-list .item { } ，避免使用通用标签名作为选择器的一环可以提高 CSS 匹配性能。 浏览器的排版引擎解析 CSS 是基于从右向左（right-to-left）的规则，这么做是为了使样式规则能够更快地与渲染树上的节点匹配。","categories":[{"name":"HTML & CSS 学习笔记","slug":"HTML-CSS-学习笔记","permalink":"https://github.com/ChangerHe/categories/HTML-CSS-学习笔记/"}],"tags":[{"name":"CSS样式书写规范","slug":"CSS样式书写规范","permalink":"https://github.com/ChangerHe/tags/CSS样式书写规范/"}]},{"title":"JavaScript 和 JAVA 在数据类型方面的异同","slug":"The-Data-Type-Differences-of-JavaScript-and-Java","date":"2017-06-14T14:16:09.000Z","updated":"2017-09-14T15:01:07.784Z","comments":true,"path":"2017/06/14/The-Data-Type-Differences-of-JavaScript-and-Java/","link":"","permalink":"https://github.com/ChangerHe/2017/06/14/The-Data-Type-Differences-of-JavaScript-and-Java/","excerpt":"","text":"今天是开始学习JAVA的第一天，对照着教程敲了一遍代码，配置了一下JAVA的运行环境，不知不觉一天就这样过去了，反倒是真正花在了解JAVA这门语言上面的时间却少了些。初了解了JAVA数据类型的知识，发现确实是和之前学习的C++,JavaScript（之后统一称JS）有异曲同工之妙，但是相比于JS来说，个人认为Java的数据结构及类型配置是更加严谨的，毕竟James Gosling 大大花了几年时间开发出了这门语言。而JavaScript这门语言由 Brendan Eich 花了十天就设计出来了，哈哈哈哈哈哈哈不得不佩服这些大大大佬们。 变量初始化问题当我使用JS时，定义变量但不给其赋值，可输出undefined1234&lt;script&gt; var a; console.log(a); //a&lt;/script&gt; 但是当我使用Java时，未给其定义时，将会在编译时直接报错，无法正常完成编译操作。12345678public class example&#123; public static void main(String[] args) &#123; int a; System. out. println(a); //错误 &#125;&#125; 变量的定义JS中，如果对变量定义的话，会有全局变量和局部变量之分。Java中也是一样，这是他们的相同之处。但是我们来看这样一个例子：12345&lt;script&gt; var a = 2; var a = 3; console.log(a); //3&lt;/script&gt; 这是使用JS进行输出的结果，JS正常输出3，我们再看在Java中的输出结果：123456789public class example&#123; public static void main(String[] args) &#123; int a = 2; int a = 3; System. out. println(a); //错误 &#125;&#125; 在重复定义了其局部变量的情况下，JAVA仍旧会报错。不仅仅是这样，还有：123456789public class example&#123; int a = 2; public static void main(String[] args) &#123; System. out. println(a); //错误 &#125;&#125; 这是个什么鬼，作为一个学了JS的小朋友不淡定了，我明明在全局中定义了a的值了呀，为什么还会报错，原来是少了样东西：需要在对a进行定义时加上static，具体个中原因，查了资料，资料是这样写的：1产生此现象的原因是无法从静态上下文中引用非静态变量，因为main方法是static的,如果想用main方法直接去调用方法或者属性的话必须是static的。当然,如果实例化出一个对象的话,那么定义的变量就可以不是static的。 也就是说，对于这种情况，有两种解决方案： 方案1123456public class Test&#123; static int i; public static void main(String[] args)&#123; System.out.println(i); &#125;&#125; 方案2123456public class Test&#123; int i; public static void main(String[] args)&#123; System.out.println(new Test().i); &#125;&#125; 因为new了一个Test类的实例,所以可以直接去调用Test的属性跟方法。 数据运算JS中的加法有一个很好玩的地方，我们来看一下：12345&lt;script&gt; var a = 0.1; var b = 0.2; console.log(a + b); //0.30000000000000004&lt;/script&gt; 但是笔者在JAVA中亲测，也是一模一样啊有木有（当然，这个时候JAVA就要改一下数据类型了，这个在JS中是不需要的）：12345678910public class example&#123; static double a = 0.1D; static double b = 0.2D; public static void main(String[] args) &#123; System. out. println(a + b); //0.30000000000000004 &#125;&#125; 对于这种现象，网上的大神们的解释是这样子的：123456789101112131415十进制0.1=&gt; 二进制0.00011001100110011…(循环0011) =&gt;尾数为1.1001100110011001100…1100（共52位，除了小数点左边的1），指数为-4（二进制移码为00000000010）,符号位为0=&gt; 计算机存储为：0 00000000100 10011001100110011…11001=&gt; 因为尾数最多52位，所以实际存储的值为0.00011001100110011001100110011001100110011001100110011001而十进制0.2=&gt; 二进制0.0011001100110011…(循环0011)=&gt;尾数为1.1001100110011001100…1100（共52位，除了小数点左边的1），指数为-3（二进制移码为00000000011）,符号位为0=&gt; 存储为：0 00000000011 10011001100110011…11001因为尾数最多52位，所以实际存储的值为0.00110011001100110011001100110011001100110011001100110011 那么两者相加得： 0.00011001100110011001100110011001100110011001100110011001+ 0.00110011001100110011001100110011001100110011001100110011 = 0.01001100110011001100110011001100110011001100110011001100转换成10进制之后得到:0.30000000000000004” 简单来讲，还是单精度和双精度浮点运算时的误差了，不过当我把两数据设置为单精度float数时，此现象就没有了。12345678910public class example&#123; static float a = 0.1f; static float b = 0.2f; public static void main(String[] args) &#123; System. out. println(a + b); //0.3 &#125;&#125; 充分证明了 卧槽我想说证明了什么？ 反正不懂，先记着吧，反正是菜鸟~","categories":[{"name":"JAVA 学习笔记","slug":"JAVA-学习笔记","permalink":"https://github.com/ChangerHe/categories/JAVA-学习笔记/"}],"tags":[{"name":"JAVA & JavaScript","slug":"JAVA-JavaScript","permalink":"https://github.com/ChangerHe/tags/JAVA-JavaScript/"}]},{"title":"基本算法的JavaScript实现","slug":"基本算法的JavaScript实现","date":"2017-06-14T14:16:09.000Z","updated":"2017-09-14T15:02:38.816Z","comments":true,"path":"2017/06/14/基本算法的JavaScript实现/","link":"","permalink":"https://github.com/ChangerHe/2017/06/14/基本算法的JavaScript实现/","excerpt":"","text":"也算是一时兴起，对着手机拾掇了一早上，实现了一些简单的排序算法。 冒泡排序这个不必多说，最经典的排序算法之一，下面我也是用的最经典的解决方案，同时对算法进行了优化，减少了不必要的比较次数。冒泡排序在嵌套循环都为数组长度的话，这个时候的循环最多次数是N的平方，但是用以下的算法，比较的次数可以减少一半。12345678910111213141516function bubbleSort(arr)&#123; console.time(&apos;冒泡排序耗时&apos;) var len = arr.length; //定义冒泡排序的数组长度 var n; //定义n用于在冒泡排序时进行位置调换 for (var i = 0; i &lt; len-1; i++) &#123; //外层循环，使冒泡排序循环数组长度 for (var j = 0; j &lt; len-i-1; j++) &#123; if (arr[j] &gt; arr[j+1]) &#123; n = arr[j]; arr[j] = arr[j+1]; arr[j+1] = n; &#125; &#125; &#125; console.timeEnd(&apos;冒泡排序耗时&apos;)&#125; 冒泡排序的经典算法经过我自己思考优化后，其实还存在一个多次比较的问题，在网上查了些资料，大佬们给出了另一种算法，主要的优化点在于，记录上要调换的位置，然后从要调换的位置开始进行调换，调换之后，再对剩余的地方进行调换。无疑减少了在一个不需要调换的位置进行多次比较的次数。1234567891011121314151617181920function betterBubbleSort(arr)&#123; console.time(&apos;改进后冒泡排序耗时&apos;) var i = arr.length-1; //定义i为数组的最后一位数 var n; //n作为中间值，用于进行数组调换 while(i &gt; 0)&#123; var pos = 0; //记录需要调换的位置 for(var j = 0; j &lt; i; j++)&#123; // if (arr[j] &gt; arr[j+1]) &#123; pos = j; n = arr[j]; arr[j] = arr[j+1]; arr[j+1] = n; &#125; &#125; i = pos; &#125; console.timeEnd(&apos;改进后冒泡排序耗时&apos;) return arr;&#125; 以上算法对于计算次数已经有了较多的优化了，计算次数显然已经不能再往下优化，但是还有一点就是，我们能否进行多线程的计算，从而缩短整体的计算时间呢？1234567891011121314151617181920212223242526function bestBubbleSort(arr)&#123; console.time(&apos;改进后冒泡排序耗时&apos;) var low = 0; var high = arr.length -1; var tmp,j; while(low &lt; high)&#123; for(j = low; j &lt; high; ++j)&#123; if( arr[j] &gt; arr[j+1])&#123; tmp = arr[j]; arr[j] = arr[j+1]; arr[j+1] = tmp; &#125; &#125; --high; for(j = high; j &gt; low; --j)&#123; if( arr[j] &lt; arr[j-1])&#123; tmp = arr[j]; arr[j] = arr[j-1]; arr[j-1] = tmp; &#125; &#125; ++low; &#125; console.timeEnd(&apos;改进后冒泡排序耗时&apos;) return arr;&#125; 选择排序的算法选择排序是先在数组中进行查找而不调换位置，找到数组中最小数之后，将最小数放到数组的第一个位置，然后再次寻找第二个数。这样做的好处就是，相比于冒泡排序，大大减少了两个数组元素调换位置所产生的内存消耗和计算量。12345678910111213141516171819202122function selectionSort(arr)&#123; var len = arr.length-1; //定义数组的长度，并赋值给len console.time(&apos;选择排序耗时&apos;); //设置计时开始 var minindex,temp; for (var i = 0; i &lt; len; i++) &#123; minindex = i; //设置最小数组下标为minindex，将i赋值给minindex for( var j = i; j &lt; len; j++)&#123; //设置循环，循环区间为最小值到最后一位数 if (arr[j] &lt; arr[minindex]) &#123; //若某数小于第minindex个数组的值，就把它赋值给minindex minindex = j; &#125; &#125; //进行最小值与需要调换值的数组下标调换 temp = arr[i]; arr[i] = arr[minindex]; arr[minindex] = temp; &#125; console.timeEnd(&apos;选择排序耗时&apos;); return arr;&#125; 插入排序算法插入排序即是将需要排序的数组中的元素，逐次插入，以达到排序的效果，亲测此方法比上面的两个方法所耗时间都要短。1234567891011121314function insertionSort(arr)&#123; console.time(&apos;插入排序耗时&apos;); //设置计时开始 for( var i = 1; i &lt; arr.length; i++)&#123; var key = arr[i]; var j = i - 1; while(j &gt;= 0 &amp;&amp; arr[j] &gt; key)&#123; arr[j+1] = arr[j]; j--; &#125; arr[j+1] = key; &#125; console.timeEnd(&apos;插入排序耗时&apos;); //设置计时开始 return arr;&#125; 排序算法耗时汇总冒泡排序三个方法在随机生成10000个数并对其进行排序的计算中，均耗时约300ms，选择排序和插入排序则耗时较短些，选择排序耗时约200ms左右，插入排序可达到低于200ms。 JS内核的自带排序算法不多说了，就是这个sort()方法，简直想给它跪舔！同样用10000个随机生成的0-100的数，对其进行排序，其计算时间竟然能缩短到逆天的15ms！但是并没有办法详细了解其深层次的原因，听说是因为V8引擎的优化，和基于C++的算法优化所产生的效果。","categories":[{"name":"JavaScript 学习笔记","slug":"JavaScript-学习笔记","permalink":"https://github.com/ChangerHe/categories/JavaScript-学习笔记/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://github.com/ChangerHe/tags/JavaScript/"}]},{"title":"实现某节点子节点的倒序排列","slug":"实现某节点子节点的倒序排列","date":"2017-06-14T14:16:09.000Z","updated":"2017-09-14T15:03:17.517Z","comments":true,"path":"2017/06/14/实现某节点子节点的倒序排列/","link":"","permalink":"https://github.com/ChangerHe/2017/06/14/实现某节点子节点的倒序排列/","excerpt":"","text":"文章主要是对于一个很容易被忽略的知识点:createDocumentFragment()方法的一个复习,并给大家解锁一个解决给某个标签动态改变其子节点顺序的新姿势. 首先,documentFragment是一个很早之前就被广泛支持的方法,所以犀牛书上面所提供的为element对象增加一个原型方法insertAdjacentHTML()的兼容性写法,大家可以无视了,因为IE7-IE9都亲测完美支持.当然,如果你想碰IE6,就当我没说. 关于性能其实createDocumentFragment()这个方法创建的目的,就是把它当做一个特殊的node,作为其他节点的一个临时的容器. 也就是说,当我们需要使用JS为某标签动态插入较多的子节点的时候,我们可以将需要插入的节点组成一个节点树.然后在插入的时候直接把这个节点树一次性插入到文档流中. 相比于每生成一次节点之后马上插入文档流的做法来说,使用createDocumentFragment()方法可以大大减少浏览器的重绘次数,从而能够提升性能.(每当我们进行动态插入节点的时候,都会引起浏览器的一次重绘操作) 有一点要特别注意的是,IE浏览器是例外的,因为IE浏览器的特殊性,导致当我们使用createDocumentFragment()方法进行动态插入时,反倒会降低浏览器的性能. 某节点子节点的倒序排列的JS实现了解到createDocumentFragment()这个方法其实这个问题就很简单了.先将源文档的lastChild逐个插入到createDocumentFragment()的节点树中即可. 12345678function reverse(n)&#123; var f = document.createDocumentFragment(); var a = n.childNodes.length for (var i = 0; i &lt; a; i++) &#123; f.appendChild(n.lastChild) &#125; console.log(f)&#125; 有一点需要大家特别注意的是,当我们不使用a这个局部变量而是直接使用n.childNodes.length,每次for循环都进行重新判定的时候,会发生神奇的现象.n.childNodes.length会离奇般的消失了一半. 其实了解现代浏览器的childNodes.length判定机制的同学都会知道,当我们对文档流进行childNodes判定的时候,其实其子标签两边的空格和回车也是会作为文本节点被算进childNodes.length里面的. 12345678&lt;ul id=&quot;aUl&quot;&gt; &lt;li&gt;1111&lt;/li&gt; &lt;li&gt;2222&lt;/li&gt; &lt;li&gt;3333&lt;/li&gt; &lt;li&gt;4444&lt;/li&gt; &lt;li&gt;5555&lt;/li&gt; &lt;/ul&gt;//当我们打印aUl中的子节点的长度时候,判定结果是11.(IE老版本会出现仅显示长度为5的问题,后面已经更正) 说到这里其实刚刚说的神奇的现象就很好解释了,因为我们从后面开始进行移动元素”空白文本节点”及li标签的时候,它们的空白节点会动态消失.所以我们使用for循环每次进行判定该文档的长度的时候,以上面的文档结构为例,判定长度为11,但实际上循环次数仅5次. 这个坑很好的教了我们,要将长度判定等拿到for循环外面的重要性啊,不仅能提升性能,还能避免踩坑… 以上.","categories":[{"name":"JavaScript 学习笔记","slug":"JavaScript-学习笔记","permalink":"https://github.com/ChangerHe/categories/JavaScript-学习笔记/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://github.com/ChangerHe/tags/JavaScript/"}]},{"title":"接口和抽象类的区别","slug":"接口和抽象类的区别","date":"2017-06-14T14:16:09.000Z","updated":"2017-09-14T15:03:34.820Z","comments":true,"path":"2017/06/14/接口和抽象类的区别/","link":"","permalink":"https://github.com/ChangerHe/2017/06/14/接口和抽象类的区别/","excerpt":"","text":"接口（interface）和抽象类（abstract）的区别相同点1.都位于继承的顶端用于被其他类实现或继承。2.都不能实例化。3.都可以定义抽象方法，其子类都必须参与这些方法。 不同点1.接口没有构造方法，抽象有构造方法。2.抽象类可包含抽象方法和普通方法，接口只能包含抽象方法。3.一个类只能继承一个直接父类，却可以实现多个接口。4.接口里默认是public static final,抽象类型默认是包访问。5.方法：接口里默认是public abstract,抽象类型是包访问。6.内部类：接口里默认是public static,抽象类型是包访问。","categories":[{"name":"JAVA 学习笔记","slug":"JAVA-学习笔记","permalink":"https://github.com/ChangerHe/categories/JAVA-学习笔记/"}],"tags":[{"name":"JAVA","slug":"JAVA","permalink":"https://github.com/ChangerHe/tags/JAVA/"}]},{"title":"杨辉三角的JAVA实现","slug":"杨辉三角的JAVA实现","date":"2017-06-14T14:16:09.000Z","updated":"2017-09-14T15:01:19.437Z","comments":true,"path":"2017/06/14/杨辉三角的JAVA实现/","link":"","permalink":"https://github.com/ChangerHe/2017/06/14/杨辉三角的JAVA实现/","excerpt":"","text":"杨辉三角，是二项式系数在三角形中的一种几何排列。在欧洲，这个表叫做帕斯卡三角形。帕斯卡（1623—-1662）是在1654年发现这一规律的，比杨辉要迟393年，比贾宪迟600年。没有参考网上的代码，自己手撸了一遍杨辉三角。主要依据是根据杨辉三角的特性，行数等于列数乘二加一。输入想要得到的杨辉三角层数，即可得到相应的杨辉三角数字列表。中间的空格直接使用0来表示了，所以感觉我的代码比网上的很多代码简洁了很多：12345678910111213141516171819202122232425262728293031//杨辉三角的JAVA实现class YangHuiSanJiao&#123; static void putIn(int m)&#123; int n = m*2-1; //根据杨辉三角特性，行数等于列数乘二加一 int[][] arr = new int[m][n]; //新建数组 arr[0][m-1] = 1; for ( int i = 0; i &lt; m-2 ; i++ ) &#123; for ( int j = 0; j &lt; n-2 ; j++ ) &#123; arr[i+1][j+1] = arr[i][j] + arr[i][j+2]; //将当列的第J个数和第J+2个数，赋值给下一列的J+1个数（因为i和j初始为0） &#125; &#125; for (int i = 0; i &lt; m-1 ; i++ ) &#123; for (int j = 0; j &lt; n ; j++ ) &#123; System.out.print(arr[i][j]+ &quot;\\t&quot;); //遍历数组，将值逐一打印 &#125; System.out.println(); //打印换行 &#125; &#125; public static void main(String[] args) &#123; putIn(10); //输入想要得到的杨辉三角层数 &#125;&#125; 因为其实可以把整个数组进行遍历，然后通过强制类型转换将0转为空格的，这个还没转。代码以上。","categories":[{"name":"JAVA 学习笔记","slug":"JAVA-学习笔记","permalink":"https://github.com/ChangerHe/categories/JAVA-学习笔记/"}],"tags":[{"name":"JAVA","slug":"JAVA","permalink":"https://github.com/ChangerHe/tags/JAVA/"}]},{"title":"阿里妈妈iconfont矢量图标字体的用法","slug":"The-Usages-Of-Iconfont","date":"2017-06-14T14:16:09.000Z","updated":"2017-09-14T15:01:11.461Z","comments":true,"path":"2017/06/14/The-Usages-Of-Iconfont/","link":"","permalink":"https://github.com/ChangerHe/2017/06/14/The-Usages-Of-Iconfont/","excerpt":"","text":"Iconfont是什么？iconfont是由阿里妈妈出品，国内射鸡师妹妹和前端小哥哥/小姐姐们常去的学（gao）习（ji）网站，网站上面都是一些“高清无码”的矢量图标，相比于使用单一的小png和使用spirit来说大大减少了与服务器握手次数，可以提升网页打开效率。 Iconfont使用方法1.我们先一起打开这个国内打大型同性交友网站http://www.iconfont.cn ，然后点击“图标库”，可以使用自己的github登陆，登陆后就可以根据自己的需要进行查找图标，海量图标等你约哟。2.将需要的图标添加到购物车形状里面，也就是放到自己的库里，没有库的自己可以随便创建一个项目库。3.添加好之后，会出现下面这个样子，此时选好之后，就可以下载至本地，不建议直接使用在线使用的办法，亲测没有效，而且浏览器请求时间太长。4.下好之后，需要将一行代码放到css文件中，也就是下下来的iconfont.css这个文件，或者直接在自己的项目html中引用这个css，但不建议这样做，会增加服务器请求次数。5.大胆的使用这些图标吧，使用方法就是直接自己的标签中加class=“iconfont”再加上对应图标的class就可以啦（对应的图标class在iconfont.css中，参考上图）。 有一点要切记！图标的文件要放在与自己的css文件一起的文件夹中！否则图标显示不成功！6.具体上面的iconfont.css代码干嘛用的，请参考慕课网，我这里就不详细讲了。","categories":[{"name":"HTML & CSS 学习笔记","slug":"HTML-CSS-学习笔记","permalink":"https://github.com/ChangerHe/categories/HTML-CSS-学习笔记/"}],"tags":[{"name":"HTML & CSS","slug":"HTML-CSS","permalink":"https://github.com/ChangerHe/tags/HTML-CSS/"}]},{"title":"What is Flex?","slug":"What-is-Flex","date":"2017-06-14T14:16:09.000Z","updated":"2017-09-14T15:00:41.068Z","comments":true,"path":"2017/06/14/What-is-Flex/","link":"","permalink":"https://github.com/ChangerHe/2017/06/14/What-is-Flex/","excerpt":"","text":"Flex布局是什么？Flex是Fllexible Box的缩写，也就是“弹性布局”，用来为盒子模型提供最大的灵活性。任何一个容器都可以指定为Flex布局。123.box&#123; display:flex;&#125; 当然，对于行内元素，也可以使用Flex布局。123.box&#123; display:inline-flex;&#125; 注意，当设为Flex布局以后，子元素的float、clear和vertical-align属性将会失效。 基本概念采用Flex布局的元素，成为Flex容器，他的所有子元素自动成为容器成员，成为Flex项目（flex item)容器默认存在两根轴：水平主轴和垂直的交叉轴。主轴的开始位置（与边框的交叉点）叫做main start,结束为止叫做mian end；交叉轴的开始位置叫做cross start，结束为止叫做cross end。项目默认沿主轴排列，单个项目占据的主轴空间叫做main size，占据的交叉轴空间叫做cross size。 #容器的属性 以下六个属性设置为容器上flex-directionflex-wrapflex-flowjustify-contentalign-itemsalign-content flex-direction属性flex-direction属性决定主轴的方向123456.box&#123; flex-direction: column-reverse； //主轴为垂直方向，起点在下沿。 flex-direction: column; //主轴为垂直方向，起点在上沿。 flex-direction: row; //默认值，主轴为水平方向，起点在左端。 flex-direction: row-reverse； //主轴为垂直方向，起点在下沿。&#125; 对应图示如下图： flex-wrap属性默认情况下，项目都排在一条线上，flex-wrap属性定义，如果一条轴线排不下，如何换行。12345.box&#123; flex-wrap: nowrap; //不换行 flex-wrap: wrap; //换行，第一行在上方 flex-wrap: wrap-reverse; //换行，第一行在下方&#125; flex-flowflex-flow属性是flex-direction属性和flex-wrap属性的简写形式，默认值为row nowrap。123.box &#123; flex-flow: &lt;flex-direction&gt; || &lt;flex-wrap&gt;;&#125; justify-content属性justify-content属性定义了项目在主轴上的对齐方式。123.box &#123; justify-content: flex-start | flex-end | center | space-between | space-around;&#125; flex-start（默认值）：左对齐flex-end：右对齐center： 居中space-between：两端对齐，项目之间的间隔都相等。space-around：每个项目两侧的间隔相等。所以，项目之间的间隔比项目与边框的间隔大一倍。 align-items属性align-items属性定义项目在交叉轴上如何对齐。123.box &#123; align-items: flex-start | flex-end | center | baseline | stretch;&#125; flex-start：交叉轴的起点对齐。flex-end：交叉轴的终点对齐。center：交叉轴的中点对齐。baseline: 项目的第一行文字的基线对齐。stretch（默认值）：如果项目未设置高度或设为auto，将占满整个容器的高度。 align-content属性align-content属性定义了多根轴线的对齐方式。如果项目只有一根轴线，该属性不起作用。123.box &#123; align-content: flex-start | flex-end | center | space-between | space-around | stretch;&#125; flex-start：与交叉轴的起点对齐。flex-end：与交叉轴的终点对齐。center：与交叉轴的中点对齐。space-between：与交叉轴两端对齐，轴线之间的间隔平均分布。space-around：每根轴线两侧的间隔都相等。所以，轴线之间的间隔比轴线与边框的间隔大一倍。stretch（默认值）：轴线占满整个交叉轴。 项目的属性order属性order属性定义项目的排列顺序。数值越小，排列越靠前，默认为0。123.item &#123; order: &lt;integer&gt;;&#125; flex-grow属性flex-grow属性定义项目的放大比例，默认为0，即如果存在剩余空间，也不放大。123.item &#123; flex-grow: &lt;number&gt;; /* default 0 */&#125; 如果所有项目的flex-grow属性都为1，则它们将等分剩余空间（如果有的话）。如果一个项目的flex-grow属性为2，其他项目都为1，则前者占据的剩余空间将比其他项多一倍。 flex-shrink属性flex-shrink属性定义了项目的缩小比例，默认为1，即如果空间不足，该项目将缩小。123.item &#123; flex-shrink: &lt;number&gt;; /* default 1 */&#125; 如果所有项目的flex-shrink属性都为1，当空间不足时，都将等比例缩小。如果一个项目的flex-shrink属性为0，其他项目都为1，则空间不足时，前者不缩小。负值对该属性无效。 flex-basis属性flex-basis属性定义了在分配多余空间之前，项目占据的主轴空间（main size）。浏览器根据这个属性，计算主轴是否有多余空间。它的默认值为auto，即项目的本来大小。123.item &#123; flex-basis: &lt;length&gt; | auto; /* default auto */&#125; flex属性flex属性是flex-grow, flex-shrink 和 flex-basis的简写，默认值为0 1 auto。后两个属性可选。123.item &#123; flex: none | [ &lt;'flex-grow'&gt; &lt;'flex-shrink'&gt;? || &lt;'flex-basis'&gt; ]&#125; 该属性有两个快捷值：auto (1 1 auto) 和 none (0 0 auto)。建议优先使用这个属性，而不是单独写三个分离的属性，因为浏览器会推算相关值。 align-self属性align-self属性允许单个项目有与其他项目不一样的对齐方式，可覆盖align-items属性。默认值为auto，表示继承父元素的align-items属性，如果没有父元素，则等同于stretch。123.item &#123; align-self: auto | flex-start | flex-end | center | baseline | stretch;&#125; (以上内容均转载自阮一峰博客）","categories":[{"name":"HTML & CSS 学习笔记","slug":"HTML-CSS-学习笔记","permalink":"https://github.com/ChangerHe/categories/HTML-CSS-学习笔记/"}],"tags":[{"name":"What is Flex?","slug":"What-is-Flex","permalink":"https://github.com/ChangerHe/tags/What-is-Flex/"}]},{"title":"XML学习笔记","slug":"XML学习笔记","date":"2017-06-14T14:16:09.000Z","updated":"2017-09-14T15:02:07.663Z","comments":true,"path":"2017/06/14/XML学习笔记/","link":"","permalink":"https://github.com/ChangerHe/2017/06/14/XML学习笔记/","excerpt":"","text":"XML/HTML/XHTML/DHTML的相互关系XML(Extensible Markup Language)可扩展标记语言，和HTML类似，都是一种标记语言，还有类似的标记语言有：DHTML和XHTML，先来捋一捋他们的关系： HTML（HyperText Markup Language）这个不必多说，网络的通用语言，随着网络的盛行，大行其道。本身是一种文本文件，通过在文本文件中添加标记符来告诉浏览器显示什么内容。因为最初的标准不完善，经过长时间的演化，现在是一个基本上已经算是完全固定的HTML5版本。HTML因为之前的不断向下兼容，导致结构不够严谨而备受诟病，因此之后一些搞事的程序猿们开始构思一个结构更加严谨的文档标记语言，这个时候XHTML应运而生了。 XHTML（Extensible HyperText Markup Language）先看一下百度百科上对XHTML的解释1可扩展超文本标记语言，是一种置标语言，表现方式与超文本标记语言（HTML）类似，不过语法上更加严格。 其实就严谨性来说，XHTML确实相比于HTML严谨了很多，但是随之也产生了跨平台的兼容性问题和无法向下兼容的问题。因此XHTML逐渐被淘汰，只有一些很老的公司在使用这个技术。 DHTML（Dynamic HTML）DHTML其实相当于HTML加上CSS加上JS，因为DHTML是“动态的”HTML。 XML(Extensible Markup Language)下面就是我们的主角登场了，因为考虑到数据的严谨性和可调用性，同时要保证能够和前台的HTML进行成功的交互，此时XML就应运而生了（其实XML比XHTML诞生的早很多，在1998年就成为了W3C的推荐标准），XML是各种应用程序之间进行数据传输最常用的工具。 XML的语法语法注意事项1.空元素标签都必须用“/”来关闭，如： &lt;br/&gt;2.所有标签都区分大小写。3.必须严格嵌套。4.所有标签的属性都必须用引号括起来。5.XML有且只有一个根元素。 XML声明&lt;?xml 版本信息[编码信息][文档独立性信息]?&gt;如： &lt;?xml version=&quot;1.0&quot;?&gt;注：xml文档声明必须放到文档第一行，且前方不能又任何字符。 文档类型声明（DTD）命名规范1.只能以字母，下划线，或冒号开头。2.不能包含空格。3.名称中尽量不使用冒号，否则可能出现解析问题。4.字符中不能有 &amp; 和 &lt; 以及 ]]&gt; 标签，否则会被理解为标记的起始和结束定界符。 字符引用有些地方必须要用字符时，可用字符的实体或者字符的进制码代替 字符 字符引用（十进制） 字符引用（十六进制） 预定义实体引用 &lt; &amp;#60; &amp;#x3c; &amp;lt; &gt; &amp;#62; &amp;#x3e; &amp;gt; “ &amp;#34; &amp;#x22; &amp;quot; ‘ &amp;#39; &amp;#x27; &amp;apos; &amp; &amp;#38; &amp;#x26; &amp;amp; CDATA字段其内容不被XML处理器解析，所以可以包含任意字符。但是不能有 &amp; 和 &lt; 以及 ]]&gt; ，相当于引用了其中的内容，而该内容不被解析。格式：&lt;![CDATA[ 任何不想被解析的内容 ]]&gt; 引用引用css格式：&lt;?xml-stylesheet href=&quot;hello.css&quot; type=&quot;text/css&quot;?&gt;引用外部DTD格式：&lt;!DOCTYPE greeting SYSTEM &quot;hello.dtd&quot;&gt;直接写在xml文档内的DTD：123&lt;!DOCTYPE greeting [ &lt;!ELEMENT greeting (#PCDATA)&gt;]&gt; 不过，对于css而言，对xml其实并不特别合适，XML的首选样式语言是XSLT (eXtensible Stylesheet Language Transformations)其引用方式与css类似：&lt;?xml-stylesheet type=&quot;text/xsl&quot; href=&quot;simple.xsl&quot;?&gt;注：PCDATA:被解析的字符数据CDATA:不会被解析器解析的文本 属性声明属性通过ATTLIST来进行声明格式：&lt;!ATTLIST 元素名称 属性名称 属性类型 默认值&gt;12&lt;!ATTLIST payment type CDATA &quot;check&quot;&gt;&lt;payment type=&quot;check&quot;/&gt; XML HTTP Request讲了半天XML的杂七杂八，其实这玩意儿才是正主。XMLHttpRequest 对象用于在后台与服务器交换数据。也就是有了他，AJAX,JSON,XMLHttpRequest对象之流才能正常工作起来，实现数据的交换和同步异步传输。语法如下：12345678910111213141516171819202122&lt;script&gt;var xmlhttp=new XMLHttpRequest(); //新定义一个XMLHttpRequest对象xmlhttp.onreadystatechange = state_Change; //onreadystatechange 是一个事件句柄。它的值 (state_Change) 是一个函数的名称//当 XMLHttpRequest 对象的状态发生改变时，会触发此函数。xmlhttp.open(&quot;GET&quot;,url,true);//参数提交方式为GET，参数指向一个url，参数为异步请求（true）xmlhttp.send(null);//send()方法仅在使用POST传参时使用，故设定为nullfunction state_Change()&#123; if(xmlhttp.readyState == 4)&#123; //4表示已装载 if(xmlhttp.status == 200)&#123; //200表示http请求执行成功 //此处可执行代码 &#125; else &#123; console.log(&quot;服务器发生错误&quot;) &#125; &#125; else &#123; consolg.log(&quot;未成功装载&quot;) &#125;&#125;&lt;/script&gt;","categories":[{"name":"XML 学习笔记","slug":"XML-学习笔记","permalink":"https://github.com/ChangerHe/categories/XML-学习笔记/"}],"tags":[{"name":"XML","slug":"XML","permalink":"https://github.com/ChangerHe/tags/XML/"}]},{"title":"Position属性知多少","slug":"hello-world","date":"2017-06-14T14:16:09.000Z","updated":"2017-09-14T15:01:04.235Z","comments":true,"path":"2017/06/14/hello-world/","link":"","permalink":"https://github.com/ChangerHe/2017/06/14/hello-world/","excerpt":"","text":"本篇文章关于Position属性值，等于对position这个属性中的值：static，relative,absolute,fixed进行一次总结，回忆一下学到的内容，加深一下理解。 1.static：所有元素在默认情况之下的属性，在布局中的属性top、bottom、left、right在position为static的情况下是无效的。 2.relative：相对定位，可以设置性top、bottom、left、right属性值，但是请注意！虽然元素的位置会随着top、bottom、left、right属性值的改变而改变，但是其“真身”是留在之前的位置的，也就是说下方的元素不会因为其设置了relative属性，并改变其位置后而上移或下移。 有一点要特别注意的是：设置了relative属性后的的元素其display属性（不管你是inline还是inline-block还是block）之前是怎样现在还是怎样，这个是不变得。 3.absolute：绝对定位，设置了absolute属性后，该元素会向其父节点去寻找它的“根源”，有一点要特别注意的是（对比第二条的特别注意看）：设置了absolute属性后的的元素其display属性（不管你是inline还是inline-block还是block）将会统一全部变成block且width自动成为auto，也就是会受到父元素的影响。 ##（1）其父节点无position属性，父n个节点都没有position属性，那么其relative的“根 源”将以body为参照，也就是屏幕的0,0点。 ##（2）其父节点有position属性且该属性设置为relative，那么好，这个节点就会以此父节 点为“根源”去做自己的定位了。定位top、bottom、left、right属性值为都是相对于父节点的0,0位置。 ##（3）其父节点有position属性且该属性设置为absolute，我们很惊奇地会看到，握草这 两个元素居然重叠了而且重叠的毫无缝隙，什么鬼！，事实发现原来是这样的：设置为absolute后div自动变为width：auto；也就是说A-1和A-2都是width：auto；从而导致了它们的重叠，但是为何其“根源”变成了A-1，这是令我不解的地方。 ##（4）其父节点有position属性该属性设置为absolute，而且其父父节点有position属性该属性设置为relative，那么这个结果应该大家都猜得到，该元素及其父节点都会以其父父节点作为“根源”。 #（5）其父节点有position属性该属性设置为absolute，而且其父父节点有position属性该属性设置为absolute，情况和（3）类似，我就直接上图了。 4.fixed：该属性之前一直因为与IE6的兼容性问题，而被打入“冷宫”，fixed和absolute有许多共同点： ##（1）改变呈现样式，设置后元素将直接变为block。 ##（2）会让元素脱离普通流，不会像relative一样，在页面的原来位置留下“真身”。 那么问题来了，他和absolute的区别在哪里？他们的区别就是，fixed属性永远会跟着body爸爸走，body爸爸去哪儿，它也去哪儿。而absolute属性可就要看情况了，具体看3里面我对absolute的介绍。","categories":[{"name":"HTML & CSS 学习笔记","slug":"HTML-CSS-学习笔记","permalink":"https://github.com/ChangerHe/categories/HTML-CSS-学习笔记/"}],"tags":[{"name":"HTML & CSS","slug":"HTML-CSS","permalink":"https://github.com/ChangerHe/tags/HTML-CSS/"}]},{"title":"HEXO使用小结","slug":"hexo","date":"2017-06-14T14:16:09.000Z","updated":"2017-09-14T15:00:59.553Z","comments":true,"path":"2017/06/14/hexo/","link":"","permalink":"https://github.com/ChangerHe/2017/06/14/hexo/","excerpt":"","text":"本文是我从自学前端开发以来，自己写的第一篇博客，为什么要写这一篇博客呢，原因有二，一是给自己没写过博客的hexo开个光，二是记录一下自己的每日所学所感。 关于hexo的基础配置hexo的配置其实在网上已经有许多的大佬已经讲的一清二楚了，这里贴几个DALAO的链接，我在构建自己的博客的时候，就是以他们为参照的： 1. holaOla :Hexo安装和配置2. Raspberry :Hexo 搭建博客-基础配置篇以上基本可以在看完之后基本实现自己的bolg上线了，主要工作无非有四：1.git的安装2.GitHub的注册，本地SSHkey的设置3.hexo的安装4.node.js的环境搭建实现了以上四项，自己的bolg基本上可以搭建成功。 关于hexo的设置和配置以下为hexo在\\Hexo\\themes\\next_config.yml下的配置文件（笔者使用的是next作为主题） 1title: 副标题1subtitle: 网站描述1description: 作者昵称1author: 网站语言，默认英语，设置简体汉语1language: zh-Hans 时区，默认电脑时区12### timezone: timezone: Asia/Shanghai 网址设置如果网站是放在子目录中，将url设置成’1http://yoursite.com/child' 将root设置成’/child/‘ 1If your site is put in a subdirectory, set url as 'http://yoursite.com/child' and root as '/child/' ###网址url: 网站根目录。如果网站是放在子目录中，将root设置成’子目录名’root: / 文章链接地址格式 。即文章存放的目录。12permalink: :year/:month/:day/:title/permalink_defaults: 目录设置资源文件夹，放在里面的文件会上传到github中1source_dir: source 公共文件夹，存放生成的静态文件1public_dir: public 标签文件夹，默认是tags。实际存放在source/tags中。12tag_dir: tagsrss_dir: rss 档案文件夹，默认是archives。1archive_dir: archives 分类文件夹，默认是categories。实际存放在source/categories中。1category_dir: categories 代码文件夹，默认是downloads/code1code_dir: downloads/code 国际化文件夹，默认跟language相同1i18n_dir: :lang 不需要渲染的文件夹或文件夹,放在[]中这两个文件是百度和google的站长验证文件，不能渲染，否则会改变内容，不能验证过1skip_render: [baidu_verify_R9MZjdMkXT.html, google0f8fac7da2b48ef8.html, README.md, 模板.md] 写作选项新建博文（帖子）的默认名称12#File name of new postsnew_post_name: :title.md 默认布局模板是post，而不是draft和page1default_layout: post 是否将标题转换成标题形式（首字母大写）1titlecase: false # Transform title into titlecase 在新标签页面中打开网页12external_link: true # Open external links in new tabfilename_case: 0 是否渲染草稿1render_drafts: false 启动 Asset 文件夹1post_asset_folder: false 把链接改为与根目录的相对位址1relative_link: false 显示未来的文章1future: true 代码块的设置12345highlight: enable: true #使用代码高亮 line_number: true #显示行号 auto_detect: true #自动检测语言 tab_replace: 分类和标签默认分类1default_category: uncategorized 分类别名1category_map: 标签别名1tag_map: 日期和时间格式Hexo 使用 Moment.js 来解析和显示时间。1234#You can customize the date format as defined in#http://momentjs.com/docs/#/displaying/format/date_format: YYYY-MM-DDtime_format: HH:mm:ss 分页配置—————下面选项需要对应插件的支持—————12345#npm install hexo-generator-index --save#npm install hexo-generator-archive --save#npm install hexo-generator-category --save#npm install hexo-generator-tag --save#Set per_page to 0 to disable pagination 每页显示的文章量1#per_page: 20 首页的分页设置12index_generator: per_page: 5 归档页的分页设置1234archive_generator: per_page: 30 yearly: true monthly: true 标签页的分页设置12tag_generator: per_page: 20 分页路径，在public中可以看到1#pagination_dir: page Extensions 拓展插件配置1234#Plugins: https://hexo.io/plugins/plugins: baidusitemap: path: baidusitemap.xml 配置RSS1234567feed: #feed 类型 (atom/rss2) type: atom #rss 路径 path: atom.xml ### 在 rss 中最多生成的文章数(0显示所有) limit: 0 自定义站点内容搜索需要先安装插件：123#npm install hexo-generator-search --savesearch: path: search.xml 如只想索引文章，可设置为post field: all 主题配置1234#Themes: https://hexo.io/themes/#theme: false #禁用主题#theme: landscapetheme: next 部署配置#Docs: https://hexo.io/docs/deployment.htmldeploy: type: git #repo: https://github.com/changerhe.github.io.git repo: #部署到github github: git@github.com:changerhe/changerhe.github.io.git,master #部署到coding.net。取消注释，可同时部署 #coding: git@git.coding.net:chngerhe/blog.git,coding-pages #type: baidu_url_submitter","categories":[{"name":"Hexo-NexT搭建个人博客","slug":"Hexo-NexT搭建个人博客","permalink":"https://github.com/ChangerHe/categories/Hexo-NexT搭建个人博客/"}],"tags":[{"name":"HEXO","slug":"HEXO","permalink":"https://github.com/ChangerHe/tags/HEXO/"}]},{"title":"hexo博客必备-MarkDown语法总结","slug":"hexo博客必备-MarkDown语法总结","date":"2017-06-14T13:54:12.000Z","updated":"2017-10-12T11:10:43.489Z","comments":true,"path":"2017/06/14/hexo博客必备-MarkDown语法总结/","link":"","permalink":"https://github.com/ChangerHe/2017/06/14/hexo博客必备-MarkDown语法总结/","excerpt":"","text":"什么? 你想写技术文章, 又不想贴到社区啊巴拉巴拉这些怎么办? 很好解决啊, 用github写博客呗, 写博客需要啥? hexo+喜欢的主题+markdown啊 现在毋庸置疑, Markdowm语法已经被许多的开发者所接受, github的介绍都要求要使用这个语法了, 那么这里针对markdown的一些语法做一些总结, 希望能够帮助到大家. 鼠标悬停效果(列表效果)不同显示效果依不同的主题决定 使用方法是, 直接在一行字前面加上 - 符号, 没错就是这么简单 想要像下面这样实现字体加粗? 可以使用在文字两侧加上 ** 两个星号就好 同样类似的有*, 加一个星, 代表斜体 Markdown和扩展Markdown简洁的语法 代码块高亮 图片链接和图片上传 Markdown及扩展那么整半天, 想起来Markdown还没做介绍呢, 我们看一下维基百科的介绍 Markdown 是一种轻量级标记语言，它允许人们使用易读易写的纯文本格式编写文档，然后转换成格式丰富的HTML页面。 —— [ 维基百科 ] 主要是想体现上面的两个语法, 使用 &gt; 可以实现引用效果, 文字的链接可以使用 —— &lt;a href=&quot;链接地址&quot; &gt; [ 链接名 ] 来实现, 如果需要在新页面打开, 加上target=&quot;_blank&quot;, 其实和HTML是一样的. 表格Markdown Extra 表格语法： 横向使用|来分隔, 竖向的标题和内容使用-来分隔, 下面是实现效果 项目 价格 Computer $1600 Phone $12 Pipe $1 可以使用冒号来定义对齐方式： 需要哪一侧对齐, 就在哪一侧加点, 例如下面我的分隔方式是这样的| :-------- | --------:| :--: | 项目 价格 数量 Computer 1600 元 5 Phone 12 元 12 Pipe 1 元 234 代码块代码块语法遵循标准markdown代码，例如： 别问我代码哪里来的,顺手抄的 123456.box&#123; display:-webkit-box; display:box; display:-webkit-flex; display:flex;&#125; 离线写博客即使用户在没有网络的情况下，也可以通过本编辑器离线写博客（直接在曾经使用过的浏览器中输入write.blog.csdn.net/mdeditor即可。Markdown编辑器使用浏览器离线存储将内容保存在本地。 用户写博客的过程中，内容实时保存在浏览器缓存中，在用户关闭浏览器或者其它异常情况下，内容不会丢失。用户再次打开浏览器时，会显示上次用户正在编辑的没有发表的内容。 博客发表后，本地缓存将被删除。 用户可以选择 把正在写的博客保存到服务器草稿箱，即使换浏览器或者清除缓存，内容也不会丢失。 注意：虽然浏览器存储大部分时候都比较可靠，但为了您的数据安全，在联网后，请务必及时发表或者保存到服务器草稿箱。 ##浏览器兼容 目前，本编辑器对Chrome浏览器支持最为完整。建议大家使用较新版本的Chrome。 IE９以下不支持 IE９，１０，１１存在以下问题 不支持离线功能 IE9不支持文件导入导出 IE10不支持拖拽文件导入","categories":[{"name":"Markdown","slug":"Markdown","permalink":"https://github.com/ChangerHe/categories/Markdown/"}],"tags":[{"name":"Markdown","slug":"Markdown","permalink":"https://github.com/ChangerHe/tags/Markdown/"}]}]}