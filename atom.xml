<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>ChangerHe&#39;s Bolg|何庆畅的个人博客</title>
  <subtitle>What doesn&#39;t kill you make you stronger.</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://github.com/ChangerHe/"/>
  <updated>2017-09-16T03:54:41.808Z</updated>
  <id>https://github.com/ChangerHe/</id>
  
  <author>
    <name>ChangerHe</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>《ES6标准入门》阅读笔记——-Module</title>
    <link href="https://github.com/ChangerHe/2017/07/20/%E3%80%8AES6%E6%A0%87%E5%87%86%E5%85%A5%E9%97%A8%E3%80%8B%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0%E2%80%94%E2%80%94-Module/"/>
    <id>https://github.com/ChangerHe/2017/07/20/《ES6标准入门》阅读笔记——-Module/</id>
    <published>2017-07-19T16:23:13.000Z</published>
    <updated>2017-09-16T03:54:41.808Z</updated>
    
    <summary type="html">
    
      本系列为在我基本完全读完了阮一峰老师的《ES6标准入门》第二版之后，所做的阅读笔记的整理，作为日后的复习使用。 系列博客将采用一个一个的样例，来说明书中的精华部分（当然，这只是我认为的），同时引导像我这样的新手，快速入门ES6，并逐步将其投入到生产实践中。
    
    </summary>
    
      <category term="ES6标准入门" scheme="https://github.com/ChangerHe/categories/ES6%E6%A0%87%E5%87%86%E5%85%A5%E9%97%A8/"/>
    
    
      <category term="ES6" scheme="https://github.com/ChangerHe/tags/ES6/"/>
    
      <category term="Module" scheme="https://github.com/ChangerHe/tags/Module/"/>
    
  </entry>
  
  <entry>
    <title>《ES6标准入门》阅读笔记——-Class</title>
    <link href="https://github.com/ChangerHe/2017/07/16/%E3%80%8AES6%E6%A0%87%E5%87%86%E5%85%A5%E9%97%A8%E3%80%8B%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0%E2%80%94%E2%80%94-Class/"/>
    <id>https://github.com/ChangerHe/2017/07/16/《ES6标准入门》阅读笔记——-Class/</id>
    <published>2017-07-16T15:52:52.000Z</published>
    <updated>2017-09-16T03:54:05.164Z</updated>
    
    <summary type="html">
    
      本系列为在我基本完全读完了阮一峰老师的《ES6标准入门》第二版之后，所做的阅读笔记的整理，作为日后的复习使用。 系列博客将采用一个一个的样例，来说明书中的精华部分（当然，这只是我认为的），同时引导像我这样的新手，快速入门ES6，并逐步将其投入到生产实践中。
    
    </summary>
    
      <category term="ES6标准入门" scheme="https://github.com/ChangerHe/categories/ES6%E6%A0%87%E5%87%86%E5%85%A5%E9%97%A8/"/>
    
    
      <category term="ES6" scheme="https://github.com/ChangerHe/tags/ES6/"/>
    
      <category term="Class" scheme="https://github.com/ChangerHe/tags/Class/"/>
    
  </entry>
  
  <entry>
    <title>《ES6标准入门》阅读笔记——-Promise</title>
    <link href="https://github.com/ChangerHe/2017/07/11/%E3%80%8AES6%E6%A0%87%E5%87%86%E5%85%A5%E9%97%A8%E3%80%8B%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0%E2%80%94%E2%80%94-Promise/"/>
    <id>https://github.com/ChangerHe/2017/07/11/《ES6标准入门》阅读笔记——-Promise/</id>
    <published>2017-07-11T14:23:54.000Z</published>
    <updated>2017-09-16T03:53:28.932Z</updated>
    
    <summary type="html">
    
      本系列为在我基本完全读完了阮一峰老师的《ES6标准入门》第二版之后，所做的阅读笔记的整理，作为日后的复习使用。 系列博客将采用一个一个的样例，来说明书中的精华部分（当然，这只是我认为的），同时引导像我这样的新手，快速入门ES6，并逐步将其投入到生产实践中。
    
    </summary>
    
      <category term="ES6标准入门" scheme="https://github.com/ChangerHe/categories/ES6%E6%A0%87%E5%87%86%E5%85%A5%E9%97%A8/"/>
    
    
      <category term="ES6" scheme="https://github.com/ChangerHe/tags/ES6/"/>
    
      <category term="Promise" scheme="https://github.com/ChangerHe/tags/Promise/"/>
    
  </entry>
  
  <entry>
    <title>《ES6标准入门》阅读笔记——-Iterator和Generator</title>
    <link href="https://github.com/ChangerHe/2017/07/07/%E3%80%8AES6%E6%A0%87%E5%87%86%E5%85%A5%E9%97%A8%E3%80%8B%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0%E2%80%94%E2%80%94-Iterator%E5%92%8CGenerator/"/>
    <id>https://github.com/ChangerHe/2017/07/07/《ES6标准入门》阅读笔记——-Iterator和Generator/</id>
    <published>2017-07-07T15:11:34.000Z</published>
    <updated>2017-09-16T03:53:00.557Z</updated>
    
    <summary type="html">
    
      本系列为在我基本完全读完了阮一峰老师的《ES6标准入门》第二版之后，所做的阅读笔记的整理，作为日后的复习使用。 系列博客将采用一个一个的样例，来说明书中的精华部分（当然，这只是我认为的），同时引导像我这样的新手，快速入门ES6，并逐步将其投入到生产实践中。
    
    </summary>
    
      <category term="ES6标准入门" scheme="https://github.com/ChangerHe/categories/ES6%E6%A0%87%E5%87%86%E5%85%A5%E9%97%A8/"/>
    
    
      <category term="ES6" scheme="https://github.com/ChangerHe/tags/ES6/"/>
    
      <category term="Iterator" scheme="https://github.com/ChangerHe/tags/Iterator/"/>
    
      <category term="Generator" scheme="https://github.com/ChangerHe/tags/Generator/"/>
    
  </entry>
  
  <entry>
    <title>《ES6标准入门》阅读笔记——-set和map</title>
    <link href="https://github.com/ChangerHe/2017/07/03/%E3%80%8AES6%E6%A0%87%E5%87%86%E5%85%A5%E9%97%A8%E3%80%8B%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0%E2%80%94%E2%80%94-set%E5%92%8Cmap/"/>
    <id>https://github.com/ChangerHe/2017/07/03/《ES6标准入门》阅读笔记——-set和map/</id>
    <published>2017-07-03T03:37:44.000Z</published>
    <updated>2017-09-16T03:52:17.617Z</updated>
    
    <summary type="html">
    
      本系列为在我基本完全读完了阮一峰老师的《ES6标准入门》第二版之后，所做的阅读笔记的整理，作为日后的复习使用。 系列博客将采用一个一个的样例，来说明书中的精华部分（当然，这只是我认为的），同时引导像我这样的新手，快速入门ES6，并逐步将其投入到生产实践中。
    
    </summary>
    
      <category term="ES6标准入门" scheme="https://github.com/ChangerHe/categories/ES6%E6%A0%87%E5%87%86%E5%85%A5%E9%97%A8/"/>
    
    
      <category term="ES6" scheme="https://github.com/ChangerHe/tags/ES6/"/>
    
      <category term="set" scheme="https://github.com/ChangerHe/tags/set/"/>
    
      <category term="map" scheme="https://github.com/ChangerHe/tags/map/"/>
    
  </entry>
  
  <entry>
    <title>《ES6标准入门》阅读笔记——-symbol及proxy/reflect</title>
    <link href="https://github.com/ChangerHe/2017/07/01/%E3%80%8AES6%E6%A0%87%E5%87%86%E5%85%A5%E9%97%A8%E3%80%8B%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0%E2%80%94%E2%80%94-symbol%E5%8F%8Aproxy-reflect/"/>
    <id>https://github.com/ChangerHe/2017/07/01/《ES6标准入门》阅读笔记——-symbol及proxy-reflect/</id>
    <published>2017-07-01T05:51:28.000Z</published>
    <updated>2017-09-16T03:51:33.270Z</updated>
    
    <summary type="html">
    
      本系列为在我基本完全读完了阮一峰老师的《ES6标准入门》第二版之后，所做的阅读笔记的整理，作为日后的复习使用。 系列博客将采用一个一个的样例，来说明书中的精华部分（当然，这只是我认为的），同时引导像我这样的新手，快速入门ES6，并逐步将其投入到生产实践中。
    
    </summary>
    
      <category term="ES6标准入门" scheme="https://github.com/ChangerHe/categories/ES6%E6%A0%87%E5%87%86%E5%85%A5%E9%97%A8/"/>
    
    
      <category term="ES6" scheme="https://github.com/ChangerHe/tags/ES6/"/>
    
      <category term="symbol" scheme="https://github.com/ChangerHe/tags/symbol/"/>
    
      <category term="proxy" scheme="https://github.com/ChangerHe/tags/proxy/"/>
    
      <category term="reflect" scheme="https://github.com/ChangerHe/tags/reflect/"/>
    
  </entry>
  
  <entry>
    <title>《ES6标准入门》阅读笔记——-string类型的扩展</title>
    <link href="https://github.com/ChangerHe/2017/06/30/%E3%80%8AES6%E6%A0%87%E5%87%86%E5%85%A5%E9%97%A8%E3%80%8B%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0%E2%80%94%E2%80%94-string%E7%B1%BB%E5%9E%8B%E7%9A%84%E6%89%A9%E5%B1%95/"/>
    <id>https://github.com/ChangerHe/2017/06/30/《ES6标准入门》阅读笔记——-string类型的扩展/</id>
    <published>2017-06-30T05:49:33.000Z</published>
    <updated>2017-09-16T03:50:34.743Z</updated>
    
    <summary type="html">
    
      本系列为在我基本完全读完了阮一峰老师的《ES6标准入门》第二版之后，所做的阅读笔记的整理，作为日后的复习使用。 系列博客将采用一个一个的样例，来说明书中的精华部分（当然，这只是我认为的），同时引导像我这样的新手，快速入门ES6，并逐步将其投入到生产实践中。
    
    </summary>
    
      <category term="ES6标准入门" scheme="https://github.com/ChangerHe/categories/ES6%E6%A0%87%E5%87%86%E5%85%A5%E9%97%A8/"/>
    
    
      <category term="ES6" scheme="https://github.com/ChangerHe/tags/ES6/"/>
    
      <category term="string" scheme="https://github.com/ChangerHe/tags/string/"/>
    
  </entry>
  
  <entry>
    <title>《ES6标准入门》阅读笔记——-函数的扩展</title>
    <link href="https://github.com/ChangerHe/2017/06/28/%E3%80%8AES6%E6%A0%87%E5%87%86%E5%85%A5%E9%97%A8%E3%80%8B%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0%E2%80%94%E2%80%94-%E5%87%BD%E6%95%B0%E7%9A%84%E6%89%A9%E5%B1%95/"/>
    <id>https://github.com/ChangerHe/2017/06/28/《ES6标准入门》阅读笔记——-函数的扩展/</id>
    <published>2017-06-28T13:36:55.000Z</published>
    <updated>2017-09-16T03:49:47.881Z</updated>
    
    <summary type="html">
    
      本系列为在我基本完全读完了阮一峰老师的《ES6标准入门》第二版之后，所做的阅读笔记的整理，作为日后的复习使用。 系列博客将采用一个一个的样例，来说明书中的精华部分（当然，这只是我认为的），同时引导像我这样的新手，快速入门ES6，并逐步将其投入到生产实践中。
    
    </summary>
    
      <category term="ES6标准入门" scheme="https://github.com/ChangerHe/categories/ES6%E6%A0%87%E5%87%86%E5%85%A5%E9%97%A8/"/>
    
    
      <category term="ES6" scheme="https://github.com/ChangerHe/tags/ES6/"/>
    
      <category term="Function" scheme="https://github.com/ChangerHe/tags/Function/"/>
    
  </entry>
  
  <entry>
    <title>《ES6标准入门》阅读笔记——-数组的扩展</title>
    <link href="https://github.com/ChangerHe/2017/06/25/%E3%80%8AES6%E6%A0%87%E5%87%86%E5%85%A5%E9%97%A8%E3%80%8B%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0%E2%80%94%E2%80%94-%E6%95%B0%E7%BB%84%E7%9A%84%E6%89%A9%E5%B1%95/"/>
    <id>https://github.com/ChangerHe/2017/06/25/《ES6标准入门》阅读笔记——-数组的扩展/</id>
    <published>2017-06-25T14:34:21.000Z</published>
    <updated>2017-09-16T03:49:04.719Z</updated>
    
    <summary type="html">
    
      本系列为在我基本完全读完了阮一峰老师的《ES6标准入门》第二版之后，所做的阅读笔记的整理，作为日后的复习使用。 系列博客将采用一个一个的样例，来说明书中的精华部分（当然，这只是我认为的），同时引导像我这样的新手，快速入门ES6，并逐步将其投入到生产实践中。
    
    </summary>
    
      <category term="ES6标准入门" scheme="https://github.com/ChangerHe/categories/ES6%E6%A0%87%E5%87%86%E5%85%A5%E9%97%A8/"/>
    
    
      <category term="ES6" scheme="https://github.com/ChangerHe/tags/ES6/"/>
    
      <category term="Array" scheme="https://github.com/ChangerHe/tags/Array/"/>
    
  </entry>
  
  <entry>
    <title>《ES6标准入门》阅读笔记——-number类型的扩展</title>
    <link href="https://github.com/ChangerHe/2017/06/22/%E3%80%8AES6%E6%A0%87%E5%87%86%E5%85%A5%E9%97%A8%E3%80%8B%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0%E2%80%94%E2%80%94-number%E7%B1%BB%E5%9E%8B%E7%9A%84%E6%89%A9%E5%B1%95/"/>
    <id>https://github.com/ChangerHe/2017/06/22/《ES6标准入门》阅读笔记——-number类型的扩展/</id>
    <published>2017-06-22T15:41:23.000Z</published>
    <updated>2017-09-16T03:48:23.584Z</updated>
    
    <summary type="html">
    
      本系列为在我基本完全读完了阮一峰老师的《ES6标准入门》第二版之后，所做的阅读笔记的整理，作为日后的复习使用。 系列博客将采用一个一个的样例，来说明书中的精华部分（当然，这只是我认为的），同时引导像我这样的新手，快速入门ES6，并逐步将其投入到生产实践中。
    
    </summary>
    
      <category term="ES6标准入门" scheme="https://github.com/ChangerHe/categories/ES6%E6%A0%87%E5%87%86%E5%85%A5%E9%97%A8/"/>
    
    
      <category term="ES6" scheme="https://github.com/ChangerHe/tags/ES6/"/>
    
      <category term="number" scheme="https://github.com/ChangerHe/tags/number/"/>
    
  </entry>
  
  <entry>
    <title>《ES6标准入门》阅读笔记——-正则表达式的扩展</title>
    <link href="https://github.com/ChangerHe/2017/06/20/%E3%80%8AES6%E6%A0%87%E5%87%86%E5%85%A5%E9%97%A8%E3%80%8B%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0%E2%80%94%E2%80%94-%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F%E7%9A%84%E6%89%A9%E5%B1%95/"/>
    <id>https://github.com/ChangerHe/2017/06/20/《ES6标准入门》阅读笔记——-正则表达式的扩展/</id>
    <published>2017-06-20T12:45:51.000Z</published>
    <updated>2017-09-16T05:54:37.841Z</updated>
    
    <content type="html"><![CDATA[<h1 id="写在前面"><a href="#写在前面" class="headerlink" title="写在前面"></a>写在前面</h1><p>本系列为在我基本完全读完了阮一峰老师的《ES6标准入门》第二版之后，所做的阅读笔记的整理，作为日后的复习使用。</p>
<p>许多初学ES6, 同时和我一样初次阅读阮老师的这本书的时候, 读第一遍会越发的困惑, 因为阮老师上面说的很多的定义,方法,之前都是没有见过的, 读到后面才发现, 哦~原来是这样.</p>
<p>有一句话叫做”大神的世界我们不懂”, 所以我在初读第一遍《ES6标准入门》这本书的时候,也是踩了不少坑,读书的时候查阅了不少的资料.</p>
<p>所以,在这一系列的笔记教程中,我会从一个初学者的角度,向您讲述ES6的相关知识,在后面介绍的知识我会尽量不提前用,即使提前使用,也会同时做好标注,避免了阅读时各种查阅资料的烦恼.</p>
<p>系列博客将采用一个一个的样例，来说明书中的精华部分（当然，这只是我认为的），同时引导像我这样的新手，快速入门ES6，并逐步将其投入到生产实践中。</p>
<p>同时,在阅读前也提醒您, 为了系统连贯性的学习ES6的基础知识,建议您从我的博客第一章开始阅读,当然,如果您对对应的知识已经有所了解,那么可以跳转到任意章节阅读,每一篇博客名中均有介绍该博客中涉及到的ES6的内容.</p>
<p>阮一峰老师的这本书是开源的，在其官方博客就可以下载到，但是我强烈建议大家去购买一本书, 一是方便自己查阅ES6中新增的众多API, 二也是表达一下对大神的敬仰.</p>
<h1 id="正则表达式的扩展"><a href="#正则表达式的扩展" class="headerlink" title="正则表达式的扩展"></a>正则表达式的扩展</h1><p>在ES6以前,正则表达式的构造函数只能接受字符串作为参数</p>
<p>但在ES6中,是允许RegExp构造函数使用正则表达式作为参数的,这时候会返回一个原有正则表达式的拷贝</p>
<p>如果在使用正则表达式的第二个参数时,则它将会使用第二个修饰符而忽略原有的正则表达式修饰符<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">var reg = new RegExp(/abc/ig, &apos;g&apos;).flags // .flags表示查找正则表达式的修饰符,如ige等</div><div class="line">console.log(reg) // g</div></pre></td></tr></table></figure></p>
<p>ES6新增了u修饰符,含义为Unicode模式, 用来正确处理大于\uFFFF 的Unicode字符</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">console.log(/^\ud83d/u.test(&apos;\ud83d\udc2a&apos;))</div><div class="line">console.log(/^\ud83d/.test(&apos;\ud83d\udc2a&apos;)) // 当不使用u操作符的时候,使用utf-16编码的字符无法被正常识别</div></pre></td></tr></table></figure>
<p>对于点字符,当字符为utf-16编码是,是无法正常被识别的,此时必须加上u修饰符</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">console.log(&apos;\u&#123;20bb7&#125;&apos;)</div><div class="line">var s = &apos;\u&#123;20bb7&#125;&apos;</div><div class="line">console.log(/^.$/.test(s)) // 当正则表达式的标识符不加u时,是不会被识别的,不会被匹配为任意字符,当然,主要原因还是因为它被当成两个字符了</div><div class="line">console.log(/^.$/u.test(s)) // true</div></pre></td></tr></table></figure>
<p>同时,ES6新增了使用大括号表示Unicode的表示法,这种表示法在正则表达式中必须加上u修饰符才能被识别</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">console.log(/\u&#123;61&#125;/.test(&apos;a&apos;))</div><div class="line"> // 当不使用u作为修饰符时,此正则表达式会被认为是u的61个重复</div><div class="line">console.log(/\u&#123;61&#125;/u.test(&apos;a&apos;))</div><div class="line"> // 使用u修饰符后,所有量词都会正确识别码点大于0xFFFF的Unicode字符</div><div class="line">console.log(/𠮷&#123;2&#125;/u.test(&apos;𠮷𠮷&apos;))</div><div class="line"> // 当我们使用\S(非空格字符)对四字节的字符进行匹配的时候,同样会产生问题:无法正常匹配,原因还是一样,之前ES5将这个字符理解成了两个字符了</div><div class="line">console.log(/^\S$/.test(&apos;𠮷&apos;))</div><div class="line">console.log(/^\S$/u.test(&apos;𠮷&apos;))</div></pre></td></tr></table></figure>
<p>除了u修饰符,ES6还为正则表达式添加了y修饰符,叫做黏连修饰符(y)</p>
<p>y修饰符的作用与g修饰符类似,也是全局匹配,后一次的匹配都会从上一次匹配成功的下一个位置开始.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">var s = &apos;sss_ss_s&apos;</div><div class="line">var r1 = /s+/g</div><div class="line">var r2 = /s+/yg</div><div class="line">console.log(s.match(r1))</div><div class="line">console.log(s.match(r2)) </div><div class="line">// 我们使用y修饰符进行匹配,因为同样的s是没有连贯性的出现在一起,所以导致后面的就无法匹配了</div><div class="line">var r3 = /s+_/g</div><div class="line">var r4 = /s+_/y</div><div class="line">console.log(s.match(r3))</div><div class="line">console.log(s.match(r4))</div><div class="line">console.log(s.match(r4))</div></pre></td></tr></table></figure>
<p>ES6为正则表达式提供了flags 和 source 方法,用于返回正则表达式的修饰符 和匹配正文</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">var r = /s/igy</div><div class="line">console.log(r.source)</div><div class="line">console.log(r.flags)</div></pre></td></tr></table></figure>
<p>(完)</p>
]]></content>
    
    <summary type="html">
    
      本系列为在我基本完全读完了阮一峰老师的《ES6标准入门》第二版之后，所做的阅读笔记的整理，作为日后的复习使用。 系列博客将采用一个一个的样例，来说明书中的精华部分（当然，这只是我认为的），同时引导像我这样的新手，快速入门ES6，并逐步将其投入到生产实践中。
    
    </summary>
    
      <category term="ES6标准入门" scheme="https://github.com/ChangerHe/categories/ES6%E6%A0%87%E5%87%86%E5%85%A5%E9%97%A8/"/>
    
    
      <category term="ES6" scheme="https://github.com/ChangerHe/tags/ES6/"/>
    
      <category term="RegExp" scheme="https://github.com/ChangerHe/tags/RegExp/"/>
    
  </entry>
  
  <entry>
    <title>《ES6标准入门》阅读笔记——-Unicode</title>
    <link href="https://github.com/ChangerHe/2017/06/19/%E3%80%8AES6%E6%A0%87%E5%87%86%E5%85%A5%E9%97%A8%E3%80%8B%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0%E2%80%94%E2%80%94-Unicode/"/>
    <id>https://github.com/ChangerHe/2017/06/19/《ES6标准入门》阅读笔记——-Unicode/</id>
    <published>2017-06-19T14:11:34.000Z</published>
    <updated>2017-09-16T05:46:44.244Z</updated>
    
    <content type="html"><![CDATA[<h1 id="写在前面"><a href="#写在前面" class="headerlink" title="写在前面"></a>写在前面</h1><p>本系列为在我基本完全读完了阮一峰老师的《ES6标准入门》第二版之后，所做的阅读笔记的整理，作为日后的复习使用。</p>
<p>许多初学ES6, 同时和我一样初次阅读阮老师的这本书的时候, 读第一遍会越发的困惑, 因为阮老师上面说的很多的定义,方法,之前都是没有见过的, 读到后面才发现, 哦~原来是这样.</p>
<p>有一句话叫做”大神的世界我们不懂”, 所以我在初读第一遍《ES6标准入门》这本书的时候,也是踩了不少坑,读书的时候查阅了不少的资料.</p>
<p>所以,在这一系列的笔记教程中,我会从一个初学者的角度,向您讲述ES6的相关知识,在后面介绍的知识我会尽量不提前用,即使提前使用,也会同时做好标注,避免了阅读时各种查阅资料的烦恼.</p>
<p>系列博客将采用一个一个的样例，来说明书中的精华部分（当然，这只是我认为的），同时引导像我这样的新手，快速入门ES6，并逐步将其投入到生产实践中。</p>
<p>同时,在阅读前也提醒您, 为了系统连贯性的学习ES6的基础知识,建议您从我的博客第一章开始阅读,当然,如果您对对应的知识已经有所了解,那么可以跳转到任意章节阅读,每一篇博客名中均有介绍该博客中涉及到的ES6的内容.</p>
<p>阮一峰老师的这本书是开源的，在其官方博客就可以下载到，但是我强烈建议大家去购买一本书, 一是方便自己查阅ES6中新增的众多API, 二也是表达一下对大神的敬仰.</p>
<h1 id="ES6加强了对Unicode的支持-并扩展了字符串对象"><a href="#ES6加强了对Unicode的支持-并扩展了字符串对象" class="headerlink" title="ES6加强了对Unicode的支持,并扩展了字符串对象"></a>ES6加强了对Unicode的支持,并扩展了字符串对象</h1><p>ES6对Unicode的主要的新增支持是,已经开始支持32位的字符了,要知道在之前,32位的字符是会被JS判定为两个字符的.</p>
<p>codePointAt()方法,可以很方便地判定字符是由2字节还是4字节组成</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">let a = &apos;\uD842\uDFB7&apos;</div><div class="line">console.log(a);  // 𠮷 在ES5中会被判定为两个字符</div><div class="line">let b = &apos;\u20BB7&apos;</div><div class="line">let c = &apos;\u&#123;20BB7&#125;&apos;</div><div class="line">console.log(b) // □7  未被识别</div><div class="line">console.log(c) // 𠮷</div><div class="line">let d = &apos;𠮷a&apos;</div><div class="line">console.log(d.length) // 3 把第一个字符当两个字符了</div><div class="line">console.log(d.charAt(0)) // 乱码</div><div class="line">console.log(d.charAt(1)) // 乱码</div><div class="line">console.log(d.charAt(2)) // a</div><div class="line">console.log(d.charAt(3)) // </div><div class="line">console.log(d.codePointAt(0)) // 134071</div><div class="line">console.log(d.codePointAt(1)) // 57271</div></pre></td></tr></table></figure>
<p>要知道在之前es5中定义的fromCharCode()方法中,只能够识别16位的字符,并将其转换为相应字符,但是当我们需要进行32位字符码点转换为字符的时候,就无能为力了,这个时候ES6定义了一个新的方法: fromCodePoint()</p>
<p>在ES6中新定义的for-of循环可以实现识别使用32位编码的字符</p>
<p>for of 循环也是ES6中新定义的循环方式,可以用来遍历数组,遍历的同时不同于for  in循环,for of循环不会遍历到你定义的原型上的可枚举属性,去除了for in循环的糟粕, 同时也避免了forEach循环不能跳出循环队列的问题,for of是可以随时跳出循环队列的. 同样的for of循环也可以遍历数组,对象等.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">let text = String.fromCodePoint(0x20bb7);</div><div class="line">for (let i = 0; i &lt; text.length; i++) &#123;</div><div class="line">	console.log(text[i])  // 乱码</div><div class="line">	console.log(i)  // 1</div><div class="line">&#125;</div><div class="line">for (let i of text) &#123;</div><div class="line">	console.log(i)  // 𠮷</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>ES5为字符串对象提供了charAt方法,返回给定位置的字符,该方法不能识别码点大于0xFFFF的字符</p>
<p>因此,ES7定义了at方法,用于识别码点大于0xFFFF的字符</p>
<p>但是,现在谷歌浏览器暂不支持, 需要通过babel转码</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">console.log(&apos;𠮷a&apos;.charAt(0)) // 乱码</div><div class="line">console.log(&apos;𠮷&apos;.at(0))  // 报错</div></pre></td></tr></table></figure>
<p>ES6新增了一些查找字符串的相应方法</p>
<blockquote>
<p>  includes() 返回布尔值,表示是否找到了参数字符串<br>  startsWith() 返回布尔值,表示字符串是否在元字符串的头部<br>  endsWith()  返回布尔值,表示参数自粗换是否在源字符串的头部<br>  repeat()  返回一个新字符串,表示将原字符串重复n次</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">var str = &apos;hello&apos;</div><div class="line">console.log(str.startsWith(&apos;he&apos;)) // true</div><div class="line">console.log(str.endsWith(&apos;lo&apos;)) // true</div><div class="line">console.log(str.includes(&apos;lo&apos;)) // true</div><div class="line">console.log(str.repeat(3))  // hellohellohello</div></pre></td></tr></table></figure>
<h1 id="ES6的模板字符串"><a href="#ES6的模板字符串" class="headerlink" title="ES6的模板字符串"></a>ES6的模板字符串</h1><p>使用变量直接添加到相应的字符串中 用法很简单,添加到相应的字符串中</p>
<p>需要注意的是,使用模板字符串的时候,需要使用反向引号将整体的字符串引起来,否则是无效的</p>
<p>模板字符串,其实就是模块化了的,放在${}里面的js代码</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">let name = &apos;Bob&apos;,</div><div class="line">	time = &apos;today&apos;</div><div class="line">console.log(`hello $&#123;name&#125;, how are you $&#123;time&#125;?`) </div><div class="line">// hello Bob, how are you today?</div><div class="line">console.log(&apos;hello $&#123;name&#125;&apos;) </div><div class="line">// hello $&#123;name&#125;</div></pre></td></tr></table></figure>
<p>模板字符串还拥有更加灵活的用法</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">let a = 1,</div><div class="line">	b = 2;</div><div class="line">console.log(`$&#123;a&#125; + $&#123;b&#125; = $&#123;a+b&#125;`)  // 1 + 2 = 3</div><div class="line"></div><div class="line">function foo() &#123;</div><div class="line">	return &apos;hello&apos;</div><div class="line">&#125;</div><div class="line"></div><div class="line">console.log(`$&#123;foo()&#125; world`) // hello world</div></pre></td></tr></table></figure>
<p>(完)</p>
]]></content>
    
    <summary type="html">
    
      本系列为在我基本完全读完了阮一峰老师的《ES6标准入门》第二版之后，所做的阅读笔记的整理，作为日后的复习使用。 系列博客将采用一个一个的样例，来说明书中的精华部分（当然，这只是我认为的），同时引导像我这样的新手，快速入门ES6，并逐步将其投入到生产实践中。
    
    </summary>
    
      <category term="ES6标准入门" scheme="https://github.com/ChangerHe/categories/ES6%E6%A0%87%E5%87%86%E5%85%A5%E9%97%A8/"/>
    
    
      <category term="ES6" scheme="https://github.com/ChangerHe/tags/ES6/"/>
    
      <category term="Unicode" scheme="https://github.com/ChangerHe/tags/Unicode/"/>
    
  </entry>
  
  <entry>
    <title>《ES6标准入门》阅读笔记———解构赋值</title>
    <link href="https://github.com/ChangerHe/2017/06/18/%E3%80%8AES6%E6%A0%87%E5%87%86%E5%85%A5%E9%97%A8%E3%80%8B%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0%E2%80%94%E2%80%94%E2%80%94%E8%A7%A3%E6%9E%84%E8%B5%8B%E5%80%BC/"/>
    <id>https://github.com/ChangerHe/2017/06/18/《ES6标准入门》阅读笔记———解构赋值/</id>
    <published>2017-06-18T13:21:39.000Z</published>
    <updated>2017-09-16T05:45:46.786Z</updated>
    
    <content type="html"><![CDATA[<h1 id="写在前面"><a href="#写在前面" class="headerlink" title="写在前面"></a>写在前面</h1><p>本系列为在我基本完全读完了阮一峰老师的《ES6标准入门》第二版之后，所做的阅读笔记的整理，作为日后的复习使用。</p>
<p>许多初学ES6, 同时和我一样初次阅读阮老师的这本书的时候, 读第一遍会越发的困惑, 因为阮老师上面说的很多的定义,方法,之前都是没有见过的, 读到后面才发现, 哦~原来是这样.</p>
<p>有一句话叫做”大神的世界我们不懂”, 所以我在初读第一遍《ES6标准入门》这本书的时候,也是踩了不少坑,读书的时候查阅了不少的资料.</p>
<p>所以,在这一系列的笔记教程中,我会从一个初学者的角度,向您讲述ES6的相关知识,在后面介绍的知识我会尽量不提前用,即使提前使用,也会同时做好标注,避免了阅读时各种查阅资料的烦恼.</p>
<p>系列博客将采用一个一个的样例，来说明书中的精华部分（当然，这只是我认为的），同时引导像我这样的新手，快速入门ES6，并逐步将其投入到生产实践中。</p>
<p>同时,在阅读前也提醒您, 为了系统连贯性的学习ES6的基础知识,建议您从我的博客第一章开始阅读,当然,如果您对对应的知识已经有所了解,那么可以跳转到任意章节阅读,每一篇博客名中均有介绍该博客中涉及到的ES6的内容.</p>
<p>阮一峰老师的这本书是开源的，在其官方博客就可以下载到，但是我强烈建议大家去购买一本书, 一是方便自己查阅ES6中新增的众多API, 二也是表达一下对大神的敬仰.</p>
<h1 id="什么是解构赋值"><a href="#什么是解构赋值" class="headerlink" title="什么是解构赋值?"></a>什么是解构赋值?</h1><p>ES6允许我们按照一定模式,从数组和对象中提取值,对变量进行赋值,这被称为解构</p>
<p>解构赋值可将数组的元素或对象的属性赋予给另一个变量，该变量的定义语法与数组字面量或对象字面量很相似。此语法非常简洁，相比于传统的属性访问方式，更加直观清晰。</p>
<p>在不使用解构赋值的情况下，通常我们这样访问数组中的元素：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">var first = arr[0];  </div><div class="line">var second = arr[1];  </div><div class="line">var third = arr[2];</div></pre></td></tr></table></figure>
<p>使用解构赋值后，代码得到了极大的简化，同时可读性也更强：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">var [first, second, third] = arr;</div></pre></td></tr></table></figure>
<p>以上代码的作用和上面的实例代码是一样的,声明三个变量,存储数组arr中的前三位的内容.</p>
<h1 id="数组的解构赋值"><a href="#数组的解构赋值" class="headerlink" title="数组的解构赋值"></a>数组的解构赋值</h1><p>我们将数组的对应位置定义好变量,同时在相同位置定义好对应值,就可以完成赋值操作</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">let [foo, [[bar], baz]] = [1,[[2],3]]</div><div class="line">console.log(foo, bar, baz)   // 1 2</div></pre></td></tr></table></figure>
<p>当我们对变量解构赋值的时候,不想赋值的地方可以使用空数组的键值代替.当需要使用一个变量匹配后面的所有未匹配数组的时候,使用三个点号代替</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">let [head, ...tail] = [1,2,3,4,5,6]</div><div class="line">console.log(head, tail)  // 1  [2,3,4,5,6]</div><div class="line">let [x, y, ...z] = [&apos;a&apos;];</div><div class="line">console.log(x,y,z)  // a undefined []</div></pre></td></tr></table></figure>
<p>三个点号也是ES6中的新语法, 在阮一峰老师的书中有两种叫法,一个叫做扩展运算符,一个叫做rest参数, 但是我觉得三点运算符好像更加的形象贴切啊哈哈. 当然,这个三点运算符会在数组这一章进行具体讲解.</p>
<p>解构不成功,表示右边的值不足以匹配左边的值,不完全解构,表示右边的值超出要赋予的左边的值<br>当出现如下情况的时候,f是只能匹配第一个数组元素的</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">let [e,[f],g] = [1,[2,3],4]</div><div class="line">console.log(e,f,g)   //1 2 4</div></pre></td></tr></table></figure>
<p>需要注意的是,当等号的右边不是数组,或者严格的说,不是可以遍历的结构的时候,是会报错的.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">let [a] = 1  // 报错</div></pre></td></tr></table></figure>
<p>对于解构赋值,我们可以使用Set结构,也可以使用数组的解构赋值</p>
<p>那么这里再解释一下啥叫set结构,ES6提供了一种新的数据结构Set,类似于数组,但成员值是唯一的,没有重复值. set本身是一个构造函数,用来生成set数据结构.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">let [h,i,j] = new Set([&apos;a&apos;,&apos;b&apos;,&apos;c&apos;])</div><div class="line">console.log(h,i,j)  // a b c</div></pre></td></tr></table></figure>
<p>解构赋值也允许使用默认值,所以,当我们为其不传值,或者传值为undefined的时候,是会使用默认值的</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">let [foo = true] = [undefined]</div><div class="line">console.log(foo)  // true</div></pre></td></tr></table></figure>
<p>但是因为ES6修复了很多之前因为 null == Object 而导致的许多问题,所以,在ES6中,因为其内部的判定机制,如果所属的值不严格等于undefined,那么其值为null的时候,是可以进行赋值的</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">let [foo = true] = [null]</div><div class="line">console.log(foo)</div></pre></td></tr></table></figure>
<h1 id="对象的解构赋值"><a href="#对象的解构赋值" class="headerlink" title="对象的解构赋值"></a>对象的解构赋值</h1><p>同样的,解构赋值也支持对对象的解构赋值</p>
<p>对象不同于数组,数组是按次序排列的,但是对象的属性时没有次序的,只能通过查找对象的键值来找到相应的值</p>
<p>在这里可能很多童鞋就有点懵逼了,为啥对象你写个名字,不赋值都行啊?</p>
<p>那么这里还是要再补充一下,ES6新增了一种对象的表示方法,  允许在对象之中，直接写变量。这时，属性名为变量名, 属性值为变量的值。也就是说:</p>
<blockquote>
<p><code>{bar, foo} === {bar: bar, foo: foo}</code></p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">var &#123;bar, foo&#125; = &#123;foo: &apos;aaa&apos;, bar: &apos;bbb&apos;&#125;</div><div class="line">console.log(foo)  // bbb</div><div class="line">console.log(bar)  // aaa</div></pre></td></tr></table></figure>
<p>需要注意的是,我们给对象进行解构赋值的时候,其实是赋值给了对象的键值,对象的键名是不会改变的.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">let obj = &#123;first: &apos;hello&apos;, last: &apos;world&apos;&#125;;</div><div class="line">let &#123;first: i, last: j&#125; = obj</div><div class="line">console.log(i, j) // hello  world</div></pre></td></tr></table></figure>
<p>那么还有一个问题就是,进行解构赋值的时候,我们必须将声明和赋值写在一起,不写在一起的话就会报错</p>
<p>在书写的时候有一个小坑也需要注意一下</p>
<p>当我们不加圆括号而是直接使用花括号的话,javascript引擎会把{foo}人为是一个语法块,从而不会正常进行语句的解构</p>
<p>那么解决办法就是将整条语句使用圆括号括起来,从而让引擎正确理解这条语句</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">let foo</div><div class="line">(&#123;foo&#125; = &#123;foo: 1&#125;)</div><div class="line">console.log(foo) // 1</div></pre></td></tr></table></figure>
<h1 id="使用解构赋值的小技巧"><a href="#使用解构赋值的小技巧" class="headerlink" title="使用解构赋值的小技巧"></a>使用解构赋值的小技巧</h1><p>当我们频繁使用某一个函数或是语句的时候,我们可以使用解构赋值,获得相应的更简便的书写方法</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">let &#123;logl, sin, cos&#125; = Math;</div><div class="line">console.log(cos(60))</div><div class="line">let &#123;log, dir, debug&#125; = console</div><div class="line">log(log)</div></pre></td></tr></table></figure>
<p>对应此方法,字符串也可以进行解构赋值,此时字符串被转换成了一个类似数组的对象</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">const str = &apos;abcd&apos;</div><div class="line">const [a, b, c, d] = str;</div><div class="line">const &#123;length: len&#125; = str</div><div class="line">console.log(a,b,c,d) // a b c d</div><div class="line">console.log(len)  // 4</div></pre></td></tr></table></figure>
<p>当等号右边是数值或布尔值的时候,会转换为对象,因此也拥有了此类的对象相应的方法和属性</p>
<p>需要注意的是,每个内部类型对象的构造函数中都是拥有toString的方法的</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">const &#123;toString: s&#125; = 123;</div><div class="line">console.log(s === Number.prototype.toString) // true</div><div class="line">console.log(s === Object.prototype.toString) // false</div></pre></td></tr></table></figure>
<h2 id="变量解构赋值在函数参数中的应用"><a href="#变量解构赋值在函数参数中的应用" class="headerlink" title="变量解构赋值在函数参数中的应用"></a>变量解构赋值在函数参数中的应用</h2><p>函数的参数也是可以参与到解构赋值中的</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">function add([x, y]) &#123;</div><div class="line">	return x + y;</div><div class="line">&#125;</div><div class="line">console.log(add([1,2]))</div></pre></td></tr></table></figure>
<p>我们可以将函数的返回值作为解构赋值的值来进行使用</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">function example() &#123;</div><div class="line">	return [1,2,3]</div><div class="line">&#125;</div><div class="line">var [a,b,c] = example()</div><div class="line">console.log(a,b,c)</div></pre></td></tr></table></figure>
<p>同样的,不仅能使用函数的返回值,还可以使用解构赋值给函数赋值</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">function f([x,y,z])&#123;&#125;</div><div class="line">f([1,2,3])</div><div class="line">function j(&#123;x,y,z&#125;)&#123;&#125;</div><div class="line">j(&#123;x: 1,y: 2, z: 3&#125;)</div></pre></td></tr></table></figure>
<p>因为解构赋值的特性,因此其对提取json数据有奇效</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">var jsonData = &#123;</div><div class="line">	id: 42,</div><div class="line">	status: &apos;OK&apos;,</div><div class="line">	data: [123,432]</div><div class="line">&#125;</div><div class="line">let &#123;id, status, data&#125; = jsonData</div><div class="line">console.log(id, status, data) // 42 OK [123, 432]</div></pre></td></tr></table></figure>
<p>遍历Map结构</p>
<p>Map结构也是ES6中定义的新的数据结构,它类似于对象,也是键值对的集合,但是键的范围不限于字符串,各种类型的值都可以当做键</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">var map = new Map();</div><div class="line">map.set(&apos;first&apos;, &apos;hello&apos;);</div><div class="line">map.set(&apos;second&apos;, &apos;world&apos;)</div><div class="line">for(let [key, value] of map) &#123;</div><div class="line">	console.log(key + &apos; is &apos; + value)</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>(完)</p>
]]></content>
    
    <summary type="html">
    
      本系列为在我基本完全读完了阮一峰老师的《ES6标准入门》第二版之后，所做的阅读笔记的整理，作为日后的复习使用。 系列博客将采用一个一个的样例，来说明书中的精华部分（当然，这只是我认为的），同时引导像我这样的新手，快速入门ES6，并逐步将其投入到生产实践中。
    
    </summary>
    
      <category term="ES6标准入门" scheme="https://github.com/ChangerHe/categories/ES6%E6%A0%87%E5%87%86%E5%85%A5%E9%97%A8/"/>
    
    
      <category term="ES6" scheme="https://github.com/ChangerHe/tags/ES6/"/>
    
      <category term="解构赋值" scheme="https://github.com/ChangerHe/tags/%E8%A7%A3%E6%9E%84%E8%B5%8B%E5%80%BC/"/>
    
  </entry>
  
  <entry>
    <title>《ES6标准入门》阅读笔记——let和const</title>
    <link href="https://github.com/ChangerHe/2017/06/17/%E3%80%8AES6%E6%A0%87%E5%87%86%E5%85%A5%E9%97%A8%E3%80%8B%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0%E2%80%94%E2%80%94let%E5%92%8Cconst/"/>
    <id>https://github.com/ChangerHe/2017/06/17/《ES6标准入门》阅读笔记——let和const/</id>
    <published>2017-06-17T13:33:39.000Z</published>
    <updated>2017-09-16T05:45:28.262Z</updated>
    
    <content type="html"><![CDATA[<h1 id="写在前面"><a href="#写在前面" class="headerlink" title="写在前面"></a>写在前面</h1><p>本系列为在我基本完全读完了阮一峰老师的《ES6标准入门》第二版之后，所做的阅读笔记的整理，作为日后的复习使用。</p>
<p>许多初学ES6, 同时和我一样初次阅读阮老师的这本书的时候, 读第一遍会越发的困惑, 因为阮老师上面说的很多的定义,方法,之前都是没有见过的, 读到后面才发现, 哦~原来是这样.</p>
<p>有一句话叫做”大神的世界我们不懂”, 所以我在初读第一遍《ES6标准入门》这本书的时候,也是踩了不少坑,读书的时候查阅了不少的资料.</p>
<p>所以,在这一系列的笔记教程中,我会从一个初学者的角度,向您讲述ES6的相关知识,在后面介绍的知识我会尽量不提前用,即使提前使用,也会同时做好标注,避免了阅读时各种查阅资料的烦恼.</p>
<p>系列博客将采用一个一个的样例，来说明书中的精华部分（当然，这只是我认为的），同时引导像我这样的新手，快速入门ES6，并逐步将其投入到生产实践中。</p>
<p>同时,在阅读前也提醒您, 为了系统连贯性的学习ES6的基础知识,建议您从我的博客第一章开始阅读,当然,如果您对对应的知识已经有所了解,那么可以跳转到任意章节阅读,每一篇博客名中均有介绍该博客中涉及到的ES6的内容.</p>
<p>阮一峰老师的这本书是开源的，在其官方博客就可以下载到，但是我强烈建议大家去购买一本书, 一是方便自己查阅ES6中新增的众多API, 二也是表达一下对大神的敬仰.</p>
<h1 id="函数的作用域"><a href="#函数的作用域" class="headerlink" title="函数的作用域"></a>函数的作用域</h1><p>要知道，在ES6以前，JS一直都是只有函数作用域，而没有块级作用域的。在这样的情况下，我们大多会使用IIFE（自执行函数表达式）来模拟块级作用域，达到避免全局作用域污染等目的。</p>
<p>那么ES6有新定义了两种变量的定义方式，let和const，两种变量的定义方式均会产生块级作用域，也就是我们使用大括号包起来的区域，都是块级作用域。</p>
<p>let和const两者之间的区别就是，const定义的变量，之后是无法更改的。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">&#123;</div><div class="line">	let a = 10;</div><div class="line">	var b = 1;</div><div class="line">&#125;</div><div class="line">console.log(b)</div><div class="line">console.log(a)   // 报错</div></pre></td></tr></table></figure>
<p>我们在大括号外面去打印a会报错,说明let其实是有块级作用域的,当我们使用循环语句的时候,let来声明变量是一个不错的选择.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">var a = [];</div><div class="line">for (let i = 0; i &lt; 10; i++) &#123;</div><div class="line">	a[i] = function() &#123;</div><div class="line">		console.log(i)</div><div class="line">	&#125;</div><div class="line">&#125;</div><div class="line">a[6]()    // 6</div></pre></td></tr></table></figure>
<p>当我们使用let来进行声明的时候,才能得到想要的值 也就是6</p>
<p>原因是因为,变量i是let声明的,当前的i只在本轮循环有效,所以相当于每一次循环的i都是一个新的变量</p>
<p>let 不和var一样,存在变量的提升,所以我们在没有声明之前调用let声明的变量,会报错</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">console.log(b)   // 报错</div><div class="line">let b = 2;</div></pre></td></tr></table></figure>
<p>还有一点要注意的是,我们在第一行使用var声明了b,在这里再声明,就会报错,因为let和const是不允许变量被重复声明的.</p>
<h1 id="暂时性死区"><a href="#暂时性死区" class="headerlink" title="暂时性死区"></a>暂时性死区</h1><p>只要块级作用域内存在let命令,那么它所声明的变量就绑定了这个区域,不会受外部的影响<br>es6明确规定,只要区块中存在let和const命令,则这个区块对这些命令声明的变量从一开始就形成封闭作用域.只要在声明之前就使用这些变量,就会报错</p>
<p>其实上面那个例子,已经很好地说明了暂时性死区这个概念了.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">var c = 3;</div><div class="line">if(true) &#123;</div><div class="line">	tmp = &apos;abc&apos;  //报错,tmp没有定义</div><div class="line">	let tmp</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>不仅如此,坑爹的是有些死区,你不仔细看真的很难发现</p>
<p>另外补充一点,在函数中进行形式参数的预定义,也就是设置函数的参数默认值,也是ES6中新定义的函数写法,关于此的内容,会在之后在函数篇中详细介绍.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">function bar(x = y, y = 2) &#123;</div><div class="line">	return [x, y]</div><div class="line">&#125;</div><div class="line">bar()  //报错, y is not defined</div></pre></td></tr></table></figure>
<p>当然,我们把上面的代码稍微改一下就不会报错了</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">function bac(y = 2, x = y) &#123;</div><div class="line">	return [x, y]</div><div class="line">&#125;</div><div class="line">console.log(bac()) // [2,2]</div></pre></td></tr></table></figure>
<p>结合上面的介绍,还有一点,当我们在块级作用域的内部再定义块级作用域的时候,就不会报错了.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">function f1() &#123;</div><div class="line">	let n = 5;</div><div class="line">	if (true) &#123;</div><div class="line">		let n = 10;</div><div class="line">	&#125;</div><div class="line">	console.log(n) // 5</div><div class="line">&#125;</div><div class="line">f1()</div></pre></td></tr></table></figure>
<p>讲到这里,我再分享一个坑,关于函数的声明提升问题,当然, 下面这一题我没有直接在题上写答案,大家可以把解析先遮住,思考一下这题的结果是什么.既然是坑, 我觉得新手还是老老实实往上踩几脚比较好.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">let f = function() &#123;</div><div class="line">	console.log(&apos;outside&apos;)</div><div class="line">&#125;</div><div class="line"></div><div class="line">function aaa() &#123;</div><div class="line">	if (false) &#123;</div><div class="line">		function f() &#123;</div><div class="line">			console.log(&apos;inside&apos;)</div><div class="line">		&#125;</div><div class="line"></div><div class="line">	&#125;</div><div class="line">	f()</div><div class="line">&#125;</div><div class="line">aaa()</div></pre></td></tr></table></figure>
<p>万万没想到啊没想到, aaa函数中f()函数的执行居然会报错,而且打印f的值居然是undefined!</p>
<p>这其实是一个函数的作用域提升问题,预编译阶段内部函数f会跨过if判断而提升至函数aaa的作用域顶端</p>
<p>那么可能大家会问,我在aaa函数内部打印f函数,是undefined啊.</p>
<p>因为函数的声明赋值时在if判断语句之内的,所以在此之前仅有一个var f,也就是定义了一个f,但并未对其赋值,所以f打印出来就是undefined.</p>
<h1 id="const和let的具体区别"><a href="#const和let的具体区别" class="headerlink" title="const和let的具体区别"></a>const和let的具体区别</h1><p>我们来看下面这几行代码</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">let f;</div><div class="line">console.log(f);  // undefined</div><div class="line">&#123;</div><div class="line">	let a = &apos;secret&apos;</div><div class="line">	console.log(f)  // undefined</div><div class="line">	f = function() &#123;</div><div class="line">		return a;</div><div class="line">	&#125;</div><div class="line">	console.log(f)  // f() &#123; return a &#125;</div><div class="line">&#125;</div><div class="line">console.log(f());   //secret</div></pre></td></tr></table></figure>
<p>其实上面的代码很好地说明了let的作用域的问题,而且需要注意的是,let的变量值,是可以随时更改的.</p>
<p>而const,就没有这么自由了</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">const PI = 3.14;</div><div class="line">PI = 3;   // 报错</div><div class="line">const foo;  // 定义变量时位对其赋值,报错</div></pre></td></tr></table></figure>
<p>需要注意的是const定义复合类型值的时候,因为复合类型的变量不直接指向数据,而是指向数据所存储的相应内存空间</p>
<p>所以这个时候当我们对相应的内存空间中的值进行更改,只要内存空间不变,则都可以对值进行更改</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">const foo = &#123;&#125;;</div><div class="line">foo.prop = 1;</div><div class="line">console.log(foo.prop)   // 1</div></pre></td></tr></table></figure>
<p>但是呢,,如果我们更改相应的foo指向的内存空间,则就会报错</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">foo = &#123;&#125;  // 报错(接上面的代码实例)</div></pre></td></tr></table></figure>
<p>如果在声明引用类型变量后,我们不想让里面的值改变怎么办呢?</p>
<p>这个时候可以使用Object.freeze()方法,冻结这个对象,包括其内存空间的值</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">const foo1 = Object.freeze(&#123;&#125;);</div><div class="line">foo1.prop = 1;</div><div class="line">console.log(foo1.prop)  // undefined</div></pre></td></tr></table></figure>
<p>这个时候为该对象定义属性和方法,都无效了,但是不会抛出异常</p>
<p>最后需要注意的一点是,即使我们在全局使用let或是const定义变量,变量都不会挂载到全局的window对象上.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">var a = 1</div><div class="line">let b = 2</div><div class="line">const c = 3</div><div class="line"></div><div class="line">console.log(window.a) // 1</div><div class="line">console.log(window.b) // undefined</div><div class="line">console.log(window.c) // undefined</div></pre></td></tr></table></figure>
<p>(完)</p>
]]></content>
    
    <summary type="html">
    
      本系列为在我基本完全读完了阮一峰老师的《ES6标准入门》第二版之后，所做的阅读笔记的整理，作为日后的复习使用。 系列博客将采用一个一个的样例，来说明书中的精华部分（当然，这只是我认为的），同时引导像我这样的新手，快速入门ES6，并逐步将其投入到生产实践中。
    
    </summary>
    
      <category term="ES6标准入门" scheme="https://github.com/ChangerHe/categories/ES6%E6%A0%87%E5%87%86%E5%85%A5%E9%97%A8/"/>
    
    
      <category term="ES6" scheme="https://github.com/ChangerHe/tags/ES6/"/>
    
      <category term="let" scheme="https://github.com/ChangerHe/tags/let/"/>
    
      <category term="const" scheme="https://github.com/ChangerHe/tags/const/"/>
    
  </entry>
  
  <entry>
    <title>Nodejs的require()模块源码解读</title>
    <link href="https://github.com/ChangerHe/2017/06/16/Nodejs%E7%9A%84require-%E6%A8%A1%E5%9D%97%E6%BA%90%E7%A0%81%E8%A7%A3%E8%AF%BB/"/>
    <id>https://github.com/ChangerHe/2017/06/16/Nodejs的require-模块源码解读/</id>
    <published>2017-06-16T11:44:27.000Z</published>
    <updated>2017-09-16T03:39:33.855Z</updated>
    
    <content type="html"><![CDATA[<p>2009年, nodejs项目诞生,所有模块一律为commonjs格式.</p>
<p>时至今日,Nodejs的包管理npm仓库,已经存放了十万百万级的模块,其中绝大部分都是使用的commonjs格式.</p>
<p>这种格式的核心就是require语句, 模块通过它进行加载.</p>
<h1 id="基本用法"><a href="#基本用法" class="headerlink" title="基本用法"></a>基本用法</h1><p>以下内容翻译自《Node使用手册》</p>
<p>当 Node 遇到 require(X) 时，按下面的顺序处理。</p>
<blockquote>
<p>（1）如果 X 是内置模块（比如 require(‘http’）)<br>　　a. 返回该模块。<br>　　b. 不再继续执行。<br>（2）如果 X 以 “./“ 或者 “/“ 或者 “../“ 开头<br>　　a. 根据 X 所在的父模块，确定 X 的绝对路径。<br>　　b. 将 X 当成文件，依次查找<code>X</code>,找不到之后会查找<code>X .js</code>,再找不到则找<code>X .json</code>,还找不到则找<code>X .node</code>，只要其中有一个存在，就返回该文件，不再继续执行。<br>　　c. 将 X 当成目录，依次查找<code>X /package.json</code>,找不到之后会查找<code>X /index.js</code>,再找不到则找<code>X /index.json</code>,还找不到则找<code>X /index.node</code>，只要其中有一个存在，就返回该文件，不再继续执行。<br>（3）如果 X 不带路径<br>　　a. 根据 X 所在的父模块，确定 X 可能的安装目录。<br>　　b. 依次在每个目录中，将 X 当成文件名或目录名加载。<br>（4） 抛出 “not found”</p>
</blockquote>
<h1 id="Module构造函数"><a href="#Module构造函数" class="headerlink" title="Module构造函数"></a>Module构造函数</h1><p>Module构造函数的部分源码是这样的</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">function Module(id, parent) &#123;</div><div class="line">  this.id = id;</div><div class="line">  this.exports = &#123;&#125;;</div><div class="line">  this.parent = parent;</div><div class="line">  this.filename = null;</div><div class="line">  this.loaded = false;</div><div class="line">  this.children = [];</div><div class="line">&#125;</div><div class="line"></div><div class="line">module.exports = Module;</div><div class="line"></div><div class="line">var module = new Module(filename, parent);</div></pre></td></tr></table></figure>
<p>上面代码中，Node 定义了一个构造函数 Module，所有的模块都是 Module 的实例。可以看到，当前模块（module.js）也是 Module 的一个实例。<br>每个实例都有自己的属性。下面通过一个例子，看看这些属性的值是什么。新建一个脚本文件 a.js 。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">// a.js</div><div class="line"></div><div class="line">console.log(&apos;module.id: &apos;, module.id);  //.</div><div class="line">console.log(&apos;module.exports: &apos;, module.exports); // &#123;&#125;</div><div class="line">console.log(&apos;module.parent: &apos;, module.parent); // null</div><div class="line">console.log(&apos;module.filename: &apos;, module.filename); // 当前文件路径</div><div class="line">console.log(&apos;module.loaded: &apos;, module.loaded); // false</div><div class="line">console.log(&apos;module.children: &apos;, module.children); //</div><div class="line">console.log(&apos;module.paths: &apos;, module.paths);</div></pre></td></tr></table></figure>
<p>可以看到，如果没有父模块，直接调用当前模块，parent 属性就是 null，id 属性就是一个点。filename 属性是模块的绝对路径，path 属性是一个数组，包含了模块可能的位置。另外，输出这些内容时，模块还没有全部加载，所以 loaded 属性为 false 。<br>新建另一个脚本文件 b.js，让其调用 a.js 。</p>
<p>上面代码中，由于 a.js 被 b.js 调用，所以 parent 属性指向 b.js 模块，id 属性和 filename 属性一致，都是模块的绝对路径。</p>
<h1 id="模块实例的-require-方法"><a href="#模块实例的-require-方法" class="headerlink" title="模块实例的 require 方法"></a>模块实例的 require 方法</h1><p>每个模块实例都有一个 require 方法。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">Module.prototype.require = function(path) &#123;</div><div class="line">return Module._load(path, this);</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<p>由此可知，require 并不是全局性命令，而是每个模块提供的一个内部方法，也就是说，只有在模块内部才能使用 require 命令（唯一的例外是 REPL 环境）。另外，require 其实内部调用 Module._load 方法。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div></pre></td><td class="code"><pre><div class="line">Module._load = function(request, parent, isMain) &#123;</div><div class="line"></div><div class="line">//  计算绝对路径</div><div class="line">var filename = Module._resolveFilename(request, parent);</div><div class="line"></div><div class="line">//  第一步：如果有缓存，取出缓存</div><div class="line">var cachedModule = Module._cache[filename];</div><div class="line">if (cachedModule) &#123;</div><div class="line">return cachedModule.exports;</div><div class="line"></div><div class="line">// 第二步：是否为内置模块</div><div class="line">if (NativeModule.exists(filename)) &#123;</div><div class="line">return NativeModule.require(filename);</div><div class="line">&#125;</div><div class="line"></div><div class="line">// 第三步：生成模块实例，存入缓存</div><div class="line">var module = new Module(filename, parent);</div><div class="line">Module._cache[filename] = module;</div><div class="line"></div><div class="line">// 第四步：加载模块</div><div class="line">try &#123;</div><div class="line">module.load(filename);</div><div class="line">hadException = false;</div><div class="line">&#125; finally &#123;</div><div class="line">if (hadException) &#123;</div><div class="line">delete Module._cache[filename];</div><div class="line">&#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">// 第五步：输出模块的exports属性</div><div class="line">return module.exports;</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<p>上面代码中，首先解析出模块的绝对路径（filename），以它作为模块的识别符。然后，如果模块已经在缓存中，就从缓存取出；如果不在缓存中，就加载模块。</p>
<p>因此，Module._load 的关键步骤是两个。</p>
<p>Module._resolveFilename() ：确定模块的绝对路径<br>module.load()：加载模块</p>
<h1 id="模块的绝对路径"><a href="#模块的绝对路径" class="headerlink" title="模块的绝对路径"></a>模块的绝对路径</h1><p>下面是 Module._resolveFilename 方法的源码。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line">Module._resolveFilename = function(request, parent) &#123;</div><div class="line"></div><div class="line">// 第一步：如果是内置模块，不含路径返回</div><div class="line">if (NativeModule.exists(request)) &#123;</div><div class="line">return request;</div><div class="line">&#125;</div><div class="line"></div><div class="line">// 第二步：确定所有可能的路径</div><div class="line">var resolvedModule = Module._resolveLookupPaths(request, parent);</div><div class="line">var id = resolvedModule[0];</div><div class="line">var paths = resolvedModule[1];</div><div class="line"></div><div class="line">// 第三步：确定哪一个路径为真</div><div class="line">var filename = Module._findPath(request, paths);</div><div class="line">if (!filename) &#123;</div><div class="line">var err = new Error(&quot;Cannot find module &apos;&quot; + request + &quot;&apos;&quot;);</div><div class="line">err.code = &apos;MODULE_NOT_FOUND&apos;;</div><div class="line">throw err;</div><div class="line">&#125;</div><div class="line">return filename;</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<p>上面代码中，在 Module.resolveFilename 方法内部，又调用了两个方法 Module.resolveLookupPaths() 和 Module._findPath() ，前者用来列出可能的路径，后者用来确认哪一个路径为真。<br>为了简洁起见，这里只给出 Module._resolveLookupPaths() 的运行结果。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">[   &apos;/home/ruanyf/tmp/node_modules&apos;,</div><div class="line">&apos;/home/ruanyf/node_modules&apos;,</div><div class="line">&apos;/home/node_modules&apos;,</div><div class="line">&apos;/node_modules&apos;</div><div class="line">&apos;/home/ruanyf/.node_modules&apos;,</div><div class="line">&apos;/home/ruanyf/.node_libraries&apos;，</div><div class="line">&apos;$Prefix/lib/node&apos; ]</div></pre></td></tr></table></figure>
<p>上面的数组，就是模块所有可能的路径。基本上是，从当前路径开始一级级向上寻找 node_modules 子目录。最后那三个路径，主要是为了历史原因保持兼容，实际上已经很少用了。<br>有了可能的路径以后，下面就是 Module._findPath() 的源码，用来确定到底哪一个是正确路径。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div></pre></td><td class="code"><pre><div class="line">Module._findPath = function(request, paths) &#123;</div><div class="line"></div><div class="line">// 列出所有可能的后缀名：.js，.json, .node</div><div class="line">var exts = Object.keys(Module._extensions);</div><div class="line"></div><div class="line">// 如果是绝对路径，就不再搜索</div><div class="line">if (request.charAt(0) === &apos;/&apos;) &#123;</div><div class="line">paths = [&apos;&apos;];</div><div class="line">&#125;</div><div class="line"></div><div class="line">// 是否有后缀的目录斜杠</div><div class="line">var trailingSlash = (request.slice(-1) === &apos;/&apos;);</div><div class="line"></div><div class="line">// 第一步：如果当前路径已在缓存中，就直接返回缓存</div><div class="line">var cacheKey = JSON.stringify(&#123;request: request, paths: paths&#125;);</div><div class="line">if (Module._pathCache[cacheKey]) &#123;</div><div class="line">return Module._pathCache[cacheKey];</div><div class="line">&#125;</div><div class="line"></div><div class="line">// 第二步：依次遍历所有路径</div><div class="line">for (var i = 0, PL = paths.length; i &lt; PL; i++) &#123;</div><div class="line">var basePath = path.resolve(paths[i], request);</div><div class="line">var filename;</div><div class="line"></div><div class="line">if (!trailingSlash) &#123;</div><div class="line">// 第三步：是否存在该模块文件</div><div class="line">filename = tryFile(basePath);</div><div class="line"></div><div class="line">if (!filename &amp;&amp; !trailingSlash) &#123;</div><div class="line">// 第四步：该模块文件加上后缀名，是否存在</div><div class="line">filename = tryExtensions(basePath, exts);</div><div class="line">&#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">// 第五步：目录中是否存在 package.json</div><div class="line">if (!filename) &#123;</div><div class="line">filename = tryPackage(basePath, exts);</div><div class="line">&#125;</div><div class="line"></div><div class="line">if (!filename) &#123;</div><div class="line">// 第六步：是否存在目录名 + index + 后缀名</div><div class="line">filename = tryExtensions(path.resolve(basePath, &apos;index&apos;), exts);</div><div class="line">&#125;</div><div class="line"></div><div class="line">// 第七步：将找到的文件路径存入返回缓存，然后返回</div><div class="line">if (filename) &#123;</div><div class="line">Module._pathCache[cacheKey] = filename;</div><div class="line">return filename;</div><div class="line">&#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">// 第八步：没有找到文件，返回false</div><div class="line">return false;</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<p>经过上面代码，就可以找到模块的绝对路径了。<br>有时在项目代码中，需要调用模块的绝对路径，那么除了 module.filename ，Node 还提供一个 require.resolve 方法，供外部调用，用于从模块名取到绝对路径。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">require.resolve = function(request) &#123;</div><div class="line">return Module._resolveFilename(request, self);</div><div class="line">&#125;;</div><div class="line"></div><div class="line">// 用法</div><div class="line">require.resolve(&apos;a.js&apos;)</div><div class="line">// 返回 /home/ruanyf/tmp/a.js</div></pre></td></tr></table></figure>
<h1 id="加载模块"><a href="#加载模块" class="headerlink" title="加载模块"></a>加载模块</h1><p>有了模块的绝对路径，就可以加载该模块了。下面是 module.load 方法的源码。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">Module.prototype.load = function(filename) &#123;</div><div class="line">var extension = path.extname(filename) || &apos;.js&apos;;</div><div class="line">if (!Module._extensions[extension]) extension = &apos;.js&apos;;</div><div class="line">Module._extensions[extension](this, filename);</div><div class="line">this.loaded = true;</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<p>上面代码中，首先确定模块的后缀名，不同的后缀名对应不同的加载方法。下面是 .js 和 .json 后缀名对应的处理方法。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">Module._extensions[&apos;.js&apos;] = function(module, filename) &#123;</div><div class="line">var content = fs.readFileSync(filename, &apos;utf8&apos;);</div><div class="line">module._compile(stripBOM(content), filename);</div><div class="line">&#125;;</div><div class="line"></div><div class="line">Module._extensions[&apos;.json&apos;] = function(module, filename) &#123;</div><div class="line">var content = fs.readFileSync(filename, &apos;utf8&apos;);</div><div class="line">try &#123;</div><div class="line">module.exports = JSON.parse(stripBOM(content));</div><div class="line">&#125; catch (err) &#123;</div><div class="line">err.message = filename + &apos;: &apos; + err.message;</div><div class="line">throw err;</div><div class="line">&#125;</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<p>这里只讨论 js 文件的加载。首先，将模块文件读取成字符串，然后剥离 utf8 编码特有的BOM文件头，最后编译该模块。<br>module._compile 方法用于模块的编译。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">Module.prototype._compile = function(content, filename) &#123;</div><div class="line">var self = this;</div><div class="line">var args = [self.exports, require, self, filename, dirname];</div><div class="line">return compiledWrapper.apply(self.exports, args);</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<p>上面的代码基本等同于下面的形式。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">(function (exports, require, module, __filename, __dirname) &#123;</div><div class="line">// 模块源码</div><div class="line">&#125;);</div></pre></td></tr></table></figure>
<p>也就是说，模块的加载实质上就是，注入exports、require、module三个全局变量，然后执行模块的源码，然后将模块的 exports 变量的值输出。</p>
<p>(以上文章转载自阮一峰博客)</p>
]]></content>
    
    <summary type="html">
    
      Nodejs的require()模块源码解读
    
    </summary>
    
      <category term="Nodejs学习笔记" scheme="https://github.com/ChangerHe/categories/Nodejs%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="Nodejs" scheme="https://github.com/ChangerHe/tags/Nodejs/"/>
    
      <category term="require" scheme="https://github.com/ChangerHe/tags/require/"/>
    
  </entry>
  
  <entry>
    <title>使用Nodejs实现简单的自动化构建</title>
    <link href="https://github.com/ChangerHe/2017/06/15/%E4%BD%BF%E7%94%A8Nodejs%E5%AE%9E%E7%8E%B0%E7%AE%80%E5%8D%95%E7%9A%84%E8%87%AA%E5%8A%A8%E5%8C%96%E6%9E%84%E5%BB%BA/"/>
    <id>https://github.com/ChangerHe/2017/06/15/使用Nodejs实现简单的自动化构建/</id>
    <published>2017-06-15T15:56:30.000Z</published>
    <updated>2017-09-14T14:35:01.695Z</updated>
    
    <content type="html"><![CDATA[<p>自动化构建是现代前端基本都需要的东西,说起这个,大家自然会想到 Glup/Grount这些自动化的构建工具.</p>
<p>当然,本文只是从最最基础的角度,使用Node的fs模块进行了简单的文档的写入操作.</p>
<p>首先,我们先定义一个JSON,用于存放我们想要预先定义的文件夹的内容,比如说,我想要我的文件夹名称为<code>ProjectModule</code> ,里面的文件夹有 <code>css</code> / <code>js</code> / <code>img</code> 还有一个 <code>index.html</code>,同时定义好index文件中的内容</p>
<p>那么我的JSON结构可以这样写</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line">var projectData = &#123;</div><div class="line">    &apos;name&apos; : &apos;ProjectModule&apos;,</div><div class="line">    &apos;fileData&apos;: [</div><div class="line">        &#123;</div><div class="line">            &apos;name&apos;: &apos;css&apos;,</div><div class="line">            &apos;type&apos;: &apos;dir&apos;</div><div class="line">        &#125;,</div><div class="line">        &#123;</div><div class="line">            &apos;name&apos;: &apos;js&apos;,</div><div class="line">            &apos;type&apos;: &apos;dir&apos;</div><div class="line">        &#125;,</div><div class="line">        &#123;</div><div class="line">            &apos;name&apos;: &apos;img&apos;,</div><div class="line">            &apos;type&apos;: &apos;dir&apos;</div><div class="line">        &#125;,</div><div class="line">        &#123;</div><div class="line">            &apos;name&apos;: &apos;index.html&apos;,</div><div class="line">            &apos;type&apos;: &apos;file&apos;,</div><div class="line">            &apos;content&apos;: &apos;&lt;html&gt;\n\t&lt;head&gt;\n\t&lt;title&gt;MyProject&lt;/title&gt;\n\t&lt;/head&gt;\n\t&lt;body&gt;\n\t&lt;/body&gt;\n&lt;/html&gt;&apos;</div><div class="line">        &#125;</div><div class="line">    ]</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>接下来,就是引入fs模块</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">var fs = require(&apos;fs&apos;)</div></pre></td></tr></table></figure>
<p>因为这里是要实时创建的,我们可以直接使用同步的操作,就省去了异步需要使用回调函数的麻烦</p>
<p>当然,开始之前,要先确定一下,JSON是否有正常的给出文件夹的名称</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line">if(projectData.name) &#123;</div><div class="line"></div><div class="line">    fs.mkdirSync(projectData.name)</div><div class="line"></div><div class="line">    var fileData = projectData.fileData</div><div class="line"></div><div class="line">    fileData.forEach(function(f) &#123;</div><div class="line"></div><div class="line">        f.content = f.content? f.content : &apos;&apos;</div><div class="line"></div><div class="line">        f.path = projectData.name + &apos;/&apos; + f.name</div><div class="line"></div><div class="line">        switch (f.type) &#123;</div><div class="line">            </div><div class="line">            case &apos;dir&apos;:</div><div class="line">                fs.mkdirSync(f.path)</div><div class="line">                break;</div><div class="line">            case &apos;file&apos;:</div><div class="line">                fs.writeFileSync(f.path, f.content)</div><div class="line">                break;</div><div class="line">            default:</div><div class="line">                break;</div><div class="line">        &#125;</div><div class="line">    &#125;)</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>如果使用的是webstorm, 那么直接使用ctrl+f9, 让你的node程序跑起来吧~</p>
]]></content>
    
    <summary type="html">
    
      自动化构建是现代前端基本都需要的东西,说起这个,大家自然会想到 Glup/Grount这些自动化的构建工具.
当然,本文只是从最最基础的角度,使用Node的fs模块进行了简单的文档的写入操作.
    
    </summary>
    
      <category term="Nodejs学习笔记" scheme="https://github.com/ChangerHe/categories/Nodejs%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="Nodejs学习笔记" scheme="https://github.com/ChangerHe/tags/Nodejs%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>ES6中的遍历器接口Iterator</title>
    <link href="https://github.com/ChangerHe/2017/06/15/ES6%E4%B8%AD%E7%9A%84%E9%81%8D%E5%8E%86%E5%99%A8%E6%8E%A5%E5%8F%A3Iterator/"/>
    <id>https://github.com/ChangerHe/2017/06/15/ES6中的遍历器接口Iterator/</id>
    <published>2017-06-15T15:34:18.000Z</published>
    <updated>2017-09-14T14:39:16.288Z</updated>
    
    <content type="html"><![CDATA[<p>初读阮一峰老师的这本书,简直如发现了新世界一般.原来ES6的语法是如此的清奇.</p>
<p>随着ES6, ES7, 到今年七月份的ES8. 我们会发现,javascript这门最初被定义在客户端的’玩具语言’已经变得越发的强壮和标准,这也是我们作为前端ers 所希望看到的,毕竟,这涉及到以后的饭碗呢哈哈.</p>
<p>阮一峰老师的文笔还是不错的,但是随着后面的阅读,会发现有一些后面的知识,被直接不明就里的拿到前面来用了,这就导致我这个新手小白就有点懵逼了.</p>
<p>比如说: 箭头函数,当然,这个比较好理解,有固定的语法</p>
<p>但是,阮老师一直有提到的iterator接口,到底是个啥? 估计初学ES6的新手小白自然会有着和我一样的困惑.</p>
<p>那么,下面就综合我的搜索和总结,对iterator接口的相关知识,做一个分享,也算是对自己所学的一个总结</p>
<h1 id="iterator接口是什么"><a href="#iterator接口是什么" class="headerlink" title="iterator接口是什么"></a>iterator接口是什么</h1><p>不知大家碰到此问题的时候是不是和我一样马上选择了百度(毕竟英语不够好,不能随随便便Google一下啊),泪奔~</p>
<p>百度上面会告诉你, Java的iterator很好用巴拉巴拉</p>
<p>那么,在javascript中,iterator接口到底是个神马东西呢?</p>
<p>iterator, 其实就是一个迭代器,或者说,是一个迭代器</p>
<p>在es6中，能表示“集合”概念的数据类型大致有四种:Array,Object,Map,Set</p>
<p>既然是集合，那遍历便是一种基本需求。而Iterator就是为了提供一种统一的接口机制。任何的数据结构，只要部署了Iterator接口，便可以使用类似的方式完成遍历操作。</p>
<p>当然，Iterator还有2个作用，它使数据结构的成员按某种次序排列，其次，es6有一种新的遍历方式，前面也说过，for…of，而Iterator的主要作用，就是支持此操作。</p>
<h2 id="Iteartor的遍历过程是这样的"><a href="#Iteartor的遍历过程是这样的" class="headerlink" title="Iteartor的遍历过程是这样的"></a>Iteartor的遍历过程是这样的</h2><blockquote>
<p>创建一个指向数据结构起始位置的指针。(起始位置不是第一个成员的位置，起始位置使一个单独的标志位。)</p>
<p>当调用next()方法，指针就向后移动一个位置，并返回当前位置上的成员，直到指针指向数据结构的结束位置为止。</p>
</blockquote>
<p>第二步中，js语言返回的的成员信息是两个，value和done，value不用介绍，done是一个表示遍历是否结束的布尔值。</p>
<h1 id="部署接口"><a href="#部署接口" class="headerlink" title="部署接口"></a>部署接口</h1><p>上面我们说到的部署接口，那js怎么部署接口呢。其实我们之前已经说到过，在Symbol一节中，介绍了很多es6内置的Symbol值，这些就是接口。</p>
<p>es6中有三类结构生来就具有Iterator接口：数组、类数组对象、Map和Set结构。</p>
<p>当然,如果你和我一样,现在看到第八章的话,暂时是没有学到Map和Set结构的,这个看下就好</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">var arr = [1,2,3,4];</div><div class="line">let iterator = arr[Symbol.iterator]();</div><div class="line"></div><div class="line">console.log(iterator.next());  //&#123; value: 1, done: false &#125;</div><div class="line">console.log(iterator.next());  //&#123; value: 2, done: false &#125;</div><div class="line">console.log(iterator.next());  //&#123; value: 3, done: false &#125;</div><div class="line">console.log(iterator.next());  //&#123; value: 4, done: false &#125;</div><div class="line">console.log(iterator.next());  //&#123; value: undefined, done: true &#125;</div></pre></td></tr></table></figure>
<p>数组，Map等结构中的成员都是有顺序的，即都是线性的结构，而对象，各成员并没有一个确定的顺序，所以遍历时先遍历谁后遍历谁并不确定。所以，给一个对象部署iterator接口，其实就是对该对象做一种线性转换。</p>
<p>如果有需要，可以手动给对象部署iterator接口</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line">let obj = &#123;</div><div class="line">    data: [ &apos;hello&apos;, &apos;world&apos; ],</div><div class="line">    [Symbol.iterator]() &#123;</div><div class="line">        const self = this;</div><div class="line">        let index = 0;</div><div class="line">        return &#123;</div><div class="line">            next() &#123;</div><div class="line">                if (index &lt; self.data.length) &#123;</div><div class="line">                    return &#123;</div><div class="line">                        value: self.data[index++],</div><div class="line">                        done: false</div><div class="line">                    &#125;;</div><div class="line">                &#125; else &#123;</div><div class="line">                    return &#123; value: undefined, done: true &#125;;</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">        &#125;;</div><div class="line">    &#125;</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<p>可以看到，Symbol.iterator会返回一个对象，这就是一个遍历器对象，而作为遍历器对象，其必须具备的特征就是必须具备next()方法。</p>
<p>至于可以使用Array.from转换成数组的类数组对象，部署iterator有一种很简单的方法，即直接使用数组的[Symbol.iterator]接口。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">fakeArray.prototype[Symbol.iterator] = Array.prototype[Symbol.iterator];</div></pre></td></tr></table></figure>
<p>用Generator函数来实现Symbol.iterator接口，事半功倍。</p>
<p>这也是看到第八章我要出来百度的原因,因为影响到了我正常的往下阅读了</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">var yieldIterator = &#123;&#125;;</div><div class="line">yieldIterator[Symbol.iterator] = function* () &#123;</div><div class="line">    yield 1;</div><div class="line">    yield 2;</div><div class="line">    yield 3;</div><div class="line">&#125;;</div><div class="line"></div><div class="line">[...yieldIterator] // [1, 2, 3]</div></pre></td></tr></table></figure>
<p>注意，yield* 后面跟的是一个可遍历的结构，它会调用该结构的遍历器接口。</p>
<p>　　其次，其它调用到遍历器的操作还有解构赋值、扩展操作符、其它任何接受数组作为参数的场合，如：</p>
<blockquote>
<p>for…of<br>Array.from()<br>Map(), Set(), WeakMap(), WeakSet()（比如）<br>Promise.all()<br>Promise.race()</p>
</blockquote>
<p>一旦当你给你的结构部署了iterator接口，那么恭喜你，你可以使用for…of来遍历你的结构了！</p>
<p>遍历器对象除了必须布置next方法以外，还有2个可选方法。return()和throw()。当一个解构在遍历的时候异常提前退出(比如break,continue或者出错)的时候，就会调用return方法，其次，return方法必须返回一个对象。</p>
<p>至于throw方法，则是用于抛出错误，Generator.prototype.throw</p>
<p>for of循环有很多优点，比如不像for…in一样只遍历键名（甚至包括原型链上的键），而且不像foreach不能跳出循环。并且for…of为各种数据结构提供了一个统一的遍历方法。所以，尽量使用它吧~</p>
]]></content>
    
    <summary type="html">
    
      初读阮一峰老师的这本书,简直如发现了新世界一般.原来ES6的语法是如此的清奇.
随着ES6, ES7, 到今年七月份的ES8. 我们会发现,javascript这门最初被定义在客户端的&#39;玩具语言&#39;已经变得越发的强壮和标准,这也是我们作为前端ers 所希望看到的,毕竟,这涉及到以后的饭碗呢哈哈.
    
    </summary>
    
      <category term="ES6标准入门阅读笔记" scheme="https://github.com/ChangerHe/categories/ES6%E6%A0%87%E5%87%86%E5%85%A5%E9%97%A8%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="ES6标准入门阅读笔记" scheme="https://github.com/ChangerHe/tags/ES6%E6%A0%87%E5%87%86%E5%85%A5%E9%97%A8%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>JavaScript躲坑指南（一）</title>
    <link href="https://github.com/ChangerHe/2017/06/15/JavaScript%E8%BA%B2%E5%9D%91%E6%8C%87%E5%8D%97%EF%BC%88%E4%B8%80%EF%BC%89/"/>
    <id>https://github.com/ChangerHe/2017/06/15/JavaScript躲坑指南（一）/</id>
    <published>2017-06-15T15:03:29.000Z</published>
    <updated>2017-09-14T14:37:46.143Z</updated>
    
    <content type="html"><![CDATA[<p>本系列将会写一些在正常工作中会遇到的一些坑,然后分析它们的产生原因及解决办法.本文的内容主要来自&lt;you don’t know JS&gt;及日常工作的问题的一些总结.</p>
<h1 id="坑一-关于parseInt-方法转换字符串的问题-神坑"><a href="#坑一-关于parseInt-方法转换字符串的问题-神坑" class="headerlink" title="坑一: 关于parseInt()方法转换字符串的问题,神坑!"></a>坑一: 关于parseInt()方法转换字符串的问题,神坑!</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">console.log(parseInt(1/0, 19));  //18</div><div class="line">//原因:1/0得到的结果是Infinity,而得到的Infinity本身其实也是一个字符串,所以parseInt会以19进制对其进行类型转换,首字母为I,则其结果则为18了.</div><div class="line">console.log(parseInt(.000009))    //0</div><div class="line">console.log(parseInt(.0000009))   //9</div><div class="line">console.log(parseInt(false, 16))  //250,判定&apos;false&apos;的字符串的&apos;fa&apos;为十六进制了</div><div class="line">console.log(parseInt(parseInt, 16))  //15</div><div class="line">//结果为15的原因是因为parseInt为函数,所以会被typeof为function,</div></pre></td></tr></table></figure>
<h1 id="坑二-位运算符-的妙用"><a href="#坑二-位运算符-的妙用" class="headerlink" title="坑二: 位运算符~的妙用:"></a>坑二: 位运算符~的妙用:</h1><p>在许多编程语言中,查找值或函数执行过程中,大于等于0的值表示查找或执行成功,返回-1则表示查找或执行失败.因此当失败时,可以直接使用位运算符~进行判定,当为-1时, -(-1 + 1) 即为零,因此就可以直接进行布尔运算了.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">var a = &quot;hello world&quot;;</div><div class="line">if(~a.indexof(&quot;lo&quot;))&#123;</div><div class="line">	//查找不到值,则执行函数体中的内容</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>位运算的另一个巧妙用法:将值截除为一个32位整数</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">console.log(Math.floor(-.1))  //-1</div><div class="line">console.log(Math.floor(.1))  //0</div><div class="line">console.log(~~-.1)   // 0</div><div class="line">console.log(~~.1)    //0</div></pre></td></tr></table></figure>
<h1 id="坑三-对于稀疏数组的输出差异"><a href="#坑三-对于稀疏数组的输出差异" class="headerlink" title="坑三: 对于稀疏数组的输出差异"></a>坑三: 对于稀疏数组的输出差异</h1><p>在谷歌浏览器中,对于长度为三,无内容的稀疏数组显示为undefined*3,对于长度为三,但内容都赋值为undefined的数组,显示为[undefined, undefined, undefined].但是此情况在IE浏览器中显示的内容都是两个等号!不过在火狐中相对比较正常,输出的是文字”三个空的数组”和[undefined, undefined, undefined]</p>
<h1 id="坑四-JSON-stringify的妙用"><a href="#坑四-JSON-stringify的妙用" class="headerlink" title="坑四: JSON.stringify的妙用:"></a>坑四: JSON.stringify的妙用:</h1><p>在序列化为JSON对象时,将该对象选择性输出,以得到想要的值;</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">var a = &#123;</div><div class="line">    b: 42,</div><div class="line">    c: &apos;41&apos;,</div><div class="line">    d: [1,2,3]</div><div class="line">&#125;</div><div class="line">console.log(JSON.stringify(a, [&apos;b&apos;,&apos;d&apos;]))   //&#123;&quot;b&quot;:42,&quot;d&quot;:[1,2,3]&#125;</div></pre></td></tr></table></figure>
<p>当然,这个时候stringify还可以传递一个函数进去进行判断.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">var a = &#123;</div><div class="line">    b: 42,</div><div class="line">    c: &apos;41&apos;,</div><div class="line">    d: [1,2,3]</div><div class="line">&#125;</div><div class="line">console.log(JSON.stringify(a, function(k, v)&#123;</div><div class="line">	if(k !== &apos;c&apos;) return v;</div><div class="line">&#125;))   //&#123;&quot;b&quot;:42,&quot;d&quot;:[1,2,3]&#125;</div></pre></td></tr></table></figure>
<p>JSON.stringify()还有一个参数space,用来指定输出的缩进格式,space为数值时表示缩进的字符数,还可以是字符串,为字符串时最前面的十个字符用于每一级的缩进:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">var a = &#123;</div><div class="line">    b: 42,</div><div class="line">    c: &apos;41&apos;,</div><div class="line">    d: [1,2,3]</div><div class="line">&#125;</div><div class="line">console.log(JSON.stringify(a, null, &quot;------------------&quot;));</div><div class="line">//&#123;</div><div class="line">//----------&quot;b&quot;: 42,</div><div class="line">//----------&quot;c&quot;: &quot;41&quot;,</div><div class="line">//----------&quot;d&quot;: [</div><div class="line">//--------------------1,</div><div class="line">//--------------------2,</div><div class="line">//--------------------3</div><div class="line">//----------]</div><div class="line">//&#125;</div></pre></td></tr></table></figure>
<p>从上面来看,使用位运算得到的值和Math.floor() 的值不尽相同,使用位运算相当于直接去掉了数字的小数点.</p>
<h1 id="坑五-当在函数内部为变量指定新值后-并不影响传参的值"><a href="#坑五-当在函数内部为变量指定新值后-并不影响传参的值" class="headerlink" title="坑五: 当在函数内部为变量指定新值后,并不影响传参的值."></a>坑五: 当在函数内部为变量指定新值后,并不影响传参的值.</h1><p>当函数内部制定了变量值后,输出的值是不一样的,我们来看一下例子:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">function foo(x) &#123;</div><div class="line">	x.push(4);</div><div class="line">	console.log(x);   //输出的是[1,2,3,4],没毛病</div><div class="line">	x = [4,5,6];</div><div class="line">	x.push(7);</div><div class="line">	console.log(x);   //输出[4,5,6,7]这个没毛病</div><div class="line">&#125;</div><div class="line">var a = [1,2,3];</div><div class="line">foo(a);</div><div class="line">console.log(a);     //这个情况下,a的值其实是[1,2,3,4];</div></pre></td></tr></table></figure>
<p>其实主要的原因是这样的,当我们的a作为参数传到foo函数中的时候,foo中的参数x其实是获得了一个到a数组的指针,当x进行相应的数值处理操作的时候,会直接作用到a上面,但是当x的指针改变了,也就是x被重新赋值的时候,x的指针就指向新的[4,5,6]数组了,这个时候其实后面的push(7)的操作已经是对于新的数组,并没有对a数组进行相应的操作,故最后返回的a的值只是[1,2,3,4]</p>
<h1 id="坑六-为变量赋予常量值的问题"><a href="#坑六-为变量赋予常量值的问题" class="headerlink" title="坑六: 为变量赋予常量值的问题"></a>坑六: 为变量赋予常量值的问题</h1><p>一个很小的问题(其实涉及到的知识点和上面是类似的),当我为一个变量赋予了一个常量值,但通过函数对这个常量值进行更改,那么更改会不会体现到这个常量值中呢?<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">function foo(x) &#123;</div><div class="line">	x = x + 1;</div><div class="line">	console.log(x);</div><div class="line">&#125;</div><div class="line">var a = 2;</div><div class="line">foo(a);</div><div class="line">console.log(a);  //此时a还是为2</div></pre></td></tr></table></figure></p>
<h1 id="坑七-关于浅复制的一些小技巧-也是对上面问题的另一种出理方案"><a href="#坑七-关于浅复制的一些小技巧-也是对上面问题的另一种出理方案" class="headerlink" title="坑七: 关于浅复制的一些小技巧(也是对上面问题的另一种出理方案)"></a>坑七: 关于浅复制的一些小技巧(也是对上面问题的另一种出理方案)</h1><p>使用slice()方法对变量进行浅复制,达到不影响变量原来的值的目的.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">foo(slice() )</div></pre></td></tr></table></figure>
<h1 id="坑八-new出的对象"><a href="#坑八-new出的对象" class="headerlink" title="坑八: new出的对象"></a>坑八: new出的对象</h1><p>使用new方法new出来的变量都是属于对象,因此进行类型检测时都会显示为object型.</p>
<h1 id="坑九-关于隐式类型转换"><a href="#坑九-关于隐式类型转换" class="headerlink" title="坑九: 关于隐式类型转换"></a>坑九: 关于隐式类型转换</h1><p>对new出来的对象来讲,对其进行判断会有一个自动的隐式类型转换过程,自动调用数组中的valueof()方法,因此就有了以下这样的奇葩现象:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">var a = 2;</div><div class="line">Number.prototype.valueOf = function() &#123;</div><div class="line">    return a++;</div><div class="line">&#125;</div><div class="line">var b = new Number(2);</div><div class="line">if(b == 2 &amp;&amp; b ==3) &#123;</div><div class="line">    console.log(&apos;WTF?&apos;)   //WTF?</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>其实这个问题很好解释,每次对b进行判断都是会调用其valueof方法,而valueof方法中a会自增1,因此会有b又等于2,又等于3的情况.</p>
]]></content>
    
    <summary type="html">
    
      本系列将会写一些在正常工作中会遇到的一些坑,然后分析它们的产生原因及解决办法.本文的内容主要来自&lt;you don&#39;t know JS&gt;及日常工作的问题的一些总结.
    
    </summary>
    
      <category term="JavaScript躲坑指南" scheme="https://github.com/ChangerHe/categories/JavaScript%E8%BA%B2%E5%9D%91%E6%8C%87%E5%8D%97/"/>
    
    
      <category term="JavaScript躲坑指南" scheme="https://github.com/ChangerHe/tags/JavaScript%E8%BA%B2%E5%9D%91%E6%8C%87%E5%8D%97/"/>
    
  </entry>
  
  <entry>
    <title>JavaScript躲坑指南（二）</title>
    <link href="https://github.com/ChangerHe/2017/06/15/JavaScript%E8%BA%B2%E5%9D%91%E6%8C%87%E5%8D%97%EF%BC%88%E4%BA%8C%EF%BC%89/"/>
    <id>https://github.com/ChangerHe/2017/06/15/JavaScript躲坑指南（二）/</id>
    <published>2017-06-15T15:02:38.000Z</published>
    <updated>2017-09-14T14:37:53.212Z</updated>
    
    <content type="html"><![CDATA[<p>本系列将会写一些在正常工作中会遇到的一些坑,然后分析它们的产生原因及解决办法.本文的内容主要来自&lt;you don’t know JS&gt;及日常工作的问题的一些总结.</p>
<h1 id="关于arguments的使用"><a href="#关于arguments的使用" class="headerlink" title="关于arguments的使用:"></a>关于arguments的使用:</h1><p>arguments在ES6之前简直就是福音,因为在ES6之前是没有办法取到函数的参数组成的数组的.</p>
<p>但是arguments在使用的过程中还是有一些坑的,我们来看一下:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">function foo(a) &#123;</div><div class="line">    a = 42;</div><div class="line">    console.log(arguments[0])</div><div class="line">&#125;</div><div class="line">foo(2);   //42</div><div class="line">foo();    //undefined</div></pre></td></tr></table></figure>
<p>在向函数传递参数的时候,arguments数组中的对应单元会和命名参数建立关联,以得到相同的值,但是当函数在调用的时候没有传递参数时,因为没有参数,自然arguments就无法和函数建立关联了,自然就是undefined.</p>
<h1 id="try-catch-finally的内容执行先后的问题"><a href="#try-catch-finally的内容执行先后的问题" class="headerlink" title="try/catch/finally的内容执行先后的问题"></a>try/catch/finally的内容执行先后的问题</h1><p>finally中的代码总是会在try之后执行,如果有catch的话会在catch之后执行.其实也可以把finally中的代码当做一个回调函数.无论出现什么情况,最后一定会被调用.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">function foo() &#123;</div><div class="line">    try &#123;</div><div class="line">        return 42;</div><div class="line">    &#125; finally &#123;</div><div class="line">        console.log(&apos;hello&apos;)</div><div class="line">    &#125;</div><div class="line">    console.log(&apos;never runs&apos;);</div><div class="line">&#125;</div><div class="line">console.log(foo());</div><div class="line">//输出结果: 先输出 hello  再输出返回的值hello</div></pre></td></tr></table></figure>
<p>在这里return42先执行,并将foo()函数的返回值设置为42.try执行完毕后执行finally.console.log()显示的是函数的返回值.</p>
<p>对于这个问题还有一个很好玩的东西,就是当你在finally中进行抛出异常时,其实try中的返回值就不生效了.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">function foo() &#123;</div><div class="line">    try &#123;</div><div class="line">        return  42;</div><div class="line">    &#125; finally &#123;</div><div class="line">        throw &quot;oops!&quot;</div><div class="line">    &#125;</div><div class="line">    console.log(&apos;never runs&apos;);</div><div class="line">&#125;</div><div class="line">console.log(foo()); // Uncaught oops!</div></pre></td></tr></table></figure>
<p>其实综上而言,不论try中执行的是什么东西,即使是<code>return</code>或者<code>throw</code>等让函数立即结束的语句,最后finally也会成功执行.但是当<code>finally</code>中抛出异常时,<code>try</code>中的代码其实就相当于无效了.也就是finally中的值会最终覆盖掉try中的值.</p>
<h1 id="关于全局的DOM变量"><a href="#关于全局的DOM变量" class="headerlink" title="关于全局的DOM变量"></a>关于全局的DOM变量</h1><p>当我们在文档流中加入 <code>&lt;div id=&quot;foo&quot;&gt;&lt;/div&gt;</code> 时,我们在其下面的js文档中能否找到foo这个变量呢?答案是可以!</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">//我们直接在文档的下面进行类型判定</div><div class="line">console.log(typeof foo);   //输出结果是object,   WTF?</div></pre></td></tr></table></figure>
<h1 id="关于属性的屏蔽"><a href="#关于属性的屏蔽" class="headerlink" title="关于属性的屏蔽"></a>关于属性的屏蔽</h1><p>当我们在原型链中为底层函数操作原型链中的属性进行算术运算时,属性被被底层函数给屏蔽掉.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">var anotherObject = &#123;</div><div class="line">    a: 2</div><div class="line">&#125;</div><div class="line">var myObject = Object.create(anotherObject);</div><div class="line">console.log(myObject.a);</div><div class="line">myObject.a++;</div><div class="line">console.log(myObject.a,anotherObject.a);</div></pre></td></tr></table></figure>
<p>其实想到原理就很简单,因为当我们把<code>myObject</code>中的a,也就是<code>anotherObject</code>中的a调用之后,相应的<code>myObject.a</code>会得到<code>anotherObject</code>中的a的值,也就是2.但是当我们对<code>myObject</code>执行其属性的自加操作之后,它的底层其实是这样的:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">myObject.__proto__.a = 2;</div><div class="line">myObject= &#123;a:myObject.__proto__.a&#125;;</div><div class="line">myObject.a = myObject.a + 1;</div></pre></td></tr></table></figure>
<h1 id="关于concat-方法连接数组和push-方法连接数组的区别"><a href="#关于concat-方法连接数组和push-方法连接数组的区别" class="headerlink" title="关于concat()方法连接数组和push()方法连接数组的区别"></a>关于concat()方法连接数组和push()方法连接数组的区别</h1><p>首先我们看一个例子:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">var nums = [2, 3, 4, 5];</div><div class="line">console.log(nums.concat([1, 2]))</div><div class="line">//[2, 3, 4, 5, 1, 2]</div><div class="line">console.log(nums)</div><div class="line">//[2, 3, 4, 5]</div><div class="line">nums.push([1, 2])</div><div class="line">console.log(nums)</div><div class="line">[2, 3, 4, 5, [1, 2]]</div></pre></td></tr></table></figure>
<p>其实看了这个例子大家应该都懂了,首先,<code>concat</code>的作用是链接两个数组,会将两个数组拼合成一个数组,并且不会改变之前的数组的值,而是返回一个新数组.</p>
<p>而<code>push()</code>则直接改变了数组的值,而且是直接将<code>push()</code>中传的参数直接接到了数组的后面,也就是当我们在<code>push()</code>中传参数组时,最后会得到一个嵌套的数组.</p>
]]></content>
    
    <summary type="html">
    
      本系列将会写一些在正常工作中会遇到的一些坑,然后分析它们的产生原因及解决办法.本文的内容主要来自&lt;you don&#39;t know JS&gt;及日常工作的问题的一些总结.
    
    </summary>
    
      <category term="JavaScript躲坑指南" scheme="https://github.com/ChangerHe/categories/JavaScript%E8%BA%B2%E5%9D%91%E6%8C%87%E5%8D%97/"/>
    
    
      <category term="JavaScript躲坑指南" scheme="https://github.com/ChangerHe/tags/JavaScript%E8%BA%B2%E5%9D%91%E6%8C%87%E5%8D%97/"/>
    
  </entry>
  
  <entry>
    <title>JavaScript模块化编程-commonjs和AMD及CMD</title>
    <link href="https://github.com/ChangerHe/2017/06/15/JavaScript%E6%A8%A1%E5%9D%97%E5%8C%96%E7%BC%96%E7%A8%8B-commonjs%E5%92%8CAMD%E5%8F%8ACMD/"/>
    <id>https://github.com/ChangerHe/2017/06/15/JavaScript模块化编程-commonjs和AMD及CMD/</id>
    <published>2017-06-15T15:00:36.000Z</published>
    <updated>2017-09-14T14:35:26.947Z</updated>
    
    <content type="html"><![CDATA[<h1 id="commonjs"><a href="#commonjs" class="headerlink" title="commonjs"></a>commonjs</h1><p>2009年，美国程序员Ryan Dahl创造了node.js项目，将javascript语言用于服务器端编程。</p>
<p>这标志”Javascript模块化编程”正式诞生。因为老实说，在浏览器环境下，没有模块也不是特别大的问题，毕竟网页程序的复杂性有限；但是在服务器端，一定要有模块，与操作系统和其他应用程序互动，否则根本没法编程。</p>
<p>node.js的模块系统，就是参照CommonJS规范实现的。在CommonJS中，有一个全局性方法require()，用于加载模块。假定有一个数学模块math.js，就可以像下面这样加载。</p>
<p><code>var math = require(&#39;math&#39;);</code></p>
<p>然后就可以调用math.js中提供的各种接口API,在自己的程序中直接使用.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">var math = require(&apos;math&apos;);</div><div class="line">math.add(2, 3);   //5</div></pre></td></tr></table></figure>
<h1 id="AMD和CMD"><a href="#AMD和CMD" class="headerlink" title="AMD和CMD"></a>AMD和CMD</h1><p>有了服务器端模块以后，很自然地，大家就想要客户端模块。而且最好两者能够兼容，一个模块不用修改，在服务器和浏览器都可以运行。</p>
<p>但是，由于一个重大的局限，使得CommonJS规范不适用于浏览器环境。还是上一节的代码，如果在浏览器中运行，会有一个很大异步加载的问题.</p>
<p>还是刚刚的代码,当我的程序在使用commonjs规范的时候,因为整个require的请求是异步的,所以当我们使用require进行请求math.js时,必须要等math.js完全加载完毕后,才能够进行下一步的操作.</p>
<p>这对服务器端不是一个问题，因为所有的模块都存放在本地硬盘，可以同步加载完成，等待时间就是硬盘的读取时间。但是，对于浏览器，这却是一个大问题，因为模块都放在服务器端，等待时间取决于网速的快慢，可能要等很长时间，浏览器处于”假死”状态。</p>
<p>因此，浏览器端的模块，不能采用”同步加载”（synchronous），只能采用”异步加载”（asynchronous）。这就是AMD规范诞生的背景。</p>
<h2 id="AMD"><a href="#AMD" class="headerlink" title="AMD"></a>AMD</h2><p>AMD是”Asynchronous Module Definition”的缩写，意思就是”异步模块定义”。它采用异步方式加载模块，模块的加载不影响它后面语句的运行。所有依赖这个模块的语句，都定义在一个回调函数中，等到加载完成之后，这个回调函数才会运行。</p>
<p>AMD也采用require()语句加载模块，但是不同于CommonJS，它要求两个参数：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">require([module], callback);</div></pre></td></tr></table></figure>
<p>第一个参数[module]，是一个数组，里面的成员就是要加载的模块；第二个参数callback，则是加载成功之后的回调函数。如果将前面的代码改写成AMD形式，就是下面这样：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">require([&apos;math&apos;], function (math) &#123;</div><div class="line">　　math.add(2, 3);</div><div class="line">&#125;);</div></pre></td></tr></table></figure>
<p>math.add()与math模块加载不是同步的，浏览器不会发生假死。所以很显然，AMD比较适合浏览器环境。</p>
<p>目前，主要有两个Javascript库实现了AMD规范：require.js和curl.js。</p>
<h2 id="require-js"><a href="#require-js" class="headerlink" title="require.js"></a>require.js</h2><p>最早的时候，所有Javascript代码都写在一个文件里面，只要加载这一个文件就够了。后来，代码越来越多，一个文件不够了，必须分成多个文件，依次加载。</p>
<p>这样的写法有很大的缺点。首先，加载的时候，浏览器会停止网页渲染，加载文件越多，网页失去响应的时间就会越长；其次，由于js文件之间存在依赖关系，因此必须严格保证加载顺序（比如上例的1.js要在2.js的前面），依赖性最大的模块一定要放到最后加载，当依赖关系很复杂的时候，代码的编写和维护都会变得困难。</p>
<p>!()[<a href="http://image.beekka.com/blog/201211/bg2012110701.png" target="_blank" rel="external">http://image.beekka.com/blog/201211/bg2012110701.png</a>]</p>
<p>使用require.js的第一步，是先去官方网站下载最新版本。下载后，假定把它放在js子目录下面，就可以加载了。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">&lt;script src=&quot;js/require.js&quot;&gt;&lt;/script&gt;</div></pre></td></tr></table></figure>
<p>有人可能会想到，加载这个文件，也可能造成网页失去响应。解决办法有两个，一个是把它放在网页底部加载，另一个是写成下面这样：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">&lt;script src=&quot;js/require.js&quot; defer async=&quot;true&quot; &gt;&lt;/script&gt;</div></pre></td></tr></table></figure>
<p>async属性表明这个文件需要异步加载，避免网页失去响应。IE不支持这个属性，只支持defer，所以把defer也写上。</p>
<p>加载require.js以后，下一步就要加载我们自己的代码了。假定我们自己的代码文件是main.js，也放在js目录下面。那么，只需要写成下面这样就行了：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">&lt;script src=&quot;js/require.js&quot; data-main=&quot;js/main&quot;&gt;&lt;/script&gt;</div></pre></td></tr></table></figure>
<p>data-main属性的作用是，指定网页程序的主模块。在上例中，就是js目录下面的main.js，这个文件会第一个被require.js加载。由于require.js默认的文件后缀名是js，所以可以把main.js简写成main。</p>
<h3 id="require-js主模块的写法"><a href="#require-js主模块的写法" class="headerlink" title="require.js主模块的写法"></a>require.js主模块的写法</h3><p>上一节的main.js，我把它称为”主模块”，意思是整个网页的入口代码。它有点像C语言的main()函数，所有代码都从这儿开始运行。主模块依赖于其他模块，这时就要使用AMD规范定义的的require()函数。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">// main.js</div><div class="line">require([&apos;moduleA&apos;, &apos;moduleB&apos;, &apos;moduleC&apos;], function (moduleA, moduleB, moduleC)&#123;</div><div class="line">　　　　// some code here</div><div class="line">&#125;);</div></pre></td></tr></table></figure>
<p>require()函数接受两个参数。第一个参数是一个数组，表示所依赖的模块，上例就是[‘moduleA’, ‘moduleB’, ‘moduleC’]，即主模块依赖这三个模块；第二个参数是一个回调函数，当前面指定的模块都加载成功后，它将被调用。加载的模块会以参数形式传入该函数，从而在回调函数内部就可以使用这些模块。</p>
<p>require()异步加载moduleA，moduleB和moduleC，浏览器不会失去响应；它指定的回调函数，只有前面的模块都加载成功后，才会运行，解决了依赖性的问题。</p>
]]></content>
    
    <summary type="html">
    
      2009年，美国程序员Ryan Dahl创造了node.js项目，将javascript语言用于服务器端编程。 这标志Javascript模块化编程正式诞生。因为老实说，在浏览器环境下，没有模块也不是特别大的问题，毕竟网页程序的复杂性有限；但是在服务器端，一定要有模块，与操作系统和其他应用程序互动，否则根本没法编程。
    
    </summary>
    
      <category term="JavaScript模块化编程" scheme="https://github.com/ChangerHe/categories/JavaScript%E6%A8%A1%E5%9D%97%E5%8C%96%E7%BC%96%E7%A8%8B/"/>
    
    
      <category term="JavaScript模块化编程" scheme="https://github.com/ChangerHe/tags/JavaScript%E6%A8%A1%E5%9D%97%E5%8C%96%E7%BC%96%E7%A8%8B/"/>
    
  </entry>
  
</feed>
