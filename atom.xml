<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>ChangerHe&#39;s Bolg|何庆畅的个人博客</title>
  <subtitle>What doesn&#39;t kill you make you stronger.</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://github.com/ChangerHe/"/>
  <updated>2017-10-20T09:19:30.190Z</updated>
  <id>https://github.com/ChangerHe/</id>
  
  <author>
    <name>ChangerHe</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>纯CSS实现元素水平垂直居中的方法</title>
    <link href="https://github.com/ChangerHe/2017/10/30/%E7%BA%AFCSS%E5%AE%9E%E7%8E%B0%E5%85%83%E7%B4%A0%E6%B0%B4%E5%B9%B3%E5%9E%82%E7%9B%B4%E5%B1%85%E4%B8%AD%E7%9A%84%E6%96%B9%E6%B3%95/"/>
    <id>https://github.com/ChangerHe/2017/10/30/纯CSS实现元素水平垂直居中的方法/</id>
    <published>2017-10-30T11:42:25.000Z</published>
    <updated>2017-10-20T09:19:30.190Z</updated>
    
    <content type="html"><![CDATA[<p>垂直居中是布局中十分常见的效果之一，为实现良好的兼容性，PC端实现垂直居中的方法一般是通过绝对定位，table-cell，负边距等方法。有了css3，针对移动端的垂直居中就更加多样化。</p>
<p>笔者在这里总结了九种使用纯CSS实现水平垂直居中的方法</p>
<p>OK. Let’s see it!</p>
<p>最开始, 我们先设置几个盒子, 设置它们的统一样式为以下</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">.box &#123;</div><div class="line">	width: 300px;</div><div class="line">	height: 300px;</div><div class="line">	margin: 10px;</div><div class="line">	box-shadow: 2px 3px 4px #000;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h1 id="方法1-table-cell"><a href="#方法1-table-cell" class="headerlink" title="方法1: table-cell"></a>方法1: table-cell</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">&lt;!-- HTML --&gt;</div><div class="line">&lt;div class=&quot;box box1&quot;&gt;</div><div class="line">        &lt;span&gt;垂直居中&lt;/span&gt;</div><div class="line">&lt;/div&gt;</div></pre></td></tr></table></figure>
<p>整体的结构是相当简单的, css直接设置本身的宽高, 然后设置为table-cell,并将对齐方式设置为vertic-align就可以实现水平垂直居中了</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">/* CSS */</div><div class="line"></div><div class="line">.box1&#123;</div><div class="line">    display: table-cell;</div><div class="line">    vertical-align: middle;</div><div class="line">    text-align: center;        </div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>实际上table-cell的兼容性也是相当不错的, 可兼容至IE8+, 相当于将这个区块设置成了一个td</p>
<h1 id="方法2-display-flex"><a href="#方法2-display-flex" class="headerlink" title="方法2: display: flex;"></a>方法2: display: flex;</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">.box2&#123;</div><div class="line">    display: flex;</div><div class="line">    justify-content:center;</div><div class="line">    align-items:Center;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>使用flex布局就非常简单了, 只需要设置两个属性即可, 存在的问题就是兼容性很有限, 虽然非常简单, 一般使用在移动端</p>
<h1 id="方法3-绝对定位和负边距"><a href="#方法3-绝对定位和负边距" class="headerlink" title="方法3 绝对定位和负边距"></a>方法3 绝对定位和负边距</h1><p>这个在以前算是比较中规中矩的办法了, 首先需要将父盒子设置为相对定位, 子盒子设置为绝对定位</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">.box3 &#123;</div><div class="line">	position:relative;</div><div class="line">&#125;</div><div class="line">.box3 span &#123;</div><div class="line">	position: absolute;</div><div class="line">	width:100px;</div><div class="line">	height: 50px;</div><div class="line">	top:50%;</div><div class="line">	left:50%;</div><div class="line">	margin-left:-50px;</div><div class="line">	margin-top:-25px;</div><div class="line">	text-align: center;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>原理也非常简单, 将定位到中间距左部和顶部50%之后,需要减去自身的长宽的一半,就实现居中了</p>
<h1 id="方法4-绝对定位和0"><a href="#方法4-绝对定位和0" class="headerlink" title="方法4: 绝对定位和0"></a>方法4: 绝对定位和0</h1><p>这种方法常用于做蒙层和遮罩效果</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">.box4 span&#123;</div><div class="line">	width: 50%; </div><div class="line">	height: 50%; </div><div class="line">	background: #000;</div><div class="line">	overflow: auto; </div><div class="line">	margin: auto; </div><div class="line">	position: absolute; </div><div class="line">	top: 0; </div><div class="line">	left: 0; </div><div class="line">	bottom: 0; </div><div class="line">	right: 0; </div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>利用绝对定位上下左右都设为0, 中间的子盒子设置margin为auto实现</p>
<p>方法5: translate</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">.box6 &#123;</div><div class="line">	position: relative;</div><div class="line">&#125;</div><div class="line">.box6 span &#123;</div><div class="line">	position: absolute;</div><div class="line">	top:50%;</div><div class="line">	left:50%;</div><div class="line">	width:100%;</div><div class="line">	transform:translate(-50%,-50%);</div><div class="line">	text-align: center;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>利用CSS3的转换效果, 将自身的位置向左上分别移动了50%, 也就是自身的一半, 就实现居中了 </p>
<h1 id="方法6：display-inline-block"><a href="#方法6：display-inline-block" class="headerlink" title="方法6：display:inline-block"></a>方法6：display:inline-block</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">.box7 &#123;</div><div class="line">  text-align:center;</div><div class="line">  font-size:0;</div><div class="line">&#125;</div><div class="line">.box7 span &#123;</div><div class="line">	vertical-align:middle;</div><div class="line">	display:inline-block;</div><div class="line">	font-size:16px;</div><div class="line">&#125;</div><div class="line">.box7:after &#123;</div><div class="line">	content:&apos;&apos;;</div><div class="line">	width:0;</div><div class="line">	height:100%;</div><div class="line">	display:inline-block;</div><div class="line">	vertical-align:middle;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这个方法就比较复杂一些了, 通过一个没有任何内容但高度为100%的伪类来进行占位, 根据vertical-align的特性, 来进行居中</p>
<h1 id="方法7：display-flex和margin-auto"><a href="#方法7：display-flex和margin-auto" class="headerlink" title="方法7：display:flex和margin:auto"></a>方法7：display:flex和margin:auto</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">.box8 &#123;</div><div class="line">    display: flex;</div><div class="line">    text-align: center;</div><div class="line">&#125;</div><div class="line">.box8 span &#123;</div><div class="line">	margin: auto;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h1 id="方法8：display-webkit-box"><a href="#方法8：display-webkit-box" class="headerlink" title="方法8：display:-webkit-box"></a>方法8：display:-webkit-box</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">.box9 &#123;</div><div class="line">    display: -webkit-box;</div><div class="line">    -webkit-box-pack:center;</div><div class="line">    -webkit-box-align:center;</div><div class="line">    -webkit-box-orient: vertical;</div><div class="line">    text-align: center</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h1 id="方法9：display-webkit-box"><a href="#方法9：display-webkit-box" class="headerlink" title="方法9：display:-webkit-box"></a>方法9：display:-webkit-box</h1><p>这种方法，在 content 元素外插入一个 div。设置此 div height:50%; margin-bottom:-contentheight;。</p>
<p>content 清除浮动，并显示在中间。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">&lt;div class=&quot;floater&quot;&gt;&lt;/div&gt;  </div><div class="line">&lt;div class=&quot;content&quot;&gt; Content here &lt;/div&gt;</div></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">.floater &#123;</div><div class="line">    float:left; </div><div class="line">    height:50%; </div><div class="line">    margin-bottom:-120px;</div><div class="line">&#125;</div><div class="line">.content &#123;</div><div class="line">    clear:both; </div><div class="line">    height:240px; </div><div class="line">    position:relative;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>(后两种居中方法摘自网络)</p>
]]></content>
    
    <summary type="html">
    
      垂直居中是布局中十分常见的效果之一，为实现良好的兼容性，PC端实现垂直居中的方法一般是通过绝对定位，table-cell，负边距等方法。有了css3，针对移动端的垂直居中就更加多样化。
    
    </summary>
    
      <category term="CSS" scheme="https://github.com/ChangerHe/categories/CSS/"/>
    
    
      <category term="CSS" scheme="https://github.com/ChangerHe/tags/CSS/"/>
    
  </entry>
  
  <entry>
    <title>微信小程序懒加载的实现</title>
    <link href="https://github.com/ChangerHe/2017/10/21/%E5%BE%AE%E4%BF%A1%E5%B0%8F%E7%A8%8B%E5%BA%8F%E6%87%92%E5%8A%A0%E8%BD%BD%E7%9A%84%E5%AE%9E%E7%8E%B0/"/>
    <id>https://github.com/ChangerHe/2017/10/21/微信小程序懒加载的实现/</id>
    <published>2017-10-21T14:12:23.000Z</published>
    <updated>2017-11-08T12:22:54.759Z</updated>
    
    <content type="html"><![CDATA[<p>近期做了一个微信小程序的项目, 其中涉及到微信小程序的懒加载功能, 第一次做这个功能的感觉真的是让人欲(tou)罢(teng)不(bu)能(yi)啊, 所以在这里做一个小小的总结来分享一下.</p>
<p>不同于原始的dom操作项目, 现在的现代框架已经将dom操作高度集成到了api中, 采用数据驱动的方式, 来实现对dom的各种处理.</p>
<p>现在我们回忆一下当初那个青涩的原始时代, 当有懒加载的需求的时候, 我们可以开心地创建一个ajax请求, 将请求参数发送到后台, 后台反馈给我们参数后, 然后我们再开心地操作dom将数据处理后插到页面上.</p>
<p>“哎呀, 屁股好疼”           —页面上的某个dom节点如是说</p>
<p>但是在数据驱动, 高度组件化处理ajax的返回参数的时候, 我们该怎么处理这个需求呢?</p>
<h1 id="微信小程序的scroll-view组件"><a href="#微信小程序的scroll-view组件" class="headerlink" title="微信小程序的scroll-view组件"></a>微信小程序的scroll-view组件</h1><p>说到懒加载, 那么就必须得提到微信的scroll-view组件, 这玩意儿干啥的呢?</p>
<p>主要的作用还是作为一个载体, 用于设置载体内的内容滚动, 当然, 如果需要在y轴滚动的话, 页面都是有这个功能的, 但是如果直接使用y轴滚动的功能的话, 就无法成功触发相应的事件了.</p>
<h1 id="wxml的写入方式"><a href="#wxml的写入方式" class="headerlink" title="wxml的写入方式"></a>wxml的写入方式</h1><p>我们将wxml中需要滚动的view外需要再套一层scroll-view方便让器其滚动触发事件</p>
<p>有一点需要特别特别注意的是, 微信原生提供了bindscrolltolower和bindscrolltoupper这两个api来专门处理对应的滚动触底(最右边或最下边)及滚动触顶(最左边或最上边)事件.</p>
<p>但是!!!</p>
<p>这两个事件的触发, 前提是必须要在对应的scroll-view上设置高度才可以的, 不然事件无法触发生效.</p>
<p>比如说, 针对不同的设备, 我设置了对应的触发高度</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">@media (min-width: 375px) &#123;</div><div class="line">  .all-movie&#123;</div><div class="line">    height: 1300rpx;</div><div class="line">  &#125;</div><div class="line">&#125;</div><div class="line">@media (max-width: 374px) &#123;</div><div class="line">  .all-movie&#123;</div><div class="line">    height: 1000rpx;</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h1 id="ajax的请求分析"><a href="#ajax的请求分析" class="headerlink" title="ajax的请求分析"></a>ajax的请求分析</h1><p>在这里要特别说明一下, 因为微信不存在dom操作, 所以我们进行懒加载操作的时候, 其实是将整个页面的所有元素都重新加载了一遍的, 因为插不进去啊(#→⌒→).</p>
<p>那么这个时候ajax的请求就很成问题了, 我们每次加载, 需要传递不同的参数进去</p>
<p>那么我的思路就是, 通过在data上挂载变量, 每次请求将变量增加, 然后通过这个变量的值的增加, 每次发起的ajax请求就不一样了, 获取到的值会逐次增加</p>
<p>微信小程序的ajax创建方式这里就不再赘述了, 官网说的很清楚, 使用wx.request对象很容易搞定</p>
<p>下面是我写在ajax请求success里面的代码</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">// 获取请求到的数据</div><div class="line">var data = res.data</div><div class="line">// 将本身setdata的对象直接拿出来, 然后再放进去</div><div class="line">var dataCon = &#123;&#125;</div><div class="line">// 每产生一次ajax请求, 就要使总和加10, 也就是再请求十条数据</div><div class="line">that.data.totalCount += 10</div><div class="line">dataCon.dataObj = data</div><div class="line">that.setData(dataCon)</div></pre></td></tr></table></figure>
<p>注意上面我是设置了一个data的数据名为totalCount, 初始值我设置其为0, 那么每次产生一次ajax 请求, 则其自加10, 通过totalCount, 在拼接上对应的请求url, 就可以成功取到相应的ajax返回值了.</p>
<p>到这里可能会有同学要问了, 你这里每次都要重新渲染一下页面, 难道不会增大微信小程序的压力吗? 每次请求的数据都会增加, 页面压力会很大啊</p>
<p>当然, 既然使用数据驱动的方式来进行开发, 对于这样的场景, 产生较大的数据压力是必然的, 但是微信小程序和浏览器一样, 本身是存在缓存的, 之前请求过的数据, 后面服务器会直接返回403, 就不会产生较大的数据流, 最后产生流量的也就是后面那一小部分的文件数据而已.</p>
<h1 id="对ajax请求的优化"><a href="#对ajax请求的优化" class="headerlink" title="对ajax请求的优化"></a>对ajax请求的优化</h1><p>以上方法可行肯定是可行的, 但是我们每次做ajax请求, 每次的请求数据都会增多, 那么会不会有一种更加的请求方案呢?</p>
<p>当然, 我们可以考虑和之前操作dom那样, 每次只请求自己需要的那一部分数据, 之前重复的数据是没有必要再到服务器请求一次的</p>
<p>我们的url可以这样构建</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">var nextUrl = this.data.requestUrl + &quot;?start=&quot; + this.data.totalCount + &quot;&amp;count=10&quot;</div></pre></td></tr></table></figure>
<p>totalCount表示已经请求的数量, 而count表示每次请求的数量</p>
<p>很好, 一下减少了不少的ajax请求压力</p>
<h1 id="优化后的bug处理"><a href="#优化后的bug处理" class="headerlink" title="优化后的bug处理"></a>优化后的bug处理</h1><p>ajax请求的压力确实减少了, 但是现在还有一个问题啊, 你每次都反馈给我十条数据, 我用你给的数据渲染, 岂不是把页面懒加载变成了页面刷新了, 每次请求的数据是不一样了, 但是之前的数据已经不存在了呀</p>
<p>所以, 我们需要使用一个data上面的变量来存储我们之前请求到的值</p>
<p>我们将之前的成功回调改写一下</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line">// 获取请求到的数据</div><div class="line">var data = res.data</div><div class="line">// 将本身setdata的对象直接拿出来, 然后再放进去</div><div class="line">var dataCon = &#123;&#125;</div><div class="line">// 每产生一次ajax请求, 就要使总和加10, 也就是再请求十条数据</div><div class="line">that.data.totalCount += 10</div><div class="line">var total = &#123;&#125;</div><div class="line">// 如果不是第一次请求数据的话,则将两次的数据相加</div><div class="line">if (!that.data.isEmpty) &#123;</div><div class="line">  total = that.data.dataObj.concat(data)</div><div class="line">&#125; else &#123;</div><div class="line">  total = data</div><div class="line">  // 如果isEmpty为true则将其改为false</div><div class="line">  that.data.isEmpty = false </div><div class="line">&#125;</div><div class="line">dataCon.dataObj = total</div><div class="line">that.setData(dataCon)</div></pre></td></tr></table></figure>
<p>这里我们设置了一个全局变量isEmpty, 默认为true, 表示默认为空, 当第一次请求的时候, 将数值存入total中,并将isEmpty改写为false, 之后的每一次请求都是在total中加数据, 我们渲染的话就都是用全局的dataObj这个变量来进行渲染, 即可解决之前的问题.</p>
<p>更新:<br>    后面有看到因为scroll-view在页面中是无法触发下拉刷新事件的,但后面微信方给出了解决办法: 不用scroll-view , 玛德坑爹</p>
<pre><code>现在可以直接使用onReachBottom事件,也就是触底事件来处理和进行懒加载, 相比于之前的方法简单了不少, 页面也更加流畅了

期待小程序能带了更多更好的东西吧
</code></pre>]]></content>
    
    <summary type="html">
    
      近期做了一个微信小程序的项目, 其中涉及到微信小程序的懒加载功能, 第一次做这个功能的感觉真的是让人欲(tou)罢(teng)不(bu)能(yi)啊, 所以在这里做一个小小的总结来分享一下.
    
    </summary>
    
      <category term="微信小程序" scheme="https://github.com/ChangerHe/categories/%E5%BE%AE%E4%BF%A1%E5%B0%8F%E7%A8%8B%E5%BA%8F/"/>
    
    
      <category term="微信小程序" scheme="https://github.com/ChangerHe/tags/%E5%BE%AE%E4%BF%A1%E5%B0%8F%E7%A8%8B%E5%BA%8F/"/>
    
      <category term="WXapplet" scheme="https://github.com/ChangerHe/tags/WXapplet/"/>
    
  </entry>
  
  <entry>
    <title>处理git无法上传超过100M文件的问题</title>
    <link href="https://github.com/ChangerHe/2017/10/13/%E5%A4%84%E7%90%86git%E6%97%A0%E6%B3%95%E4%B8%8A%E4%BC%A0%E8%B6%85%E8%BF%87100M%E6%96%87%E4%BB%B6%E7%9A%84%E9%97%AE%E9%A2%98/"/>
    <id>https://github.com/ChangerHe/2017/10/13/处理git无法上传超过100M文件的问题/</id>
    <published>2017-10-13T03:26:43.000Z</published>
    <updated>2017-10-13T11:53:08.165Z</updated>
    
    <content type="html"><![CDATA[<p>最近在项目提交分支到github的时候, 出现了一件很尴尬的事情, 文件超过100m, 被github拒绝了</p>
<p>宝宝心里苦, 但宝宝不说</p>
<p>当时也没太在意, 但是当我的当前分支提交堆积到12次的时候, 我急了</p>
<p>卧槽, 要是我以后都不能提交, 那得多尴尬啊</p>
<p>谁叫我有轻微强迫症呢</p>
<p>自己搞不定, 那百度啊</p>
<p>然后, 我百度了一圈, 更换各种搜索词, 从百度的搜索结果的第一页看到第四页, 玛德终于解决了</p>
<p>所以我响应祖国的号召, 坚持每年3.15打击假冒伪劣的思想, 向大家告知一下, 下面的方法  都!!!!  是!!!!! 不!!!!! 对!!!!! 的!!!!!</p>
<p>在这里可能有人要说了, 卧槽你整些不对的跟我说干嘛</p>
<p>没事, 我开心, 结尾也有正确的答案, 不想看过程直接看结果的跳到最后就好</p>
<h1 id="坑爹的jar包"><a href="#坑爹的jar包" class="headerlink" title="坑爹的jar包"></a>坑爹的jar包</h1><p>首先引用一下前辈的话</p>
<blockquote>
<p>如果做了这几步你push的时候还是报和开始的时候一样的错，那说明这个文件你不是最近一次commit时添加的，而是在之前commit过很多次了，这就需要把关于这个文件的所有历史commit记录全部清除掉，这时候我们就需要用到一个叫BFG的工具。我们要到<a href="https://rtyley.github.io/bfg-repo-cleaner/#download这个网站去下载并学习如何使用这个工具。" target="_blank" rel="external">https://rtyley.github.io/bfg-repo-cleaner/#download这个网站去下载并学习如何使用这个工具。</a> —— <a href="https://www.2cto.com/kf/201612/576868.html" target="_blank"> [ 来自某位不知名的大佬 ]</a></p>
</blockquote>
<p>我去尝试下下来这个文档, 卧槽原来是一个jar包, 瞬间觉得高大上了</p>
<p>前辈, 您是想要我学习一下java的运行原理么?</p>
<p>嗯~ jar包, 可以的, 跟着前辈指示的指令一波操作</p>
<p>结果: 指令没卵用</p>
<h1 id="使用git-lfs"><a href="#使用git-lfs" class="headerlink" title="使用git-lfs"></a>使用git-lfs</h1><p>其实这个方法也是可行的, 因为git是专门提供了一个工具来给我们存储大容量文件的, 就是<code>Git Large File Storage</code> 大家有兴趣可以百度或者google一下</p>
<p>但问题是, 搞这个玩意儿又要下另一个版本的git, 神烦, 故跳转到下一百度词条了, 毕竟以后很少用到, 学习成本太高</p>
<p>这里也一样, 贴上前辈的文章链接, 有兴趣的可以学习一下</p>
<blockquote>
<p>—— <a href="http://www.liuxiao.org/2017/02/git-%E5%A4%84%E7%90%86-github-%E4%B8%8D%E5%85%81%E8%AE%B8%E4%B8%8A%E4%BC%A0%E8%B6%85%E8%BF%87-100mb-%E6%96%87%E4%BB%B6%E7%9A%84%E9%97%AE%E9%A2%98/" target="_blank"> [ [Git] 处理 github 不允许上传超过 100MB 文件的问题 ]</a></p>
</blockquote>
<h1 id="修正错误"><a href="#修正错误" class="headerlink" title="修正错误?"></a>修正错误?</h1><p>还有某前辈建议这样做</p>
<blockquote>
<p>第一步输入命令 cd /Users/Dora/Desktop/XXX（cd后面的这个路径要换成你自己项目的路径），然后第二步输入命令 git rm –cached /Users/Dora/Desktop/XXX/XXX/IJKMediaFramework（加下划线部分是你自己的要移除的文件的路径），第三步输入命令 git commit –amend -CHEAD，执行完这步后，这个大文件将会从你的commit记录里移除，并且以后commit都将不会再把它commit了，这时候就可以git push把本地代码push到github上了。</p>
<p>—— <a href="http://www.cnblogs.com/akiha/p/5705505.html" target="_blank"> [ Github 修正上传时“this exceeds GitHub’s file size limit of 100 MB”错误 ]</a></p>
</blockquote>
<p>似乎~ 还是不行</p>
<h1 id="正确的做法"><a href="#正确的做法" class="headerlink" title="正确的做法"></a>正确的做法</h1><p>其实就代码来说, 很简单</p>
<p>注意一点就是, 记得在你当前本地仓库的根目录下打开git bash 否则是无效的, 别问我怎么知道的, 蓝瘦香菇</p>
<p>代码就只有三行, 复制粘贴就好了</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">git filter-branch --force --index-filter &quot;git rm --cached --ignore-unmatch ***&quot;  --prune-empty --tag-name-filter cat -- --all</div><div class="line"></div><div class="line">git commit --amend -CHEAD</div><div class="line"></div><div class="line">git push origin master</div></pre></td></tr></table></figure>
<p>代码第一行中的三个*, 将它换为你之前不要提交的文件的相对路径, 然后会看到一堆的代码校验, 最后会在分支中删除掉你提交这个大文件的记录</p>
<p>那么最后使用git push就可以提交了, 全部搞定, 大吉大利, 今晚吃鸡</p>
<p>(完)</p>
]]></content>
    
    <summary type="html">
    
      最近在项目提交分支到github的时候, 出现了一件很尴尬的事情, 文件超过100m, 被github拒绝了
    
    </summary>
    
      <category term="github" scheme="https://github.com/ChangerHe/categories/github/"/>
    
    
      <category term="Git" scheme="https://github.com/ChangerHe/tags/Git/"/>
    
      <category term="github" scheme="https://github.com/ChangerHe/tags/github/"/>
    
  </entry>
  
  <entry>
    <title>Angularjs的数据绑定和脏检查</title>
    <link href="https://github.com/ChangerHe/2017/10/10/Angularjs%E7%9A%84%E6%95%B0%E6%8D%AE%E7%BB%91%E5%AE%9A%E5%92%8C%E8%84%8F%E6%A3%80%E6%9F%A5/"/>
    <id>https://github.com/ChangerHe/2017/10/10/Angularjs的数据绑定和脏检查/</id>
    <published>2017-10-10T04:53:41.000Z</published>
    <updated>2017-10-13T12:01:38.767Z</updated>
    
    <content type="html"><![CDATA[<p>接触Angular也有一段时间了，时常问自己一些问题, 如果是我实现它，会在哪些方面选择跟它相同的道路, 哪些方面不同。为此，记录了一些思考，给自己回顾，也供他人参考。</p>
<p>本篇博客将分下面几个方面进行讲解</p>
<p>-数据双向绑定<br>-视图模型的继承关系<br>-模块和依赖注入的设计</p>
<h1 id="数据的双向绑定"><a href="#数据的双向绑定" class="headerlink" title="数据的双向绑定"></a>数据的双向绑定</h1><p>Angular实现了双向绑定机制。所谓的双向绑定，无非是从界面的操作能实时反映到数据，数据的变更能实时展现到界面。</p>
<p>一个最简单的示例就是这样：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">&lt;div ng-controller=&quot;CounterCtrl&quot;&gt;</div><div class="line">    &lt;span ng-bind=&quot;counter&quot;&gt;&lt;/span&gt;</div><div class="line">    &lt;button ng-click=&quot;counter=counter+1&quot;&gt;increase&lt;/button&gt;</div><div class="line">&lt;/div&gt;</div></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">function CounterCtrl($scope) &#123;</div><div class="line">    $scope.counter = 1;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这个例子很简单，毫无特别之处，每当点击一次按钮，界面上的数字就增加一。</p>
<h1 id="绑定数据是怎样生效的"><a href="#绑定数据是怎样生效的" class="headerlink" title="绑定数据是怎样生效的"></a>绑定数据是怎样生效的</h1><p>初学AngularJS的人可能会踩到这样的坑，假设有一个指令：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">var app = angular.module(&quot;test&quot;, []);</div><div class="line"></div><div class="line">app.directive(&quot;myclick&quot;, function() &#123;</div><div class="line">    return function (scope, element, attr) &#123;</div><div class="line">        element.on(&quot;click&quot;, function() &#123;</div><div class="line">            scope.counter++;</div><div class="line">        &#125;);</div><div class="line">    &#125;;</div><div class="line">&#125;);</div><div class="line"></div><div class="line">app.controller(&quot;CounterCtrl&quot;, function($scope) &#123;</div><div class="line">    $scope.counter = 0;</div><div class="line">&#125;);</div></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">&lt;body ng-app=&quot;test&quot;&gt;</div><div class="line">    &lt;div ng-controller=&quot;CounterCtrl&quot;&gt;</div><div class="line">        &lt;button myclick&gt;increase&lt;/button&gt;</div><div class="line">        &lt;span ng-bind=&quot;counter&quot;&gt;&lt;/span&gt;</div><div class="line">    &lt;/div&gt;</div><div class="line">&lt;/body&gt;</div></pre></td></tr></table></figure>
<p>这个时候，点击按钮，界面上的数字并不会增加。很多人会感到迷惑，因为他查看调试器，发现数据确实已经增加了，Angular不是双向绑定吗，为什么数据变化了，界面没有跟着刷新？</p>
<p>试试在scope.counter++;这句之后加一句scope.digest();再看看是不是好了？</p>
<p>为什么要这么做呢，什么情况下要这么做呢？我们发现第一个例子中并没有digest，而且，如果你写了digest，它还会抛出异常，说正在做其他的digest，这是怎么回事？</p>
<p>我们先想想，假如没有AngularJS，我们想要自己实现这么个功能，应该怎样？</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div></pre></td><td class="code"><pre><div class="line">&lt;!DOCTYPE html&gt;</div><div class="line">&lt;html&gt;</div><div class="line">    &lt;head&gt;</div><div class="line">        &lt;meta charset=&quot;utf-8&quot; /&gt;</div><div class="line">        &lt;title&gt;two-way binding&lt;/title&gt;</div><div class="line">    &lt;/head&gt;</div><div class="line">    &lt;body onload=&quot;init()&quot;&gt;</div><div class="line">        &lt;button ng-click=&quot;inc&quot;&gt;</div><div class="line">            increase 1</div><div class="line">        &lt;/button&gt;</div><div class="line">        &lt;button ng-click=&quot;inc2&quot;&gt;</div><div class="line">            increase 2</div><div class="line">        &lt;/button&gt;</div><div class="line">        &lt;span style=&quot;color:red&quot; ng-bind=&quot;counter&quot;&gt;&lt;/span&gt;</div><div class="line">        &lt;span style=&quot;color:blue&quot; ng-bind=&quot;counter&quot;&gt;&lt;/span&gt;</div><div class="line">        &lt;span style=&quot;color:green&quot; ng-bind=&quot;counter&quot;&gt;&lt;/span&gt;</div><div class="line"></div><div class="line">        &lt;script type=&quot;text/javascript&quot;&gt;</div><div class="line">            /* 数据模型区开始 */</div><div class="line">            var counter = 0;</div><div class="line"></div><div class="line">            function inc() &#123;</div><div class="line">                counter++;</div><div class="line">            &#125;</div><div class="line"></div><div class="line">            function inc2() &#123;</div><div class="line">                counter+=2;</div><div class="line">            &#125;</div><div class="line">            /* 数据模型区结束 */</div><div class="line"></div><div class="line">            /* 绑定关系区开始 */</div><div class="line">            function init() &#123;</div><div class="line">                bind();</div><div class="line">            &#125;</div><div class="line"></div><div class="line">            function bind() &#123;</div><div class="line">                var list = document.querySelectorAll(&quot;[ng-click]&quot;);</div><div class="line">                for (var i=0; i&lt;list.length; i++) &#123;</div><div class="line">                    list[i].onclick = (function(index) &#123;</div><div class="line">                        return function() &#123;</div><div class="line">                            window[list[index].getAttribute(&quot;ng-click&quot;)]();</div><div class="line">                            apply();</div><div class="line">                        &#125;;</div><div class="line">                    &#125;)(i);</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line"></div><div class="line">            function apply() &#123;</div><div class="line">                var list = document.querySelectorAll(&quot;[ng-bind=&apos;counter&apos;]&quot;);</div><div class="line">                for (var i=0; i&lt;list.length; i++) &#123;</div><div class="line">                    list[i].innerHTML = counter;</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">            /* 绑定关系区结束 */</div><div class="line">        &lt;/script&gt;</div><div class="line">    &lt;/body&gt;</div><div class="line">&lt;/html&gt;</div></pre></td></tr></table></figure>
<p>可以看到，在这么一个简单的例子中，我们做了一些双向绑定的事情。从两个按钮的点击到数据的变更，这个很好理解，但我们没有直接使用DOM的onclick方法，而是搞了一个ng-click，然后在bind里面把这个ng-click对应的函数拿出来，绑定到onclick的事件处理函数中。为什么要这样呢？因为数据虽然变更了，但是还没有往界面上填充，我们需要在此做一些附加操作。</p>
<p>从另外一个方面看，当数据变更的时候，需要把这个变更应用到界面上，也就是那三个span里。但由于Angular使用的是脏检测，意味着当改变数据之后，你自己要做一些事情来触发脏检测，然后再应用到这个数据对应的DOM元素上。问题就在于，怎样触发脏检测？什么时候触发？</p>
<p>我们知道，一些基于setter的框架，它可以在给数据设值的时候，对DOM元素上的绑定变量作重新赋值。脏检测的机制没有这个阶段，它没有任何途径在数据变更之后立即得到通知，所以只能在每个事件入口中手动调用apply()，把数据的变更应用到界面上。在真正的Angular实现中，这里先进行脏检测，确定数据有变化了，然后才对界面设值。</p>
<p>所以，我们在ng-click里面封装真正的click，最重要的作用是为了在之后追加一次apply()，把数据的变更应用到界面上去。</p>
<p>那么，为什么在ng-click里面调用$digest的话，会报错呢？因为Angular的设计，同一时间只允许一个$digest运行，而ng-click这种内置指令已经触发了$digest，当前的还没有走完，所以就出错了。</p>
<h1 id="digest和-apply"><a href="#digest和-apply" class="headerlink" title="$digest和$apply"></a>$digest和$apply</h1><p>在Angular中，有$apply和$digest两个函数，我们刚才是通过$digest来让这个数据应用到界面上。但这个时候，也可以不用$digest，而是使用$apply，效果是一样的，那么，它们的差异是什么呢？</p>
<p>最直接的差异是，$apply可以带参数，它可以接受一个函数，然后在应用数据之后，调用这个函数。所以，一般在集成非Angular框架的代码时，可以把代码写在这个里面调用。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">var app = angular.module(&quot;test&quot;, []);</div><div class="line"></div><div class="line">app.directive(&quot;myclick&quot;, function() &#123;</div><div class="line">    return function (scope, element, attr) &#123;</div><div class="line">        element.on(&quot;click&quot;, function() &#123;</div><div class="line">            scope.counter++;</div><div class="line">            scope.$apply(function() &#123;</div><div class="line">                scope.counter++;</div><div class="line">            &#125;);</div><div class="line">        &#125;);</div><div class="line">    &#125;;</div><div class="line">&#125;);</div><div class="line"></div><div class="line">app.controller(&quot;CounterCtrl&quot;, function($scope) &#123;</div><div class="line">    $scope.counter = 0;</div><div class="line">&#125;);</div></pre></td></tr></table></figure>
<p>除此之外，还有别的区别吗？</p>
<p>在简单的数据模型中，这两者没有本质差别，但是当有层次结构的时候，就不一样了。考虑到有两层作用域，我们可以在父作用域上调用这两个函数，也可以在子作用域上调用，这个时候就能看到差别了。</p>
<p>对于$digest来说，在父作用域和子作用域上调用是有差别的，但是，对于$apply来说，这两者一样。我们来构造一个特殊的示例：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div></pre></td><td class="code"><pre><div class="line">var app = angular.module(&quot;test&quot;, []);</div><div class="line"></div><div class="line">app.directive(&quot;increasea&quot;, function() &#123;</div><div class="line">    return function (scope, element, attr) &#123;</div><div class="line">        element.on(&quot;click&quot;, function() &#123;</div><div class="line">            scope.a++;</div><div class="line">            scope.$digest();</div><div class="line">        &#125;);</div><div class="line">    &#125;;</div><div class="line">&#125;);</div><div class="line"></div><div class="line">app.directive(&quot;increaseb&quot;, function() &#123;</div><div class="line">    return function (scope, element, attr) &#123;</div><div class="line">        element.on(&quot;click&quot;, function() &#123;</div><div class="line">            scope.b++;</div><div class="line">            scope.$digest();    //这个换成$apply即可</div><div class="line">        &#125;);</div><div class="line">    &#125;;</div><div class="line">&#125;);</div><div class="line"></div><div class="line">app.controller(&quot;OuterCtrl&quot;, [&quot;$scope&quot;, function($scope) &#123;</div><div class="line">    $scope.a = 1;</div><div class="line"></div><div class="line">    $scope.$watch(&quot;a&quot;, function(newVal) &#123;</div><div class="line">        console.log(&quot;a:&quot; + newVal);</div><div class="line">    &#125;);</div><div class="line"></div><div class="line">    $scope.$on(&quot;test&quot;, function(evt) &#123;</div><div class="line">        $scope.a++;</div><div class="line">    &#125;);</div><div class="line">&#125;]);</div><div class="line"></div><div class="line">app.controller(&quot;InnerCtrl&quot;, [&quot;$scope&quot;, function($scope) &#123;</div><div class="line">    $scope.b = 2;</div><div class="line"></div><div class="line">    $scope.$watch(&quot;b&quot;, function(newVal) &#123;</div><div class="line">        console.log(&quot;b:&quot; + newVal);</div><div class="line">        $scope.$emit(&quot;test&quot;, newVal);</div><div class="line">    &#125;);</div><div class="line">&#125;]);</div></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">&lt;div ng-app=&quot;test&quot;&gt;</div><div class="line">    &lt;div ng-controller=&quot;OuterCtrl&quot;&gt;</div><div class="line">        &lt;div ng-controller=&quot;InnerCtrl&quot;&gt;</div><div class="line">            &lt;button increaseb&gt;increase b&lt;/button&gt;</div><div class="line">            &lt;span ng-bind=&quot;b&quot;&gt;&lt;/span&gt;</div><div class="line">        &lt;/div&gt;</div><div class="line">        &lt;button increasea&gt;increase a&lt;/button&gt;</div><div class="line">        &lt;span ng-bind=&quot;a&quot;&gt;&lt;/span&gt;</div><div class="line">    &lt;/div&gt;</div><div class="line">&lt;/div&gt;</div></pre></td></tr></table></figure>
<p>这时候，我们就能看出差别了，在increase b按钮上点击，这时候，a跟b的值其实都已经变化了，但是界面上的a没有更新，直到点击一次increase a，这时候刚才对a的累加才会一次更新上来。怎么解决这个问题呢？只需在increaseb这个指令的实现中，把$digest换成$apply即可。</p>
<p>当调用$digest的时候，只触发当前作用域和它的子作用域上的监控，但是当调用$apply的时候，会触发作用域树上的所有监控。</p>
<p>因此，从性能上讲，如果能确定自己作的这个数据变更所造成的影响范围，应当尽量调用$digest，只有当无法精确知道数据变更造成的影响范围时，才去用$apply，很暴力地遍历整个作用域树，调用其中所有的监控。</p>
<p>从另外一个角度，我们也可以看到，为什么调用外部框架的时候，是推荐放在$apply中，因为只有这个地方才是对所有数据变更都应用的地方，如果用$digest，有可能临时丢失数据变更。</p>
<h1 id="脏检测的利弊"><a href="#脏检测的利弊" class="headerlink" title="脏检测的利弊"></a>脏检测的利弊</h1><p>很多人对Angular的脏检测机制感到不屑，推崇基于setter，getter的观测机制，在我看来，这只是同一个事情的不同实现方式，并没有谁完全胜过谁，两者是各有优劣的。</p>
<p>大家都知道，在循环中批量添加DOM元素的时候，会推荐使用DocumentFragment，为什么呢，因为如果每次都对DOM产生变更，它都要修改DOM树的结构，性能影响大，如果我们能先在文档碎片中把DOM结构创建好，然后整体添加到主文档中，这个DOM树的变更就会一次完成，性能会提高很多。</p>
<p>同理，在Angular框架里，考虑到这样的场景：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line">function TestCtrl($scope) &#123;</div><div class="line">    $scope.numOfCheckedItems = 0;</div><div class="line"></div><div class="line">    var list = [];</div><div class="line"></div><div class="line">    for (var i=0; i&lt;10000; i++) &#123;</div><div class="line">        list.push(&#123;</div><div class="line">            index: i,</div><div class="line">            checked: false</div><div class="line">        &#125;);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    $scope.list = list;</div><div class="line"></div><div class="line">    $scope.toggleChecked = function(flag) &#123;</div><div class="line">        for (var i=0; i&lt;list.length; i++) &#123;</div><div class="line">            list[i].checked = flag;</div><div class="line">            $scope.numOfCheckedItems++;</div><div class="line">        &#125;</div><div class="line">    &#125;;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>如果界面上某个文本绑定这个numOfCheckedItems，会怎样？在脏检测的机制下，这个过程毫无压力，一次做完所有数据变更，然后整体应用到界面上。这时候，基于setter的机制就惨了，除非它也是像Angular这样把批量操作延时到一次更新，否则性能会更低。</p>
<p>所以说，两种不同的监控方式，各有其优缺点，最好的办法是了解各自使用方式的差异，考虑出它们性能的差异所在，在不同的业务场景中，避开最容易造成性能瓶颈的用法。</p>
]]></content>
    
    <summary type="html">
    
      接触Angular也有一段时间了，时常问自己一些问题, 如果是我实现它，会在哪些方面选择跟它相同的道路, 哪些方面不同。为此，记录了一些思考，给自己回顾，也供他人参考。
    
    </summary>
    
      <category term="Angularjs" scheme="https://github.com/ChangerHe/categories/Angularjs/"/>
    
    
      <category term="Angularjs" scheme="https://github.com/ChangerHe/tags/Angularjs/"/>
    
      <category term="数据绑定" scheme="https://github.com/ChangerHe/tags/%E6%95%B0%E6%8D%AE%E7%BB%91%E5%AE%9A/"/>
    
  </entry>
  
  <entry>
    <title>利用dpl实现对移动设备的像素实现精准控制</title>
    <link href="https://github.com/ChangerHe/2017/10/05/%E5%88%A9%E7%94%A8dpl%E5%AE%9E%E7%8E%B0%E5%AF%B9%E7%A7%BB%E5%8A%A8%E8%AE%BE%E5%A4%87%E7%9A%84%E5%83%8F%E7%B4%A0%E5%AE%9E%E7%8E%B0%E7%B2%BE%E5%87%86%E6%8E%A7%E5%88%B6/"/>
    <id>https://github.com/ChangerHe/2017/10/05/利用dpl实现对移动设备的像素实现精准控制/</id>
    <published>2017-10-05T14:14:14.000Z</published>
    <updated>2017-11-20T04:50:12.186Z</updated>
    
    <content type="html"><![CDATA[<p>dpl, 全称是device pixel ratio ,表示设备的像素比</p>
<p>设备在移动端因为物理像素和理论像素的不同而产生了显示的差异, 随着科技的发展, 设备的物理像素与理论像素之比由之前的一比一变成了多比一, 其中比较典型的就是, iphone6的设备像素比是2:1, iphone6 plus是3:1</p>
<p>因为其显示的差异, 也造成了我们在电脑上做的页面, 在移动端出现了显示异常的情况</p>
<p>而在js的window对象中有一个属性专门用于表示设备我的像素比例, 名叫devicePixelRatio, 也就是说, 我们可以使用window.devicePixelRatio来显示出当前设备的物理像素和实际像素的比例.</p>
<p>也同样是因为这个问题, 催生了移动设备一像素的问题, 因为我们在电脑上设置1px, 导致在手机端显示为2px甚至更多, 在需要精细化控制设计图的情况下会使页面非常不美观</p>
<p>解决这个问题，主要思想是：使用伪元素设置1px的边框，然后使用媒体查询，根据dpr的大小，对边框进行缩放（scaleY）。详细代码如下所示： </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div></pre></td><td class="code"><pre><div class="line">&lt;template&gt;</div><div class="line">  &lt;div id=&quot;app&quot;&gt;</div><div class="line">    &lt;div class=&quot;tab border-1px&quot;&gt; &lt;!-- !!!!!!! --&gt;</div><div class="line">      &lt;div class=&quot;tab-items&quot;&gt;</div><div class="line">        &lt;router-link  to=&quot;/goods&quot;&gt;商品&lt;/router-link&gt;</div><div class="line">      &lt;/div&gt;</div><div class="line">      &lt;div class=&quot;tab-items&quot;&gt;</div><div class="line">         &lt;router-link  to=&quot;/ratings&quot;&gt;评价&lt;/router-link&gt;</div><div class="line">      &lt;/div&gt;</div><div class="line">      &lt;div class=&quot;tab-items&quot;&gt;</div><div class="line">        &lt;router-link  to=&quot;/seller&quot;&gt;商店&lt;/router-link&gt;</div><div class="line">      &lt;/div&gt;</div><div class="line">    &lt;/div&gt;</div><div class="line">    &lt;div class=&quot;content&quot;&gt;</div><div class="line">      &lt;router-view&gt;&lt;/router-view&gt;</div><div class="line">    &lt;/div&gt;</div><div class="line">  &lt;/div&gt;</div><div class="line">&lt;/template&gt;</div><div class="line"></div><div class="line">&lt;script&gt;</div><div class="line">&lt;/script&gt;</div><div class="line"></div><div class="line">&lt;style lang=&quot;stylus&quot; rel=&quot;stylesheet/stylus&quot;&gt;</div><div class="line">@import &quot;./common/stylus/mixin.styl&quot;</div><div class="line">@import &quot;./common/stylus/base.styl&quot;</div><div class="line">#app</div><div class="line">  .tab</div><div class="line">    display: flex</div><div class="line">    width: 100%</div><div class="line">    height: 40px</div><div class="line">    line-height: 40px</div><div class="line">    border-1px(blue)  /*!!!!!!*/</div><div class="line">    .tab-items</div><div class="line">      flex: 1</div><div class="line">      text-align: center</div><div class="line">      font-size: 14px</div><div class="line">      &amp; &gt; a</div><div class="line">        display: block</div><div class="line">        width: 100%</div><div class="line">        color: rgb(77, 85, 93)</div><div class="line">        &amp;.router-link-active</div><div class="line">          color: rgb(240, 20, 20)</div><div class="line">  .seller</div><div class="line">    border-bottom: 1px solid blue  /*用于对比，在移动端实际显示2px*/</div><div class="line">&lt;/style&gt;</div></pre></td></tr></table></figure>
<p>看过滴滴打车的黄奕老师的vue开发饿了么教程的童鞋可以知道这就是初期构建的商家详情的spa单页骨架雏形哈哈</p>
<p>可以看到我们使用到了stylus中的mixin对移动端设备一像素问题的解决办法</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">border-1px($color)</div><div class="line">    position: relative</div><div class="line">    &amp;::after</div><div class="line">        position: absolute</div><div class="line">        left: 0</div><div class="line">        bottom: 0</div><div class="line">        width: 100%</div><div class="line">        content: &apos; &apos;</div><div class="line">        border-top: 1px solid $color</div><div class="line"></div><div class="line">//图片的mixin，根据图片的不同dpr进行适配下显示高清问题</div><div class="line">bg-image($url) </div><div class="line">  background-image: url($url + &quot;@2x.png&quot;)</div><div class="line">  @media (-webkit-min-device-pixel-ratio: 3),(min-device-pixel-ratio: 3)</div><div class="line">    background-image: url($url + &quot;@3x.png&quot;)</div></pre></td></tr></table></figure>
<p>针对边框一像素问题, 我们使用的是伪类结合子绝父相, 然后将伪类的边框使用css3的transition: scale来进行缩放从而达到效果的</p>
<p>这里的bg-image($url) 是负责处理图片在不同dpr下显示的问题，原来跟1像素边框问题差不多，不过这里不需要重做，只是根据不同的media query来调用不同的图片显示，而这些图片是需要放在相对应的文件夹的。</p>
<p>再来看一下base中的内容</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">&lt;!--根据媒体查询@media设置不同的缩放比例(transform 的 scale)来修复1像素边框的问题--&gt;</div><div class="line">@media (-webkit-min-device-pixel-ratio: 1.5),(min-device-pixel-ratio: 1.5)</div><div class="line">    .border-1px</div><div class="line">        &amp;::after</div><div class="line">            -webkit-transform: scaleY(0.7)</div><div class="line">            transform: scaleY(0.7)</div><div class="line"></div><div class="line">@media (-webkit-min-device-pixel-ratio: 2),(min-device-pixel-ratio: 2)</div><div class="line">    .border-1px</div><div class="line">        &amp;::after</div><div class="line">            -webkit-transform: scaleY(0.5)</div><div class="line">            transform: scaleY(0.5)</div></pre></td></tr></table></figure>
<p>这里的修复1像素边框问题会拆分为2个部分，一个部分是这里的base.styl里面处理缩放，另外一部分是在mixin.styl里面处理重做border。<br>这里是一个base模块文件，只保留了基本的共用的css，需要结合其他的css文件(stylus)来合并理解<br>dpr一般是1或者2，1.5只是为了更精细的去适配1和2之间的手机型号</p>
]]></content>
    
    <summary type="html">
    
      一般在移动端，由于dpr（设备像素比）不为1，在PC端显示1像素的边框，在移动端其实显示为2px。解决这个问题，主要思想是：使用伪元素设置1px的边框，然后使用媒体查询，根据dpr的大小，对边框进行缩放（scaleY）。详细代码如下所示：  App.vue:
    
    </summary>
    
      <category term="移动端" scheme="https://github.com/ChangerHe/categories/%E7%A7%BB%E5%8A%A8%E7%AB%AF/"/>
    
    
      <category term="移动端" scheme="https://github.com/ChangerHe/tags/%E7%A7%BB%E5%8A%A8%E7%AB%AF/"/>
    
  </entry>
  
  <entry>
    <title>Javascript中隐式类型转换的神坑</title>
    <link href="https://github.com/ChangerHe/2017/09/30/Javascript%E4%B8%AD%E9%9A%90%E5%BC%8F%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2%E7%9A%84%E7%A5%9E%E5%9D%91/"/>
    <id>https://github.com/ChangerHe/2017/09/30/Javascript中隐式类型转换的神坑/</id>
    <published>2017-09-30T06:16:09.000Z</published>
    <updated>2017-09-30T03:41:50.749Z</updated>
    
    <content type="html"><![CDATA[<p>开篇之前, 大家先思考一个问题, 下面这段代码运行出来之后的结果是多少</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">++[[]][+[]]+[+[]]</div></pre></td></tr></table></figure>
<p>首先, 不得不说, 发现并提出这个问题的人是个天才，他怎么会遇到这样的一个问题。 </p>
<p>其次，回答这个问题的人更是一个天才，我难以想象他会回答这个问题，更难以想象的是，他的回答是如此的详细和丰富和完整，真正称得上诲人不倦。</p>
<p>不卖关子了, 这道题的答案是10, String类型的, 10</p>
<p>那么, 这个问题怎么解呢? 下面跟着我一起把小车开起来~</p>
<h1 id="回归本源"><a href="#回归本源" class="headerlink" title="回归本源"></a>回归本源</h1><p>我们先复习一下: JS中有两种数据类型: 基本数据类型, 复杂数据类型</p>
<p>基本数据类型存储在栈空间中, 类型加上ES6新增的Symbol一共六种</p>
<blockquote>
<p>string</p>
<p>number</p>
<p>boolean</p>
<p>undefined</p>
<p>null</p>
<p>symbol</p>
</blockquote>
<p>复杂数据类型存储在堆空间中,包含以下三种</p>
<blockquote>
<p>function</p>
<p>object</p>
<p>array</p>
</blockquote>
<p>但是听说最近爆出了Chrome的61版本存在的安全漏洞的问题</p>
<p>因为V8团队之前做的一个优化,将函数中的内部复杂数据类型直接存储在栈空间了, 导致V8对ES6的解构, for…of,rest参数的解析功能会变慢, 当然, 这又是另外一回事了.</p>
<h1 id="当我们执行加法操作时-JS在想什么"><a href="#当我们执行加法操作时-JS在想什么" class="headerlink" title="当我们执行加法操作时,JS在想什么"></a>当我们执行加法操作时,JS在想什么</h1><p>首先还是申明一下,下面的解释是在网上查阅资料, 加上我自己的实践得出的结果, 可能和准确值存在偏差. 欢迎指正</p>
<h2 id="加法运算的隐式转换的执行顺序"><a href="#加法运算的隐式转换的执行顺序" class="headerlink" title="加法运算的隐式转换的执行顺序"></a>加法运算的隐式转换的执行顺序</h2><p>加法运算符会触发三种类型转换：</p>
<blockquote>
<p>转换为原始值</p>
<p>转换为数字</p>
<p>转换为字符串</p>
</blockquote>
<h2 id="通过-ToPrimitive-将值转换为原始值"><a href="#通过-ToPrimitive-将值转换为原始值" class="headerlink" title="通过 ToPrimitive() 将值转换为原始值"></a>通过 ToPrimitive() 将值转换为原始值</h2><p>如果操作值是个原始值，则直接返回它。</p>
<p>否则，如果操作值是一个对象。则调用 obj.valueOf() 方法。 如果返回值是一个原始值，则返回这个原始值。</p>
<p>否则，调用 obj.toString() 方法。 如果返回值是一个原始值，则返回这个原始值。</p>
<p>否则，抛出 TypeError 异常。</p>
<h2 id="通过-ToNumber-将值转换为数字"><a href="#通过-ToNumber-将值转换为数字" class="headerlink" title="通过 ToNumber() 将值转换为数字"></a>通过 ToNumber() 将值转换为数字</h2><p>下面的表格解释了 ToNumber() 是如何将原始值转换成数字的</p>
<table>
<thead>
<tr>
<th style="text-align:center">参数</th>
<th style="text-align:center">结果</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">undefined</td>
<td style="text-align:center">NaN</td>
</tr>
<tr>
<td style="text-align:center">null</td>
<td style="text-align:center">+0</td>
</tr>
<tr>
<td style="text-align:center">boolean</td>
<td style="text-align:center">true被转换为1,false转换为+0</td>
</tr>
<tr>
<td style="text-align:center">number</td>
<td style="text-align:center">无需转换</td>
</tr>
<tr>
<td style="text-align:center">string</td>
<td style="text-align:center">由字符串解析为数字。例如，”324”被转换为324</td>
</tr>
</tbody>
</table>
<h2 id="通过ToString-将值转换为字符串"><a href="#通过ToString-将值转换为字符串" class="headerlink" title="通过ToString()将值转换为字符串"></a>通过ToString()将值转换为字符串</h2><p>下面的表格解释了 ToString() 是如何将原始值转换成字符串的</p>
<table>
<thead>
<tr>
<th style="text-align:center">参数</th>
<th style="text-align:center">结果</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">undefined</td>
<td style="text-align:center">“undefined”</td>
</tr>
<tr>
<td style="text-align:center">null</td>
<td style="text-align:center">“null”</td>
</tr>
<tr>
<td style="text-align:center">boolean</td>
<td style="text-align:center">“true” 或者 “false”</td>
</tr>
<tr>
<td style="text-align:center">number</td>
<td style="text-align:center">数字作为字符串。比如，”1.765”</td>
</tr>
<tr>
<td style="text-align:center">string</td>
<td style="text-align:center">无需转换</td>
</tr>
</tbody>
</table>
<h1 id="小小的总结一下"><a href="#小小的总结一下" class="headerlink" title="小小的总结一下"></a>小小的总结一下</h1><p>其实说这么多, 最后想表达的还是一个重要思想</p>
<p>对于JS中的加法, 流程是这样的</p>
<ul>
<li><p>判断两边的值是否都为普通的String或Number类型, 如果是,则直接进行数学相加或字符串的拼接操作</p>
</li>
<li><p>如果两边并非都为数字或字符串,那么首先会对相加值中的复杂数据类型进行valueOf()操作, 首先确定一下这个复杂数据类型能否通过求值来返回一个简单数据类型, 然后将求值结果与另一个值进行相加. </p>
</li>
<li><p>如果结果不是一个原始值, 则会调用toString()方法,将复杂类型直接转为字符串,进行拼接操作.</p>
</li>
</ul>
<p>码完了, 好累啊, 那么下面我们做一些简单的测试, 对应上面列出的几条语法</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">6 + &#123; valueOf: function () &#123; return 2 &#125; &#125;  // 8</div></pre></td></tr></table></figure>
<p>上面的代码中,我们把valueOf()转为了直接返回2, 所以因为在加法运算时会直接运行所以返回了2</p>
<p>没看懂? 没事儿咱们还有一个例子来说明这个问题,再来看一个好玩的</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">Number.prototype.valueOf = function() &#123;</div><div class="line">	return 3</div><div class="line">&#125;</div><div class="line"></div><div class="line">new Number(2) == 3 // true</div></pre></td></tr></table></figure>
<p>接下来看个简单的</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">[] + [] // &quot;&quot;</div></pre></td></tr></table></figure>
<p>为什么返回空值呢? 因为[]的valueOf值就是空值啊</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">[] + &#123;&#125; // &apos;&apos;[object Object]&apos;&apos;</div></pre></td></tr></table></figure>
<p>同样的,因为{} 的valueOf()返回的是<code>[object Object]</code>, 加上前面的<code>`, 所以返回了</code>[object Object]`</p>
<h1 id="开始的结果解析"><a href="#开始的结果解析" class="headerlink" title="开始的结果解析"></a>开始的结果解析</h1><p>看完这些之后,我们再看一下开始的代码</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">++[[]][+[]]+[+[]]</div></pre></td></tr></table></figure>
<p>其实这样就很好解释了</p>
<p>根据优先级,会先计算括号内的元素</p>
<p><code>[[]]</code> 变成了 <code>[&#39;&#39;]</code></p>
<p><code>[+[]]</code> 变成了 <code>[0]</code></p>
<p>上面的代码可以简化为</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">++[&apos;&apos;][0] + [0]</div></pre></td></tr></table></figure>
<p>而<code>[&#39;&#39;][0]</code> , 数组的第零位,也就是<code>&#39;&#39;</code>, 进行自加操作时进行上述的隐式类型转换, 变成了0, 自加1, 所以变成了1</p>
<p>同样的 <code>[0]</code> 会被转换为 0 , 注意是字符类型的 0</p>
<p>所以最后的结果是</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">1 + &quot;0&quot;</div></pre></td></tr></table></figure>
<p>所以答案是 ‘10’</p>
<p>(完)</p>
]]></content>
    
    <summary type="html">
    
      开篇之前, 大家先思考一个问题, 下面这段代码运行出来之后的结果是多少 ++[[]][+[]]+[+[]]   
    
    </summary>
    
      <category term="JavaScript 学习笔记" scheme="https://github.com/ChangerHe/categories/JavaScript-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="JavaScript" scheme="https://github.com/ChangerHe/tags/JavaScript/"/>
    
  </entry>
  
  <entry>
    <title>Chrome61发布,这新功能怕是没谁了</title>
    <link href="https://github.com/ChangerHe/2017/09/24/Chrome61%E5%8F%91%E5%B8%83,%E8%BF%99%E6%96%B0%E5%8A%9F%E8%83%BD%E6%80%95%E6%98%AF%E6%B2%A1%E8%B0%81%E4%BA%86/"/>
    <id>https://github.com/ChangerHe/2017/09/24/Chrome61发布,这新功能怕是没谁了/</id>
    <published>2017-09-24T15:11:42.000Z</published>
    <updated>2017-11-11T06:03:30.202Z</updated>
    
    <content type="html"><![CDATA[<p>Chrome 61 正式版已于2017年9月6日正式发布，并增加了很多开发者相关的功能。在 Mac、Windows 和 Linux 系统中，Chrome 61 开始支持 WebUSB API，以及 PaymentRequest API。</p>
<p>高级网络平台 API 支持大多数硬件外设，如键盘、鼠标、打印机和游戏手柄。为了使用教育、科学或工业等专用 USB 外设，用户必须使用系统级权限查找和安装可能不安全的驱动程序和软件。</p>
<p>当然, 最让人激动的是, chrome已经开始支持ES6的module功能, 原生开始支持模块化开发!</p>
<h1 id="chrome中使用模块化功能"><a href="#chrome中使用模块化功能" class="headerlink" title="chrome中使用模块化功能"></a>chrome中使用模块化功能</h1><p>Chrome 61 加入了对 JavaScript Module <code>&lt;script type=&quot;module&quot;&gt;</code>的原生支持。Chrome 现在可以并行地获取颗粒化的依赖模块，利用浏览器缓存的优势，在多个页面之间共享模块，并且可以保证脚本按照正确地顺序执行。</p>
<p>下面是我直接在html文件中写入, 的代码</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">&lt;script type=&quot;module&quot;&gt;</div><div class="line">	import utils from &quot;./test.js&quot;</div><div class="line">	utils()</div><div class="line">&lt;/script&gt;</div></pre></td></tr></table></figure>
<p>再看一下我所引入的依赖</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">// 相同目录下的test.js</div><div class="line">function utils() &#123;</div><div class="line">  console.log(1)</div><div class="line">&#125;</div><div class="line"></div><div class="line">export default utils</div></pre></td></tr></table></figure>
<p>最后, 我们使用编辑器自带的服务器开启运行, 我使用的是VSCode, 当然, 像webstorm, Hbuilder之类的都自带了服务器</p>
<p>需要注意的是, 不使用服务器而是直接使用双击打开文件的方式是没有办法体验这种功能的</p>
<p>最后我们可以看到在chrome61+控制台上打印出了1</p>
<h1 id="web-share-api"><a href="#web-share-api" class="headerlink" title="web share api"></a>web share api</h1><p>为了让用户把他们喜欢的内容分享到网络上，不得把所有的社交按钮在自己的网站上添加一遍。这让页面变得很臃肿，很可能这些分享按钮和网站的视觉不匹配，并且还要添加来自第三方的代码。</p>
<p>现在，Android 版的 Chrome 新增了 Web Share API，该 API 可以直接调用原生的分享功能，用户可以很方便的将自己喜欢的文本和链接分享到其他原生 App 上了！</p>
<p>在之后的版本中，这个 API 还能分享到已安装的 web app 中。直接调用 navigator.share 方法，传递相关的参数，就可以发起分享。其他事情系统会帮你搞定。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">navigator.share(&#123;</div><div class="line">  title: document.title, text: &apos;Hello&apos;,</div><div class="line">  url: window.location.href</div><div class="line">&#125;).then(() =&gt; &#123;</div><div class="line">  console.log(&apos;Successful share&apos;);</div><div class="line">&#125;);</div></pre></td></tr></table></figure>
<h1 id="WebUSB"><a href="#WebUSB" class="headerlink" title="WebUSB"></a>WebUSB</h1><p>很多电脑的周边硬件在 Web 平台上都有对应的 API，比如键盘、鼠标、打印机和手柄等等。但是，想要在浏览器中使用某些特殊的用于教育、科研、工业等等 USB 设备很困难，通常需要特殊的驱动才行。</p>
<p>现在 Chrome 提供了 WebUSB API，在用户授权后，Web 应用可以直接可 USB 设备通信。</p>
<p>要了解更多, 可登陆google开发者平台了解详情…</p>
]]></content>
    
    <summary type="html">
    
      Chrome 61 正式版已于2017年9月6日正式发布，并增加了很多开发者相关的功能。在 Mac、Windows 和 Linux 系统中，Chrome 61 开始支持 WebUSB API，以及 PaymentRequest API。
    
    </summary>
    
      <category term="Chrome" scheme="https://github.com/ChangerHe/categories/Chrome/"/>
    
    
      <category term="Chrome" scheme="https://github.com/ChangerHe/tags/Chrome/"/>
    
  </entry>
  
  <entry>
    <title>微信公众平台接口配置信息详解---Nodejs版</title>
    <link href="https://github.com/ChangerHe/2017/09/24/%E5%BE%AE%E4%BF%A1%E5%85%AC%E4%BC%97%E5%B9%B3%E5%8F%B0%E6%8E%A5%E5%8F%A3%E9%85%8D%E7%BD%AE%E4%BF%A1%E6%81%AF%E8%AF%A6%E8%A7%A3---Nodejs%E7%89%88/"/>
    <id>https://github.com/ChangerHe/2017/09/24/微信公众平台接口配置信息详解---Nodejs版/</id>
    <published>2017-09-24T15:11:42.000Z</published>
    <updated>2017-11-13T15:13:37.565Z</updated>
    
    <content type="html"><![CDATA[<p>首先,要说明一点的是, 虽然标题有说是: nodejs版, 那么会有其他的版本配置方法详情吗?</p>
<p>答案是没有, 不过在微信公众平台上有详细说明了PHP为后台的配置版本, 如果有兴趣的童鞋可以过去看一下, 这里就不做赘述了</p>
<p>那么本篇博客主要写哪些呢, 博客的受众有哪些呢?</p>
<p>本篇博客主要是针对需要进行微信公众平台进行开发的个人开发者, 因为在个人申请公众号的过程中存在诸多限制, 而微信则比较体贴地提供了针对个人开发者的公众平台测试帐号, 这样就可以无需申请公众帐号就能在测试帐号中体验并测试微信公众平台所有高级接口了. </p>
<p>而根据微信方的要求, 个人开发者需要有自己的服务器, 并且对微信的加密token能够正确地进行返回数据, 进行一番验证之后才能够享受微信所提供的开发者服务</p>
<p>那么问题来了, 我没有服务器怎么办啊?</p>
<p>哎不对, 我也不会正确的接收token和返回token啊! 怎么搞~</p>
<p>这里根据实际情况, 因为即使你有服务器, 每次还要登陆服务器, 势必会造成很大的麻烦, 那么我们一般会使用到ngrok的内网转发服务</p>
<p>想必到这里很多人不知道ngrok是什么, 这里从百度百科扒一个词条过来解释一下</p>
<blockquote>
<p>ngrok 是一个反向代理，通过在公共的端点和本地运行的 Web 服务器之间建立一个安全的通道。ngrok 可捕获和分析所有通道上的流量，便于后期分析和重放</p>
</blockquote>
<p>讲得那么复杂, 简单总结一下, 就是使用这玩意儿就可以将你的本地开启的服务器当做一个外网服务器来使用, 也就是说从微信发过来的验证token, 是可以直接发送到我们的电脑上, 从而成功校验token, 美滋滋~</p>
<h1 id="ngrok的使用及配置"><a href="#ngrok的使用及配置" class="headerlink" title="ngrok的使用及配置"></a>ngrok的使用及配置</h1><p>ngrok本身是源自美国的公司提供的一项反向代理的服务, 使用它就可以很方便地进行反向代理了.</p>
<h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><p><img src="https://ngrok.com/download" alt="官网下载">地址下载, 解压</p>
<p>将可执行文件ngrok移到任意文件夹内</p>
<p>如果需要在命令行直接执行, 则需要进行配置全局变量, 这个有些复杂, 就不展开讲了, 如果有不想每次都要找到这个文件双击打开, 而是直接使用CMD的同学, 可以试一下(不过我觉得每次双击打开问价没啥不好的啊)</p>
<h2 id="注册授权"><a href="#注册授权" class="headerlink" title="注册授权"></a>注册授权</h2><p>现在其实是可以进行正常捕获到请求了, 但是现在有个问题就是, 这一切是不是来的太简单了…</p>
<p>没错, 还差一步, 就是要官网的一个token</p>
<p><img src="https://dashboard.ngrok.com/user/signup" alt="sign up for an account in ngrok"> 获取ngrok的授权码,</p>
<h2 id="进行本机认证-Install-your-authtoken"><a href="#进行本机认证-Install-your-authtoken" class="headerlink" title="进行本机认证 Install your authtoken"></a>进行本机认证 Install your authtoken</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">ngrok authtoken &lt;YOUR_AUTHTOKEN&gt;</div></pre></td></tr></table></figure>
<h2 id="设置外网的访问密码-选做"><a href="#设置外网的访问密码-选做" class="headerlink" title="设置外网的访问密码(选做)"></a>设置外网的访问密码(选做)</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">// username 用户名 password密码 8080相关的端口</div><div class="line">ngrok http -auth=&quot;username:password&quot; 8080</div></pre></td></tr></table></figure>
<h2 id="配置妥当"><a href="#配置妥当" class="headerlink" title="配置妥当"></a>配置妥当</h2><p>那么现在我们可以输入以下命令, 启动ngrok了</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">ngrok http 8080</div></pre></td></tr></table></figure>
<p>当然, 这个端口可以自己设置, 开心就好</p>
<p>现在我们到浏览器中输入</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">localhost:4040</div></pre></td></tr></table></figure>
<p>即可看到ngrok的监控页面, 上面有为你分配的http和https两个网址,把网址复制到微信公众平台的测试账号申请的接口配置信息中</p>
<h1 id="离成功还差半步"><a href="#离成功还差半步" class="headerlink" title="离成功还差半步"></a>离成功还差半步</h1><p>那么, 我们成功设置了ngrok了, 现在要准备对接微信的接口了, 微信的access_token每次传输的内容有下面几个:</p>
<table>
<thead>
<tr>
<th style="text-align:center">参数</th>
<th style="text-align:center">描述</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">signature</td>
<td style="text-align:center">微信加密签名，signature结合了开发者填写的token参数和请求中的timestamp参数、nonce参数。</td>
</tr>
<tr>
<td style="text-align:center">timestamp</td>
<td style="text-align:center">时间戳</td>
</tr>
<tr>
<td style="text-align:center">nonce</td>
<td style="text-align:center">随机数</td>
</tr>
<tr>
<td style="text-align:center">echostr</td>
<td style="text-align:center">随机字符串</td>
</tr>
</tbody>
</table>
<p>开发者通过检验signature对请求进行校验（下面有校验方式）。若确认此次GET请求来自微信服务器，请原样返回echostr参数内容，则接入生效，成为开发者成功，否则接入失败。加密/校验流程如下：</p>
<p>-1）将token、timestamp、nonce三个参数进行字典序排序</p>
<p>-2）将三个参数字符串拼接成一个字符串进行sha1加密</p>
<p>-3）开发者获得加密后的字符串可与signature对比，标识该请求来源于微信</p>
<h1 id="PHP实例代码"><a href="#PHP实例代码" class="headerlink" title="PHP实例代码"></a>PHP实例代码</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">private function checkSignature () &#123;</div><div class="line">	_GET[&quot;signature&quot;];</div><div class="line">	_GET[&quot;timestamp&quot;];</div><div class="line">	_GET[&quot;nonce&quot;];</div><div class="line">        </div><div class="line">	tmpArr = array(timestamp, $nonce);</div><div class="line">	sort($tmpArr, SORT_STRING);</div><div class="line">	$tmpStr = implode( $tmpArr );</div><div class="line">	$tmpStr = sha1( $tmpStr );</div><div class="line"></div><div class="line">	if( signature )&#123;</div><div class="line">		return true;</div><div class="line">	&#125; else &#123;</div><div class="line">		return false;</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>以上为微信官网的PHP实例代码, 作为一个会nodejs的小学森, 怎么能不用nodejs呢, 看下nodejs的写法</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div></pre></td><td class="code"><pre><div class="line">const Koa = require(&apos;koa&apos;)</div><div class="line">const sha1 = require(&apos;sha1&apos;)</div><div class="line"></div><div class="line">var config = &#123;</div><div class="line">	wechat: &#123;</div><div class="line">		appId: &apos;***&apos;,</div><div class="line">		appSecret: &apos;***&apos;,</div><div class="line">		token: &apos;***&apos;</div><div class="line">	&#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">var app = new Koa()</div><div class="line"></div><div class="line">app.use(function* (next) &#123;</div><div class="line">	console.log(this.query)</div><div class="line"></div><div class="line">	var token = config.wechat.token</div><div class="line">	var signature = this.query.signature</div><div class="line">	var nonce = this.query.nonce</div><div class="line">	var timestamp = this.query.timestamp</div><div class="line">	var echostr = this.query.echostr</div><div class="line"></div><div class="line">	var str = [token, timestamp, nonce].sort().join(&apos;&apos;)</div><div class="line">	var sha = sha1(str)</div><div class="line">	console.log(sha)</div><div class="line">	if (sha === signature) &#123;</div><div class="line">		this.body = echostr</div><div class="line">	&#125; else &#123;</div><div class="line">		this.body = &apos;wrong&apos;</div><div class="line">	&#125;</div><div class="line">&#125;)</div><div class="line"></div><div class="line">app.listen(8090)</div><div class="line"></div><div class="line">console.log(&apos;listening 8090&apos;)</div></pre></td></tr></table></figure>
<p>这里用到了koa框架和sha1加密组件, 喜欢其他的方式的童鞋可以使用其他的开发方法, 总体来说都是一样的</p>
]]></content>
    
    <summary type="html">
    
      本篇博客主要是针对需要进行微信公众平台进行开发的个人开发者, 因为在个人申请公众号的过程中存在诸多限制, 而微信则比较体贴地提供了针对个人开发者的公众平台测试帐号, 这样就可以无需申请公众帐号就能在测试帐号中体验并测试微信公众平台所有高级接口了. 
    
    </summary>
    
      <category term="微信公众平台" scheme="https://github.com/ChangerHe/categories/%E5%BE%AE%E4%BF%A1%E5%85%AC%E4%BC%97%E5%B9%B3%E5%8F%B0/"/>
    
    
      <category term="微信公众平台" scheme="https://github.com/ChangerHe/tags/%E5%BE%AE%E4%BF%A1%E5%85%AC%E4%BC%97%E5%B9%B3%E5%8F%B0/"/>
    
  </entry>
  
  <entry>
    <title>sass/scss和less的区别</title>
    <link href="https://github.com/ChangerHe/2017/09/01/sass-scss%E5%92%8Cless%E7%9A%84%E5%8C%BA%E5%88%AB/"/>
    <id>https://github.com/ChangerHe/2017/09/01/sass-scss和less的区别/</id>
    <published>2017-09-01T15:13:23.000Z</published>
    <updated>2017-10-26T02:30:24.659Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Sass-Scss、Less是什么"><a href="#Sass-Scss、Less是什么" class="headerlink" title="Sass/Scss、Less是什么?"></a>Sass/Scss、Less是什么?</h1><p>Sass (Syntactically Awesome Stylesheets)是一种动态样式语言，Sass语法属于缩排语法，比css比多出好些功能(如变量、嵌套、运算,混入(Mixin)、继承、颜色处理，函数等)，更容易阅读。</p>
<h2 id="Sass与Scss是什么关系"><a href="#Sass与Scss是什么关系" class="headerlink" title="Sass与Scss是什么关系?"></a>Sass与Scss是什么关系?</h2><p>Sass的缩排语法，对于写惯css前端的web开发者来说很不直观，也不能将css代码加入到Sass里面，因此sass语法进行了改良，Sass 3就变成了Scss(sassy css)。与原来的语法兼容，只是用{}取代了原来的缩进。</p>
<p>Less也是一种动态样式语言. 对CSS赋予了动态语言的特性，如变量，继承，运算， 函数.  Less 既可以在客户端上运行 (支持IE 6+, Webkit, Firefox)，也可在服务端运行 (借助 Node.js)。</p>
<h1 id="Sass-Scss与Less区别"><a href="#Sass-Scss与Less区别" class="headerlink" title="Sass/Scss与Less区别"></a>Sass/Scss与Less区别</h1><h2 id="编译环境不一样"><a href="#编译环境不一样" class="headerlink" title="编译环境不一样"></a>编译环境不一样</h2><p>Sass的安装需要Ruby环境，是在服务端处理的，而Less是需要引入less.js来处理Less代码输出css到浏览器，也可以在开发环节使用Less，然后编译成css文件，直接放到项目中，也有 Less.app、SimpleLess、CodeKit.app这样的工具，也有在线编译地址。</p>
<h2 id="变量符不一样"><a href="#变量符不一样" class="headerlink" title="变量符不一样"></a>变量符不一样</h2><p>Less是@，而Scss是$，而且变量的作用域也不一样。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">// Less-作用域</div><div class="line">@color: #00c; /* 蓝色 */</div><div class="line">#header &#123;</div><div class="line">  @color: #c00; /* red */</div><div class="line">  border: 1px solid @color; /* 红色边框 */</div><div class="line">&#125;</div><div class="line"></div><div class="line">#footer &#123;</div><div class="line">  border: 1px solid @color; /* 蓝色边框 */</div><div class="line">&#125;</div><div class="line"></div><div class="line">// Less-作用域编译后</div><div class="line">#header&#123;border:1px solid #cc0000;&#125;</div><div class="line">#footer&#123;border:1px solid #0000cc;&#125;</div></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line">// scss-作用域</div><div class="line">$color: #00c; /* 蓝色 */</div><div class="line"></div><div class="line">#header &#123;</div><div class="line"></div><div class="line">  $color: #c00; /* red */</div><div class="line">  border: 1px solid $color; /* 红色边框 */</div><div class="line">&#125;</div><div class="line"></div><div class="line">#footer &#123;</div><div class="line">  border: 1px solid $color; /* 蓝色边框 */</div><div class="line">&#125;</div><div class="line"></div><div class="line">// Sass-作用域编译后</div><div class="line"></div><div class="line">#header&#123;border:1px solid #c00&#125;</div><div class="line">#footer&#123;border:1px solid #c00&#125;</div></pre></td></tr></table></figure>
<p>我们可以看出来，less和scss中的变量会随着作用域的变化而不一样。</p>
<h1 id="输出设置"><a href="#输出设置" class="headerlink" title="输出设置"></a>输出设置</h1><p>Less没有输出设置，Sass提供4中输出选项：nested, compact, compressed 和 expanded。</p>
<p>输出样式的风格可以有四种选择，默认为nested</p>
<p>-nested：嵌套缩进的css代码<br>-expanded：展开的多行css代码<br>-compact：简洁格式的css代码<br>-compressed：压缩后的css代码</p>
<h1 id="条件语句的支持"><a href="#条件语句的支持" class="headerlink" title="条件语句的支持"></a>条件语句的支持</h1><p>Sass支持条件语句，可以使用if{}else{},for{}循环等等。而Less不支持。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">// 简单的if语句</div><div class="line"></div><div class="line">@if lightness($color) &gt; 30% &#123;</div><div class="line"></div><div class="line">&#125; @else &#123;</div><div class="line"></div><div class="line">&#125;</div><div class="line"></div><div class="line">// 简单的for语句</div><div class="line"></div><div class="line">@for $i from 1 to 10 &#123;</div><div class="line">  .border-#&#123;$i&#125; &#123;</div><div class="line">    border: #&#123;$i&#125;px solid blue;</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h1 id="引用外部CSS文件"><a href="#引用外部CSS文件" class="headerlink" title="引用外部CSS文件"></a>引用外部CSS文件</h1><p>scss引用的外部文件命名必须以_开头, 如下例所示:其中_test1.scss、_test2.scss、<em>test3.scss文件分别设置的h1 h2 h3。文件名如果以下划线</em>开头的话，Sass会认为该文件是一个引用文件，不会将其编译为css文件.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line">// 源代码：</div><div class="line">@import &quot;_test1.scss&quot;;</div><div class="line">@import &quot;_test2.scss&quot;;</div><div class="line">@import &quot;_test3.scss&quot;;</div><div class="line"></div><div class="line">// 编译后：</div><div class="line">h1 &#123;</div><div class="line">  font-size: 17px;</div><div class="line">&#125;</div><div class="line"> </div><div class="line">h2 &#123;</div><div class="line">  font-size: 17px;</div><div class="line">&#125;</div><div class="line"> </div><div class="line">h3 &#123;</div><div class="line">  font-size: 17px;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>Less引用外部文件和css中的@import没什么差异。</p>
<h1 id="Sass和Less的工具库不同"><a href="#Sass和Less的工具库不同" class="headerlink" title="Sass和Less的工具库不同"></a>Sass和Less的工具库不同</h1><p>Sass有工具库Compass, 简单说，Sass和Compass的关系有点像Javascript和jQuery的关系,Compass是Sass的工具库。在它的基础上，封装了一系列有用的模块和模板，补充强化了Sass的功能。</p>
<p>Less有UI组件库Bootstrap,Bootstrap是web前端开发中一个比较有名的前端UI组件库，Bootstrap的样式文件部分源码就是采用Less语法编写。</p>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>不管是Sass，还是Less，都可以视为一种基于CSS之上的高级语言，其目的是使得CSS开发更灵活和更强大，Sass的功能比Less强大,基本可以说是一种真正的编程语言了，Less则相对清晰明了,易于上手,对编译环境要求比较宽松。考虑到编译Sass要安装Ruby,而Ruby官网在国内访问不了,个人在实际开发中更倾向于选择Less。</p>
]]></content>
    
    <summary type="html">
    
      Sass (Syntactically Awesome Stylesheets)是一种动态样式语言，Sass语法属于缩排语法，比css比多出好些功能(如变量、嵌套、运算,混入(Mixin)、继承、颜色处理，函数等)，更容易阅读。
    
    </summary>
    
      <category term="CSS" scheme="https://github.com/ChangerHe/categories/CSS/"/>
    
    
      <category term="SASS" scheme="https://github.com/ChangerHe/tags/SASS/"/>
    
      <category term="LESS" scheme="https://github.com/ChangerHe/tags/LESS/"/>
    
      <category term="SCSS" scheme="https://github.com/ChangerHe/tags/SCSS/"/>
    
  </entry>
  
  <entry>
    <title>基于MongoDB 2dSphere索引查找最近的点</title>
    <link href="https://github.com/ChangerHe/2017/07/21/%E5%9F%BA%E4%BA%8EMongoDB-2dSphere%E7%B4%A2%E5%BC%95%E6%9F%A5%E6%89%BE%E6%9C%80%E8%BF%91%E7%9A%84%E7%82%B9/"/>
    <id>https://github.com/ChangerHe/2017/07/21/基于MongoDB-2dSphere索引查找最近的点/</id>
    <published>2017-07-21T15:27:22.000Z</published>
    <updated>2017-09-24T15:35:44.241Z</updated>
    
    <content type="html"><![CDATA[<p>在移动端普及的今天，LBS应用需求也越来越大。比如查找附近的人，最近的餐厅等。面对这些需求，MongoDB提供了功能完备的解决方案。下面通过一个案例来解释一下MongoDB的2dSphere</p>
<p><img src="http://img.blog.csdn.net/20160923111644414" alt=""></p>
<p>在这个图片中，有A B C D E F G,假如我是搜索点A。我想查找离自己最近的点。下面是具体的操作步骤： </p>
<h1 id="建立集合和索引。sp为建立索引的字段名，我们建立的索引类型是2dsphere"><a href="#建立集合和索引。sp为建立索引的字段名，我们建立的索引类型是2dsphere" class="headerlink" title="建立集合和索引。sp为建立索引的字段名，我们建立的索引类型是2dsphere"></a>建立集合和索引。sp为建立索引的字段名，我们建立的索引类型是2dsphere</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"># 创建2dsphere索引</div><div class="line"> db.sphere.ensureIndex(&#123;&quot;sp&quot;:&quot;2dsphere&quot;&#125;)</div></pre></td></tr></table></figure>
<h1 id="向集合中插入测试数据，我们插入的是实际的经纬度。"><a href="#向集合中插入测试数据，我们插入的是实际的经纬度。" class="headerlink" title="向集合中插入测试数据，我们插入的是实际的经纬度。"></a>向集合中插入测试数据，我们插入的是实际的经纬度。</h1><p>这里需要注意的是，如果我们如果用的是2dsphere索引，那么插入的应该是GeoJson数据。GeoJson的格式是 </p>
<p><code>{ type: ‘GeoJSON type’ , coordinates: ‘coordinates’ }</code></p>
<p>其中type指的是类型，可以是Point(本例中用的)，LineString，Polygon等，coordinates是一个坐标数组。英语好的同学可以去官网看看<a href="https://docs.mongodb.com/manual/reference/geojson/" target="_blank" rel="external">https://docs.mongodb.com/manual/reference/geojson/</a></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"># 插入Point数据</div><div class="line">db.sphere.insert(&#123;name:&quot;A&quot;,sp:&#123;type:&quot;Point&quot;,coordinates:[105.754484701156,41.689607057699]&#125;&#125;)</div><div class="line">db.sphere.insert(&#123;name:&quot;B&quot;,sp:&#123;type:&quot;Point&quot;,coordinates:[105.304045248031,41.783456183240]&#125;&#125;)</div><div class="line">db.sphere.insert(&#123;name:&quot;C&quot;,sp:&#123;type:&quot;Point&quot;,coordinates:[105.084318685531,41.389027478812]&#125;&#125;)</div><div class="line">db.sphere.insert(&#123;name:&quot;D&quot;,sp:&#123;type:&quot;Point&quot;,coordinates:[105.831388998031,41.285916385493]&#125;&#125;)</div><div class="line">db.sphere.insert(&#123;name:&quot;E&quot;,sp:&#123;type:&quot;Point&quot;,coordinates:[106.128706502914,42.086868474465]&#125;&#125;)</div><div class="line">db.sphere.insert(&#123;name:&quot;F&quot;,sp:&#123;type:&quot;Point&quot;,coordinates:[105.431074666976,42.009365053841]&#125;&#125;)</div><div class="line">db.sphere.insert(&#123;name:&quot;G&quot;,sp:&#123;type:&quot;Point&quot;,coordinates:[104.705977010726,41.921549795110]&#125;&#125;)</div></pre></td></tr></table></figure>
<h1 id="进行查询。介绍一下其中的参数"><a href="#进行查询。介绍一下其中的参数" class="headerlink" title="进行查询。介绍一下其中的参数"></a>进行查询。介绍一下其中的参数</h1><blockquote>
<p>（1）geoNear:我们要查询的集合名称 </p>
<p>（2）near:就是基于那个点进行搜索，这里是我们的搜索点A </p>
<p>（3）spherical:是个布尔值，如果为true，表示将计算实际的物理距离比如两点之间有多少km,若为false,则会基于点的单位进行计算 </p>
<p>（4）minDistance:搜索的最小距离，这里的单位是米 </p>
<p>（5）maxDistance:搜索的最大距离</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">db.runCommand(&#123;</div><div class="line">    geoNear:&quot;sphere&quot;,</div><div class="line">    near:&#123;type:&quot;Point&quot;,coordinates:[105.794621276855,41.869574065014]&#125;,</div><div class="line">    spherical:true,</div><div class="line">    minDistance:25000,</div><div class="line">    maxDistance:40000,</div><div class="line">    &#125;)</div></pre></td></tr></table></figure>
<h1 id="结果分析"><a href="#结果分析" class="headerlink" title="结果分析"></a>结果分析</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div></pre></td><td class="code"><pre><div class="line">&#123;</div><div class="line">    &quot;waitedMS&quot; : NumberLong(0),</div><div class="line">    &quot;results&quot; : [ </div><div class="line">        &#123;</div><div class="line">            &quot;dis&quot; : 33887.5416611258,</div><div class="line">            &quot;obj&quot; : &#123;</div><div class="line">                &quot;_id&quot; : ObjectId(&quot;57e3857e6a4a326367ae0d05&quot;),</div><div class="line">                &quot;name&quot; : &quot;F&quot;,</div><div class="line">                &quot;sp&quot; : &#123;</div><div class="line">                    &quot;type&quot; : &quot;Point&quot;,</div><div class="line">                    &quot;coordinates&quot; : [ </div><div class="line">                        105.431074666976, </div><div class="line">                        42.009365053841</div><div class="line">                    ]</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">        &#125;, </div><div class="line">        &#123;</div><div class="line">            &quot;dis&quot; : 36734.9748784127,</div><div class="line">            &quot;obj&quot; : &#123;</div><div class="line">                &quot;_id&quot; : ObjectId(&quot;57e3857e6a4a326367ae0d04&quot;),</div><div class="line">                &quot;name&quot; : &quot;E&quot;,</div><div class="line">                &quot;sp&quot; : &#123;</div><div class="line">                    &quot;type&quot; : &quot;Point&quot;,</div><div class="line">                    &quot;coordinates&quot; : [ </div><div class="line">                        106.128706502914, </div><div class="line">                        42.086868474465</div><div class="line">                    ]</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    ],</div><div class="line">    &quot;stats&quot; : &#123;</div><div class="line">        &quot;nscanned&quot; : 24,</div><div class="line">        &quot;objectsLoaded&quot; : 20,</div><div class="line">        &quot;avgDistance&quot; : 35311.2582697693,</div><div class="line">        &quot;maxDistance&quot; : 36734.9748784127,</div><div class="line">        &quot;time&quot; : 87</div><div class="line">    &#125;,</div><div class="line">    &quot;ok&quot; : 1.0</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>在results中，我们搜索到了点F和E。每个文档都加上了一个dis字段，他表示这个点离你搜索点的距离。</p>
<p>比如说，在结果中name为F的点的dis为33887.5416611258。表示F点距离搜索点的距离是33887米。这个结果对于LBS应用是非常有用的。 </p>
]]></content>
    
    <summary type="html">
    
      在移动端普及的今天，LBS应用需求也越来越大。比如查找附近的人，最近的餐厅等。面对这些需求，MongoDB提供了功能完备的解决方案。下面通过一个案例来解释一下MongoDB的2dSphere
    
    </summary>
    
      <category term="MongoDB学习笔记" scheme="https://github.com/ChangerHe/categories/MongoDB%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="MongoDB" scheme="https://github.com/ChangerHe/tags/MongoDB/"/>
    
      <category term="2dSphere" scheme="https://github.com/ChangerHe/tags/2dSphere/"/>
    
  </entry>
  
  <entry>
    <title>《ES6标准入门》阅读笔记——-Module</title>
    <link href="https://github.com/ChangerHe/2017/07/20/%E3%80%8AES6%E6%A0%87%E5%87%86%E5%85%A5%E9%97%A8%E3%80%8B%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0%E2%80%94%E2%80%94-Module/"/>
    <id>https://github.com/ChangerHe/2017/07/20/《ES6标准入门》阅读笔记——-Module/</id>
    <published>2017-07-19T16:23:13.000Z</published>
    <updated>2017-09-18T00:42:20.342Z</updated>
    
    <content type="html"><![CDATA[<h1 id="写在前面"><a href="#写在前面" class="headerlink" title="写在前面"></a>写在前面</h1><p>本系列为在我读完阮一峰老师的《ES6标准入门》第二版之后，所做的阅读笔记的整理。</p>
<p>许多初学ES6, 同时和我一样初次阅读阮老师的这本书的时候, 读第一遍会越发的困惑, 因为阮老师上面说的很多的定义,方法,之前都是没有见过的, 读到后面才发现, 哦~原来是这样.</p>
<p>有一句话叫做”大神的世界我们不懂”, 所以我在初读第一遍《ES6标准入门》这本书的时候,也是踩了不少坑,读书的时候查阅了不少的资料.</p>
<p>所以,在这一系列的笔记教程中,我会从一个初学者的角度,向您讲述ES6的相关知识,在后面介绍的知识我会尽量不提前用,即使提前使用,也会同时做好标注,避免了阅读时各种查阅资料的烦恼.</p>
<p>系列博客将采用一个一个的样例，来说明书中的精华部分（当然，这只是我认为的），同时引导新手，快速入门ES6，并逐步将其投入到生产实践中。</p>
<p>同时,在阅读前也提醒您, 为了系统连贯性的学习ES6的基础知识,建议您从我的博客第一章开始阅读,当然,如果您对对应的知识已经有所了解,那么可以跳转到任意章节阅读,每一篇博客名中均有介绍该博客中涉及到的ES6的内容.</p>
<p>阮一峰老师的这本书是开源的，在其官方博客就可以下载到，但是我强烈建议大家去购买一本书, 一是方便自己查阅ES6中新增的众多API, 二也是表达一下对大神的敬仰.</p>
]]></content>
    
    <summary type="html">
    
      本系列为在我读完阮一峰老师的《ES6标准入门》第二版之后，所做的阅读笔记的整理。 系列博客将采用一个一个的样例，来说明书中的精华部分（当然，这只是我认为的），同时引导新手，快速入门ES6，并逐步将其投入到生产实践中。
    
    </summary>
    
      <category term="ES6标准入门" scheme="https://github.com/ChangerHe/categories/ES6%E6%A0%87%E5%87%86%E5%85%A5%E9%97%A8/"/>
    
    
      <category term="ES6" scheme="https://github.com/ChangerHe/tags/ES6/"/>
    
      <category term="Module" scheme="https://github.com/ChangerHe/tags/Module/"/>
    
  </entry>
  
  <entry>
    <title>《ES6标准入门》阅读笔记——-Class</title>
    <link href="https://github.com/ChangerHe/2017/07/16/%E3%80%8AES6%E6%A0%87%E5%87%86%E5%85%A5%E9%97%A8%E3%80%8B%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0%E2%80%94%E2%80%94-Class/"/>
    <id>https://github.com/ChangerHe/2017/07/16/《ES6标准入门》阅读笔记——-Class/</id>
    <published>2017-07-16T15:52:52.000Z</published>
    <updated>2017-09-18T00:42:14.635Z</updated>
    
    <content type="html"><![CDATA[<h1 id="写在前面"><a href="#写在前面" class="headerlink" title="写在前面"></a>写在前面</h1><p>本系列为在我读完阮一峰老师的《ES6标准入门》第二版之后，所做的阅读笔记的整理。</p>
<p>许多初学ES6, 同时和我一样初次阅读阮老师的这本书的时候, 读第一遍会越发的困惑, 因为阮老师上面说的很多的定义,方法,之前都是没有见过的, 读到后面才发现, 哦~原来是这样.</p>
<p>有一句话叫做”大神的世界我们不懂”, 所以我在初读第一遍《ES6标准入门》这本书的时候,也是踩了不少坑,读书的时候查阅了不少的资料.</p>
<p>所以,在这一系列的笔记教程中,我会从一个初学者的角度,向您讲述ES6的相关知识,在后面介绍的知识我会尽量不提前用,即使提前使用,也会同时做好标注,避免了阅读时各种查阅资料的烦恼.</p>
<p>系列博客将采用一个一个的样例，来说明书中的精华部分（当然，这只是我认为的），同时引导新手，快速入门ES6，并逐步将其投入到生产实践中。</p>
<p>同时,在阅读前也提醒您, 为了系统连贯性的学习ES6的基础知识,建议您从我的博客第一章开始阅读,当然,如果您对对应的知识已经有所了解,那么可以跳转到任意章节阅读,每一篇博客名中均有介绍该博客中涉及到的ES6的内容.</p>
<p>阮一峰老师的这本书是开源的，在其官方博客就可以下载到，但是我强烈建议大家去购买一本书, 一是方便自己查阅ES6中新增的众多API, 二也是表达一下对大神的敬仰.</p>
]]></content>
    
    <summary type="html">
    
      本系列为在我读完阮一峰老师的《ES6标准入门》第二版之后，所做的阅读笔记的整理。 系列博客将采用一个一个的样例，来说明书中的精华部分（当然，这只是我认为的），同时引导新手，快速入门ES6，并逐步将其投入到生产实践中。
    
    </summary>
    
      <category term="ES6标准入门" scheme="https://github.com/ChangerHe/categories/ES6%E6%A0%87%E5%87%86%E5%85%A5%E9%97%A8/"/>
    
    
      <category term="ES6" scheme="https://github.com/ChangerHe/tags/ES6/"/>
    
      <category term="Class" scheme="https://github.com/ChangerHe/tags/Class/"/>
    
  </entry>
  
  <entry>
    <title>记一次简单的Nodejs爬虫</title>
    <link href="https://github.com/ChangerHe/2017/07/13/%E8%AE%B0%E4%B8%80%E6%AC%A1%E7%AE%80%E5%8D%95%E7%9A%84Nodejs%E7%88%AC%E8%99%AB/"/>
    <id>https://github.com/ChangerHe/2017/07/13/记一次简单的Nodejs爬虫/</id>
    <published>2017-07-13T10:32:57.000Z</published>
    <updated>2017-09-27T09:13:27.086Z</updated>
    
    <content type="html"><![CDATA[<p>作为初学nodejs的小学森, 不玩一把爬虫真的都不好意思说自己学过nodejs</p>
<p>所以, 本次教程本着严谨的教学角度, 向大家传授一下严谨的老司机绝技</p>
<p>学完之后, 自己写点儿小程序, 爬一爬某些不可描述的小图片啊, 小电影啊什么的, 也是可以的</p>
<p>所以我要在这里再次重申一下啊, 这真的是一篇严谨的教学博客</p>
<p>一入*门深似海, 从此节操是路人</p>
<h1 id="准备工作"><a href="#准备工作" class="headerlink" title="准备工作"></a>准备工作</h1><p>看到这篇博客时, 默认您已经掌握了nodejs的基本知识以及模块化的相关理念, 以及npm包管理的简单使用方法(也就一个cmd命令, npm i),所以基本上是看一遍之后就可以非常简单的上手的.</p>
<p>本次的数据库是直接使用的mongoDB, 简单上手,值得拥有.</p>
<h2 id="mongoDB的配置"><a href="#mongoDB的配置" class="headerlink" title="mongoDB的配置"></a>mongoDB的配置</h2><p>这个下载就不用说了吧, 老司机都知道上度娘.</p>
<p>关键是配置这块, 安装好之后,我们在项目的文件夹下创建一个db文件夹, 当然,项目文件夹是要存储你待会儿写的代码用的,新建一个就好</p>
<p>下好之后, 可以启动cmd(win + r, 然后回车) 输入mongo</p>
<p>输完了吗? 是不是没有看到结果? </p>
<p>没有结果就对了,因为我没教你配置环境变量啊</p>
<h3 id="配置环境变量"><a href="#配置环境变量" class="headerlink" title="配置环境变量"></a>配置环境变量</h3><p>首先,进入安装目录的bin文件夹,比如我是直接在安装的时候全部点的下一步,所以我的安装目录在<code>C:\Program Files\MongoDB\Server\3.2\bin</code>, 找到这个地方之后,在地址栏, 将这个文件路径复制下来,粘贴到环境变量的对应地方</p>
<p>环境变量的位置在: 我的电脑右键&gt; 属性 &gt; 高级系统设置 &gt; 环境变量 &gt; 管理员的用户变量</p>
<p>注意不要动系统变量,不然一旦操作不慎是会造成系统宕机的. </p>
<p>我们在用户变量的PATH中,鼠标光标点到最后,在它后面插上一个小分号</p>
<p>哎, 怎么有了一种邪恶的感觉</p>
<p>咳咳~ 插进去之后, 将我们之前bin目录的文件路径复制上去,然后确定</p>
<p>现在我们要做一下简单的配置让mongoDB启动起来:</p>
<p><code>mongod  --storageEngine mmapv1 --dbpath &quot;d:\mongodb\db&quot; --logpath &quot;d:\mongodb\log\MongoDB.log</code></p>
<p>下面详细讲一下配置的参数:</p>
<blockquote>
<p><code>mongod</code> mongoDB的命令,这个不用说</p>
<p><code>--storageEngine mmapv1</code> 这是一个比较老的mongoDB的存储引擎, 32位系统的童鞋需要有这条命令, 64位系统的可以不用, </p>
<p><code>--dbpath &quot;d:\mongodb\db&quot;</code> 数据库路径,找到项目文件夹, 把自己的项目文件夹的db路径替换掉上面的路径</p>
<p><code>--logpath &quot;d:\mongodb\log\MongoDB.log</code> 日志路径,一般我们会放在和db一起, 也是一样的, 把自己的log文件夹的路径替换掉上面的路径,因为刚开始是没有MongoDB.log这个文件的,所以需要新建一个.</p>
</blockquote>
<p>执行成功之后,如果没有看到ERROR的提示, 那么恭喜你,mongo的服务已经成功启动了, 报错的可以再往上翻一下是不是有步骤遗漏, 因为我也是纯手工码字, 难免可能自己也有遗漏的地方, 确实不懂的地方也可以度娘或google</p>
<p>以上,mongo的配置就搞定了,mongo服务默认跑在27017端口, 如果不需要长期使用, 保持cmd挂起服务就正常运行的, 记住不能关掉哦</p>
<p>如果需要长期使用mongo服务的, 可以将mongo服务设置为系统服务,开机即启动, 可以在cmd中执行以下代码, 用于创建mongo服务进程</p>
<p><code>mongod  --storageEngine mmapv1 --dbpath &quot;d:\mongodb\db&quot; --logpath &quot;d:\mongodb\log\MongoDB.log&quot; --install --serviceName &quot;MongoDB&quot;</code></p>
<p>这个是mongo的指令,所以要在cmd状态下,不要在mongo的交互状态下执行这个命令,否则会报错的</p>
<p>完成以上指令, 就已经成功创建了系统服务了, 我们现在来启动它, 在cmd中输入:</p>
<p><code>NET START MongoDB</code></p>
<p>提示服务器启动成功, bongo~</p>
<h1 id="安装依赖"><a href="#安装依赖" class="headerlink" title="安装依赖"></a>安装依赖</h1><p>进入项目文件夹, 在cmd中输入<code>npm init</code> 创建一个json文件, 然后使用<code>npm i *</code> 一次安装express, cheerio, mongoose, superagent这几个依赖, 所以需要将指令中的<code>*</code>改为以上的依赖名称</p>
<p>万事俱备只欠东风了, 我们新建一个app.js文件, 并引入刚刚安装的依赖</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">var express = require(&apos;express&apos;)</div><div class="line">var cheerio = require(&apos;cheerio&apos;)</div><div class="line">var superagent = require(&apos;superagent&apos;)</div><div class="line">var mongoose = require(&apos;mongoose&apos;)</div></pre></td></tr></table></figure>
<p>下面来大概说明一下这几个模块的作用</p>
<blockquote>
<p>express: 一个极简快速灵活的web开发框架, 用来快速搭建web服务器的</p>
<p>cheerio: nodejs中的jQuery</p>
<p>superagent 用来做客户端请求代理的, 直接点儿说就是代我们上网站拉网页代码的</p>
<p>mongoose: 用来连接mongoDB和处理mongo的请求</p>
</blockquote>
<p>好了解完之后,我们要正式开始写代码了</p>
<p>首先一步,还是连接mongo数据库, 不然我们趴下来的数据就没地儿存了</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line">// 连接到mongoDB数据库,端口是27017, 我们将内容存储在cnodejs这个数据库中</div><div class="line">mongoose.connect(&apos;mongodb://localhost:27017/cnodejs&apos;,function(err) &#123;</div><div class="line">    if(err) &#123;</div><div class="line">        throw err</div><div class="line">    &#125; else &#123;</div><div class="line">        console.log(&apos;服务器连接成功...&apos;)</div><div class="line">    &#125;</div><div class="line">&#125;)</div><div class="line"></div><div class="line">// 实例化一个骨架,定义我们要传入的内容的键名及键值</div><div class="line">var schema = new mongoose.Schema(&#123;</div><div class="line">    title: String,</div><div class="line">    href: String</div><div class="line">&#125;)</div><div class="line"></div><div class="line">// 定义一个模型变量, 我们将模型名称定义为List, 将爬取的内容存储在list这个文档中</div><div class="line">var model = mongoose.model(&apos;List&apos;, schema, &apos;list&apos;)</div></pre></td></tr></table></figure>
<p>然后,我们再实例一个express, 方便我们进行操作</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">var app = express()</div></pre></td></tr></table></figure>
<p>使用代码来进行抓取</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div></pre></td><td class="code"><pre><div class="line">app.get(&apos;/&apos;, function(req, res, next)&#123;</div><div class="line">    // 使用superagent去抓取https://cnodejs.org的内容</div><div class="line">    superagent.get(&apos;https://cnodejs.org/&apos;).end(function(err, sres)&#123;</div><div class="line">        // 常规的错误处理</div><div class="line">        if(err) return next(err)</div><div class="line">		</div><div class="line">        // sres.text里面存储着网页的html内容, 将它传给cheerio.load之后</div><div class="line">		//就可以得到一个实现了jQuery接口的变量,我们习惯性将其命名为 &apos;$&apos;</div><div class="line">        var $ = cheerio.load(sres.text)</div><div class="line">		</div><div class="line">        var items = []</div><div class="line"></div><div class="line">        // 使用cheerio获取到爬取到的东西的内容</div><div class="line">        $(&apos;#topic_list .topic_title&apos;).each((idx, element)=&gt; &#123;</div><div class="line">		</div><div class="line">            // 预定义一个变量,从而提升整体的程序性能</div><div class="line">            var $element = $(element);</div><div class="line">			</div><div class="line">            var listModel = new model()</div><div class="line">			</div><div class="line">            listModel.title = $element.attr(&apos;title&apos;)</div><div class="line">			</div><div class="line">            listModel.href = $element.attr(&apos;href&apos;)</div><div class="line">			</div><div class="line">			// 将内容保存到数据库</div><div class="line">            listModel.save((err) =&gt; &#123;</div><div class="line">                if(err) &#123;</div><div class="line">                    throw err</div><div class="line">                &#125; else &#123;</div><div class="line">                    console.log(&apos;保存成功...&apos;)</div><div class="line">                &#125;</div><div class="line">            &#125;)</div><div class="line">        &#125;)</div><div class="line">    &#125;)</div><div class="line">&#125;)</div></pre></td></tr></table></figure>
<p>最后一步, 指定服务器的监听端口</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">app.listen(8090, function(err) &#123;</div><div class="line">	if(err) &#123;</div><div class="line">		throw err</div><div class="line">	&#125; else &#123;</div><div class="line">		console.log(&apos;服务器启动成功.. &apos;)	</div><div class="line">	&#125;</div><div class="line">&#125;)</div></pre></td></tr></table></figure>
<p>全部搞定,我们使用cmd输入命令 node app 或者使用webstorm的ctrl + f9启动一下</p>
<p>到浏览器中,输入刚刚设置的本地服务器加端口号: <code>localhost:8090</code> </p>
<p>回来一看,我靠,好多的保存成功啊</p>
<p>至此,我们的爬取工作就已经全部完成了, 看下成果呗:</p>
<h1 id="在mongoDB中查看自己的爬取结果"><a href="#在mongoDB中查看自己的爬取结果" class="headerlink" title="在mongoDB中查看自己的爬取结果"></a>在mongoDB中查看自己的爬取结果</h1><p>如果不想麻烦的话, 可以直接安装一个ROBO 3T, 傻瓜式操作</p>
<p>也可以自己输入指令查看</p>
<p>在cmd中输入mongo, 进入mongo的交互</p>
<p>输入指令: <code>use cnodejs</code> 转到我们的cnodejs这个数据库中</p>
<p>然后输入指令: ‘db.list.find().pretty()’ 爬取的结果就都出来了</p>
<h1 id="结束"><a href="#结束" class="headerlink" title="结束"></a>结束</h1><p>爬取的过程至此圆满结束</p>
<p>当然, 作为一个负责任的老司机, 怎么可能会不告诉你, 爬取出来的小电影小图片怎么看呢.</p>
<p>很简单, 使用ejs或者handlebars这类的模板引擎, 将数据库的内容渲染出来就好了</p>
]]></content>
    
    <summary type="html">
    
      作为初学nodejs的小学森, 不玩一把爬虫真的都不好意思说自己学过nodejs. 所以, 本次教程本着严谨的教学角度, 向大家传授一下严谨的老司机绝技
    
    </summary>
    
      <category term="Nodejs学习笔记" scheme="https://github.com/ChangerHe/categories/Nodejs%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="Nodejs" scheme="https://github.com/ChangerHe/tags/Nodejs/"/>
    
      <category term="爬虫" scheme="https://github.com/ChangerHe/tags/%E7%88%AC%E8%99%AB/"/>
    
  </entry>
  
  <entry>
    <title>《ES6标准入门》阅读笔记——-Promise</title>
    <link href="https://github.com/ChangerHe/2017/07/11/%E3%80%8AES6%E6%A0%87%E5%87%86%E5%85%A5%E9%97%A8%E3%80%8B%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0%E2%80%94%E2%80%94-Promise/"/>
    <id>https://github.com/ChangerHe/2017/07/11/《ES6标准入门》阅读笔记——-Promise/</id>
    <published>2017-07-11T14:23:54.000Z</published>
    <updated>2017-09-18T00:42:09.303Z</updated>
    
    <content type="html"><![CDATA[<h1 id="写在前面"><a href="#写在前面" class="headerlink" title="写在前面"></a>写在前面</h1><p>本系列为在我读完阮一峰老师的《ES6标准入门》第二版之后，所做的阅读笔记的整理。</p>
<p>许多初学ES6, 同时和我一样初次阅读阮老师的这本书的时候, 读第一遍会越发的困惑, 因为阮老师上面说的很多的定义,方法,之前都是没有见过的, 读到后面才发现, 哦~原来是这样.</p>
<p>有一句话叫做”大神的世界我们不懂”, 所以我在初读第一遍《ES6标准入门》这本书的时候,也是踩了不少坑,读书的时候查阅了不少的资料.</p>
<p>所以,在这一系列的笔记教程中,我会从一个初学者的角度,向您讲述ES6的相关知识,在后面介绍的知识我会尽量不提前用,即使提前使用,也会同时做好标注,避免了阅读时各种查阅资料的烦恼.</p>
<p>系列博客将采用一个一个的样例，来说明书中的精华部分（当然，这只是我认为的），同时引导新手，快速入门ES6，并逐步将其投入到生产实践中。</p>
<p>同时,在阅读前也提醒您, 为了系统连贯性的学习ES6的基础知识,建议您从我的博客第一章开始阅读,当然,如果您对对应的知识已经有所了解,那么可以跳转到任意章节阅读,每一篇博客名中均有介绍该博客中涉及到的ES6的内容.</p>
<p>阮一峰老师的这本书是开源的，在其官方博客就可以下载到，但是我强烈建议大家去购买一本书, 一是方便自己查阅ES6中新增的众多API, 二也是表达一下对大神的敬仰.</p>
]]></content>
    
    <summary type="html">
    
      本系列为在我读完阮一峰老师的《ES6标准入门》第二版之后，所做的阅读笔记的整理。 系列博客将采用一个一个的样例，来说明书中的精华部分（当然，这只是我认为的），同时引导新手，快速入门ES6，并逐步将其投入到生产实践中。
    
    </summary>
    
      <category term="ES6标准入门" scheme="https://github.com/ChangerHe/categories/ES6%E6%A0%87%E5%87%86%E5%85%A5%E9%97%A8/"/>
    
    
      <category term="ES6" scheme="https://github.com/ChangerHe/tags/ES6/"/>
    
      <category term="Promise" scheme="https://github.com/ChangerHe/tags/Promise/"/>
    
  </entry>
  
  <entry>
    <title>《ES6标准入门》阅读笔记——-Iterator和Generator</title>
    <link href="https://github.com/ChangerHe/2017/07/07/%E3%80%8AES6%E6%A0%87%E5%87%86%E5%85%A5%E9%97%A8%E3%80%8B%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0%E2%80%94%E2%80%94-Iterator%E5%92%8CGenerator/"/>
    <id>https://github.com/ChangerHe/2017/07/07/《ES6标准入门》阅读笔记——-Iterator和Generator/</id>
    <published>2017-07-07T15:11:34.000Z</published>
    <updated>2017-09-18T00:42:03.573Z</updated>
    
    <content type="html"><![CDATA[<h1 id="写在前面"><a href="#写在前面" class="headerlink" title="写在前面"></a>写在前面</h1><p>本系列为在我读完阮一峰老师的《ES6标准入门》第二版之后，所做的阅读笔记的整理。</p>
<p>许多初学ES6, 同时和我一样初次阅读阮老师的这本书的时候, 读第一遍会越发的困惑, 因为阮老师上面说的很多的定义,方法,之前都是没有见过的, 读到后面才发现, 哦~原来是这样.</p>
<p>有一句话叫做”大神的世界我们不懂”, 所以我在初读第一遍《ES6标准入门》这本书的时候,也是踩了不少坑,读书的时候查阅了不少的资料.</p>
<p>所以,在这一系列的笔记教程中,我会从一个初学者的角度,向您讲述ES6的相关知识,在后面介绍的知识我会尽量不提前用,即使提前使用,也会同时做好标注,避免了阅读时各种查阅资料的烦恼.</p>
<p>系列博客将采用一个一个的样例，来说明书中的精华部分（当然，这只是我认为的），同时引导新手，快速入门ES6，并逐步将其投入到生产实践中。</p>
<p>同时,在阅读前也提醒您, 为了系统连贯性的学习ES6的基础知识,建议您从我的博客第一章开始阅读,当然,如果您对对应的知识已经有所了解,那么可以跳转到任意章节阅读,每一篇博客名中均有介绍该博客中涉及到的ES6的内容.</p>
<p>阮一峰老师的这本书是开源的，在其官方博客就可以下载到，但是我强烈建议大家去购买一本书, 一是方便自己查阅ES6中新增的众多API, 二也是表达一下对大神的敬仰.</p>
]]></content>
    
    <summary type="html">
    
      本系列为在我读完阮一峰老师的《ES6标准入门》第二版之后，所做的阅读笔记的整理。 系列博客将采用一个一个的样例，来说明书中的精华部分（当然，这只是我认为的），同时引导新手，快速入门ES6，并逐步将其投入到生产实践中。
    
    </summary>
    
      <category term="ES6标准入门" scheme="https://github.com/ChangerHe/categories/ES6%E6%A0%87%E5%87%86%E5%85%A5%E9%97%A8/"/>
    
    
      <category term="ES6" scheme="https://github.com/ChangerHe/tags/ES6/"/>
    
      <category term="Iterator" scheme="https://github.com/ChangerHe/tags/Iterator/"/>
    
      <category term="Generator" scheme="https://github.com/ChangerHe/tags/Generator/"/>
    
  </entry>
  
  <entry>
    <title>《ES6标准入门》阅读笔记——-set和map</title>
    <link href="https://github.com/ChangerHe/2017/07/03/%E3%80%8AES6%E6%A0%87%E5%87%86%E5%85%A5%E9%97%A8%E3%80%8B%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0%E2%80%94%E2%80%94-set%E5%92%8Cmap/"/>
    <id>https://github.com/ChangerHe/2017/07/03/《ES6标准入门》阅读笔记——-set和map/</id>
    <published>2017-07-03T03:37:44.000Z</published>
    <updated>2017-10-09T09:51:25.926Z</updated>
    
    <content type="html"><![CDATA[<h1 id="写在前面"><a href="#写在前面" class="headerlink" title="写在前面"></a>写在前面</h1><p>本系列为在我读完阮一峰老师的《ES6标准入门》第二版之后，所做的阅读笔记的整理。</p>
<p>许多初学ES6, 同时和我一样初次阅读阮老师的这本书的时候, 读第一遍会越发的困惑, 因为阮老师上面说的很多的定义,方法,之前都是没有见过的, 读到后面才发现, 哦~原来是这样.</p>
<p>有一句话叫做”大神的世界我们不懂”, 所以我在初读第一遍《ES6标准入门》这本书的时候,也是踩了不少坑,读书的时候查阅了不少的资料.</p>
<p>所以,在这一系列的笔记教程中,我会从一个初学者的角度,向您讲述ES6的相关知识,在后面介绍的知识我会尽量不提前用,即使提前使用,也会同时做好标注,避免了阅读时各种查阅资料的烦恼.</p>
<p>系列博客将采用一个一个的样例，来说明书中的精华部分（当然，这只是我认为的），同时引导新手，快速入门ES6，并逐步将其投入到生产实践中。</p>
<p>同时,在阅读前也提醒您, 为了系统连贯性的学习ES6的基础知识,建议您从我的博客第一章开始阅读,当然,如果您对对应的知识已经有所了解,那么可以跳转到任意章节阅读,每一篇博客名中均有介绍该博客中涉及到的ES6的内容.</p>
<p>阮一峰老师的这本书是开源的，在其官方博客就可以下载到，但是我强烈建议大家去购买一本书, 一是方便自己查阅ES6中新增的众多API, 二也是表达一下对大神的敬仰.</p>
<h1 id="Set"><a href="#Set" class="headerlink" title="Set"></a>Set</h1><p>ES6提供了一种新的数据结构Set,类似于数组,但成员值是唯一的,没有重复值. set本身是一个构造函数,用来生成set数据结构</p>
<p>因此, 利用set这个结构的特性, 就可以很容易地进行数组去重了</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">let s = new Set();</div><div class="line">let a = [1, 2, 3, 4, 5, 5, 6, 2, 12, 53, 34, 5, 1, 2, 5, 3, 1, 1].map(x =&gt; s.add(x))</div><div class="line">console.log(...s)  // 1 2 3 4 5 6 12 53 34</div></pre></td></tr></table></figure>
<p>向set加入值的时候不会发生类型转换,所以 5 和 ‘5’ 是两个不同的值</p>
<p>在set内部判断两数是否相等使用的是精确相等运算符, 也就是说,当我们比较对象是否相等的时候,两个不同引用空间的对象是永远不相等的</p>
<p>有一个例外是,当我们使用NaN的时候,会发现两个NaN其实是相等的,而在ES5的时候NaN会被认为是一个Object从而判定两者不相等</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">let set = new Set([1, 2, 3, NaN, NaN])</div><div class="line">console.log(set.size)  // 4</div><div class="line">set.add(&#123;&#125;)</div><div class="line">set.add(&#123;&#125;)</div><div class="line">console.log(set.size)  // 6</div></pre></td></tr></table></figure>
<p>由上面的打印结果很明显的能看到, 两个NaN是相等的, 但是两个对象是不等的</p>
<p>set结构的实例是默认可遍历的</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">let set = new Set([&apos;red&apos;, &apos;green&apos;, &apos;blue&apos;])</div><div class="line">for (let x of set) &#123;</div><div class="line">	console.log(x) // red green blue</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>由于扩展运算符内部使用for…of循环,所以也可以用于set结构</p>
<h1 id="set的使用技巧"><a href="#set的使用技巧" class="headerlink" title="set的使用技巧"></a>set的使用技巧</h1><p>利用set可以很容易地实现并集 交集 差集的操作</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">let a = new Set([1, 2, 3])</div><div class="line">let b = new Set([2, 3, 4])</div><div class="line"></div><div class="line">// 求并集</div><div class="line">let union = new Set([...a, ...b])</div><div class="line">console.log(union)  // Set(4) &#123;1, 2, 3, 4&#125;</div><div class="line"></div><div class="line">// 求交集</div><div class="line">let intersect = new Set([...a].filter(x =&gt; b.has(x)))</div><div class="line">console.log(intersect) // Set(2) &#123;2, 3&#125;</div><div class="line"></div><div class="line">// 求差集</div><div class="line">let difference = new Set([...a].filter(x =&gt; !b.has(x)))</div><div class="line">console.log(difference) // Set(1) &#123;1&#125;</div></pre></td></tr></table></figure>
<h1 id="WeakSet"><a href="#WeakSet" class="headerlink" title="WeakSet"></a>WeakSet</h1><p>WeakSet的结构和Set类似,也是不重复的值的集合.但是,它与Set有两个区别</p>
<ul>
<li><ol>
<li>weakset成员只能是对象,不能是其他类型的值</li>
</ol>
</li>
<li><ol>
<li>weakset对象都是弱引用,即垃圾回收机制不考虑</li>
</ol>
</li>
</ul>
<p>weakset对该对象的引用,如果其他对象都不再引用该对象,那么该对象就会被GC回收.  </p>
<p>这一特点意味着无法引用weakset的成员,因此weakset是不可遍历的</p>
<h1 id="Map"><a href="#Map" class="headerlink" title="Map"></a>Map</h1><p>javascript的对象本质上是键值对的集合,但是只能用字符串作为键名</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">let data = &#123;&#125;</div><div class="line">let element = document.getElementById(&apos;myDiv&apos;)</div><div class="line"></div><div class="line">data[element] = metadata // 报错</div><div class="line"></div><div class="line">console.log(data[&apos;[Object HTMLElement]&apos;])</div></pre></td></tr></table></figure>
<p>ES6提供了Map数据结构,它类似于对象,也是键值对的集合,但是键的范围不限于字符串,各种类型的值都可以当做键名</p>
<p>因此,map是比object更加合适的键值对结构</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">let m = new Map()</div><div class="line">let o = &#123;</div><div class="line">	p: &apos;Hello world&apos;</div><div class="line">&#125;</div><div class="line">m.set(o, &apos;content&apos;)</div><div class="line">console.log(m.get(o))  // content</div><div class="line"></div><div class="line">console.log(m.has(o))  // true</div><div class="line">console.log(m.delete(o))  // true</div><div class="line">console.log(m.has(o))  // false</div></pre></td></tr></table></figure>
<p>另外有一点需要注意的是,map的键是和内存地址绑定的,只要内存地址不一样,那么就会被视为两个键, 这样就解决了同名属性的碰撞问题</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">let map = new Map()</div><div class="line"></div><div class="line">let k1 = [&apos;a&apos;]</div><div class="line">let k2 = [&apos;a&apos;]</div><div class="line"></div><div class="line">map.set(k1, 111)</div><div class="line">map.set(k2, 222)</div><div class="line"></div><div class="line">console.log(map.get(k1))  // 111</div><div class="line">console.log(map.get(k2))  // 222</div></pre></td></tr></table></figure>
<p>那么同样的,当我们使用简单数据类型时,只要两值完全相等,map就将其视为一个键</p>
<p>包括+0 和 -0 , 以及NaN</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">let map = new Map()</div><div class="line"></div><div class="line">map.set(NaN, 123)</div><div class="line">console.log(map.get(NaN)) // 123</div><div class="line"></div><div class="line">map.set(-0, 321)</div><div class="line">console.log(map.get(+0))  // 321</div></pre></td></tr></table></figure>
<p>map结构转为数组结构比较方便的方法就是使用三点运算符,或者说是扩展运算符,或者说是rest参数</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">let map = new Map([</div><div class="line">	[1, &apos;one&apos;],</div><div class="line">	[2, &apos;two&apos;],</div><div class="line">	[3, &apos;three&apos;]</div><div class="line">])</div><div class="line"></div><div class="line">console.log([...map.keys()])</div><div class="line">// 1  2  3</div><div class="line">console.log([...map.values()])</div><div class="line">// &quot;one&quot;  &quot;two&quot;  &quot;three&quot;</div><div class="line">console.log([...map.entries()])</div><div class="line">// [1, &quot;one&quot;]  [2, &quot;two&quot;]  [3, &quot;three&quot;]</div><div class="line">console.log([...map]) </div><div class="line">// [1, &quot;one&quot;]  [2, &quot;two&quot;]  [3, &quot;three&quot;]</div></pre></td></tr></table></figure>
<h1 id="WeakMap"><a href="#WeakMap" class="headerlink" title="WeakMap"></a>WeakMap</h1><p>Weakmap的结构和map结构基本类似,但是weakmap只接受对象作为键名,不接受其他类型的值作为键名</p>
<p>weakmap的应用典型场景就是在DOM节点作为键名的时候</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">let myElement = document.getElementById(&apos;logo&apos;)</div><div class="line">let myWeakmap = new WeakMap()</div><div class="line"></div><div class="line">myWeakmap.set(myElement, &#123;</div><div class="line">	timesClicked: 0</div><div class="line">&#125;)</div><div class="line"></div><div class="line">myElement.addEventListener(&apos;click&apos;, () =&gt; &#123;</div><div class="line">	let logoData = myWeakmap.get(myElement)</div><div class="line">	logoData.timesClicked++</div><div class="line">		myWeakmap.set(myElement, logoData)</div><div class="line">&#125;, false)</div></pre></td></tr></table></figure>
<p>(完)</p>
]]></content>
    
    <summary type="html">
    
      本系列为在我读完阮一峰老师的《ES6标准入门》第二版之后，所做的阅读笔记的整理。 系列博客将采用一个一个的样例，来说明书中的精华部分（当然，这只是我认为的），同时引导新手，快速入门ES6，并逐步将其投入到生产实践中。
    
    </summary>
    
      <category term="ES6标准入门" scheme="https://github.com/ChangerHe/categories/ES6%E6%A0%87%E5%87%86%E5%85%A5%E9%97%A8/"/>
    
    
      <category term="ES6" scheme="https://github.com/ChangerHe/tags/ES6/"/>
    
      <category term="set" scheme="https://github.com/ChangerHe/tags/set/"/>
    
      <category term="map" scheme="https://github.com/ChangerHe/tags/map/"/>
    
  </entry>
  
  <entry>
    <title>《ES6标准入门》阅读笔记——-symbol及proxy/reflect</title>
    <link href="https://github.com/ChangerHe/2017/07/01/%E3%80%8AES6%E6%A0%87%E5%87%86%E5%85%A5%E9%97%A8%E3%80%8B%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0%E2%80%94%E2%80%94-symbol%E5%8F%8Aproxy-reflect/"/>
    <id>https://github.com/ChangerHe/2017/07/01/《ES6标准入门》阅读笔记——-symbol及proxy-reflect/</id>
    <published>2017-07-01T05:51:28.000Z</published>
    <updated>2017-10-09T09:10:47.950Z</updated>
    
    <content type="html"><![CDATA[<h1 id="写在前面"><a href="#写在前面" class="headerlink" title="写在前面"></a>写在前面</h1><p>本系列为在我读完阮一峰老师的《ES6标准入门》第二版之后，所做的阅读笔记的整理。</p>
<p>许多初学ES6, 同时和我一样初次阅读阮老师的这本书的时候, 读第一遍会越发的困惑, 因为阮老师上面说的很多的定义,方法,之前都是没有见过的, 读到后面才发现, 哦~原来是这样.</p>
<p>有一句话叫做”大神的世界我们不懂”, 所以我在初读第一遍《ES6标准入门》这本书的时候,也是踩了不少坑,读书的时候查阅了不少的资料.</p>
<p>所以,在这一系列的笔记教程中,我会从一个初学者的角度,向您讲述ES6的相关知识,在后面介绍的知识我会尽量不提前用,即使提前使用,也会同时做好标注,避免了阅读时各种查阅资料的烦恼.</p>
<p>系列博客将采用一个一个的样例，来说明书中的精华部分（当然，这只是我认为的），同时引导新手，快速入门ES6，并逐步将其投入到生产实践中。</p>
<p>同时,在阅读前也提醒您, 为了系统连贯性的学习ES6的基础知识,建议您从我的博客第一章开始阅读,当然,如果您对对应的知识已经有所了解,那么可以跳转到任意章节阅读,每一篇博客名中均有介绍该博客中涉及到的ES6的内容.</p>
<p>阮一峰老师的这本书是开源的，在其官方博客就可以下载到，但是我强烈建议大家去购买一本书, 一是方便自己查阅ES6中新增的众多API, 二也是表达一下对大神的敬仰.</p>
<h1 id="Symbol"><a href="#Symbol" class="headerlink" title="Symbol"></a>Symbol</h1><p>在ES6之前,当我们命名变量的时候,总是会担心,如果我把之前的变量改写了该怎么办呢</p>
<p>那么,现在ES6推出了继 null undefined string number boolean 这五中数据类型以外的第六种简单数据类型symbol</p>
<p>推出的主要目的在于,解决属性名冲突的问题</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">let s = Symbol()</div><div class="line">console.log(typeof s) // symbol</div></pre></td></tr></table></figure>
<p>symbol一般会传入一个字符串作为不同symbol实例的描述,方便进行区分</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">let a = Symbol(&apos;a&apos;)</div><div class="line">let b = Symbol(&apos;b&apos;)</div><div class="line">console.log(a, b)  // Symbol(a) Symbol(b)</div><div class="line">console.log(a.toString(), b.toString()) // Symbol(a) Symbol(b)</div></pre></td></tr></table></figure>
<p>我们查看控制台的打印结果,会发现symbol的值是以红色显示的,而普通字符串则以灰色显示</p>
<h2 id="symbol的几个特征"><a href="#symbol的几个特征" class="headerlink" title="symbol的几个特征"></a>symbol的几个特征</h2><blockquote>
<p>symbol函数的参数只表示对当前symbol值的表示,因此相同参数的symbol函数的返回值是不相等的</p>
<p>symbol无法与其他类型值进行运算,否则会报错</p>
<p>symbol可以转为布尔值,但是无法转为数值</p>
<p>symbol作为变量时,不能使用点运算符</p>
</blockquote>
<p>因为symbol是一个特殊的基本类型,因此使用点运算符是不行的,这样会被理解为是在使用字符串作为变量名称</p>
<p>那么这个时候,可以使用方括号加上symbol名称的方式,来调取这个symbol值</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">var mySymbol = Symbol(&apos;aaa&apos;)</div><div class="line">var a = &#123;&#125;</div><div class="line">a.mySymbol = &apos;hello&apos;</div><div class="line">console.log(a[mySymbol]) // undefined</div><div class="line">console.log(a.mySymbol) // hello</div><div class="line">console.log(a[&apos;mySymbol&apos;]) // hello</div><div class="line"></div><div class="line">let c = Symbol</div><div class="line">let d = c</div><div class="line">console.log(d, d === c) // ƒ Symbol() &#123; [native code] &#125; true</div></pre></td></tr></table></figure>
<h2 id="作为属性名的symbol"><a href="#作为属性名的symbol" class="headerlink" title="作为属性名的symbol"></a>作为属性名的symbol</h2><p>symbol作为属性名,该属性不会出现在for…in for…of 循环中,也不会被Object.keys()/Object.getOwnPropertyNames()返回</p>
<p>但它也不是私有属性,有一个Object.getOwnPropertSymbols方法可以获取指定对象的所有symbol属性名</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">var obj = &#123;&#125;</div><div class="line">var a = Symbol(&apos;a&apos;)</div><div class="line">var b = Symbol.for(&apos;b&apos;)</div><div class="line"></div><div class="line">obj[a] = &apos;hello&apos;</div><div class="line">obj[b] = &apos;world&apos;</div><div class="line"></div><div class="line">var objectSymbols = Object.getOwnPropertySymbols(obj)</div><div class="line">console.log(objectSymbols) // [Symbol(a), Symbol(b)]</div><div class="line"></div><div class="line">var symbolNames = Object.getOwnPropertyNames(obj)</div><div class="line">console.log(symbolNames) // []</div></pre></td></tr></table></figure>
<p>由以上可知,使用getOwnPropertySymbols() 方法可以得到对应的symbol值,而getOwnPropertyNames() 是得不到对应的symbol值的</p>
<h2 id="Reflect-ownKeys-obj"><a href="#Reflect-ownKeys-obj" class="headerlink" title="Reflect.ownKeys(obj)"></a>Reflect.ownKeys(obj)</h2><p>ES6中定义了一个新的API Reflect.ownKeys(obj) 可以返回所有类型的键名称,包括常规键名和symbol键名</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">let obj = &#123;</div><div class="line">	[Symbol(&apos;my_key&apos;)]: 1,</div><div class="line">	enum: 2,</div><div class="line">	nonEnum: 3</div><div class="line">&#125;</div><div class="line"></div><div class="line">console.log(Object.keys(obj)) // [&quot;enum&quot;, &quot;nonEnum&quot;]</div><div class="line"></div><div class="line">console.log(Reflect.ownKeys(obj)) </div><div class="line">//[&quot;enum&quot;, &quot;nonEnum&quot;, Symbol(my_key)]</div></pre></td></tr></table></figure>
<h2 id="Symbol-for-和-Symbol-keyFor"><a href="#Symbol-for-和-Symbol-keyFor" class="headerlink" title="Symbol.for() 和 Symbol.keyFor()"></a>Symbol.for() 和 Symbol.keyFor()</h2><p>有时候我们希望重新使用同一个symbol值, Symbol.for方法可以做到这一点,它接收一个字符串作为参数,然后搜索没有以该字符串作为名称的Symbol值. 如果有,就返回这个Symbol值, 否则就新建一个以该字符串为名称的Symbol值</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">let s1 = Symbol.for(&apos;foo&apos;)</div><div class="line">let s2 = Symbol.for(&apos;foo&apos;)</div><div class="line"></div><div class="line">console.log(s1 === s2) // true</div></pre></td></tr></table></figure>
<p>上面的代码中,虽然s1和s2都是Symbol值,但是它们都是同一个Symbol.for生成的,所以是同一个值</p>
<p>Symbol()和Symbol.for()两种写法,都会生成新的Symbol,但是后者会被登记在全局环境中供 搜索,但是前者不会</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">console.log(Symbol.for(&apos;bar&apos;) === Symbol.for(&apos;bar&apos;)) // true</div><div class="line">console.log(Symbol(&apos;bar&apos;) === Symbol(&apos;bar&apos;)) // false</div></pre></td></tr></table></figure>
<p>上面的代码中,由于Symbol()没有登记机制,所以每次调用都会返回不同的值</p>
<p>Symbol.keyFor()方法用于返回一个已经登记的Symbol类型值的key</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">let s3 = Symbol.for(&apos;aaa&apos;)</div><div class="line">let s4 = Symbol(&apos;bbb&apos;)</div><div class="line"></div><div class="line">console.log(Symbol.keyFor(s3)) // aaa</div><div class="line">console.log(Symbol.keyFor(s4)) // undefined</div></pre></td></tr></table></figure>
<h1 id="Proxy概述"><a href="#Proxy概述" class="headerlink" title="Proxy概述"></a>Proxy概述</h1><p>proxy 用于修改某些操作的默认行为,等同于在语言层面做出修改,所以属于一种元编程, 即对编程语言进行编程</p>
<p>Proxy 可以理解为在目标对象前架设一个拦截层,外界对该对象的访问都必须先通过这一层拦截,因此提供了一钟机制来对外界的访问进行过滤和改写</p>
<p>所以,Proxy 也可以理解为一种代理器</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">let obj = new Proxy(&#123;&#125;, &#123;</div><div class="line">	get: function(target, key, receiver) &#123;</div><div class="line">		console.log(`getting $&#123;key&#125;`)</div><div class="line">		return Reflect.get(target, key, receiver)</div><div class="line">	&#125;,</div><div class="line">	set: function(target, key, value, receiver) &#123;</div><div class="line">		console.log(`setting $&#123;key&#125;`)</div><div class="line">		return Reflect.set(target, key, value, receiver)</div><div class="line">	&#125;</div><div class="line">&#125;)</div><div class="line"></div><div class="line">obj.count = 1  // setting count   </div><div class="line">obj.count++  // getting count   setting count</div></pre></td></tr></table></figure>
<p>上面的代码说明, proxy实际上重载了点运算符, 即用自己的定义覆盖了语言的原始定义</p>
<p>一个小技巧是,可以将Proxy对象设置到object.proxy属性,从而可以在object对象上调用</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">var object = &#123;</div><div class="line">    proxy: new Proxy(target, handler)</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>那么我们就可以直接定义一个proxy对象,并在需要的时候使用Object.create() 进行对象的创建即可</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">var proxy = new Proxy(&#123;&#125;, &#123;</div><div class="line">	get: function(target, property) &#123;</div><div class="line">		return 35</div><div class="line">	&#125;</div><div class="line">&#125;)</div><div class="line"></div><div class="line">let obj = Object.create(proxy)</div><div class="line"></div><div class="line">console.log(obj.time)</div></pre></td></tr></table></figure>
<h1 id="Reflect"><a href="#Reflect" class="headerlink" title="Reflect"></a>Reflect</h1><p>Reflect对象和Proxy对象一样, 也是ES6为了操作对象而提供的新api</p>
<p>reflect对象的设计目的主要有以下几个</p>
<blockquote>
<p>将object对象的一些明显属于语言层面的方法放到reflect对象上. 现阶段, 某些方法同时在object和reflect对象上部署, 未来的新方法将只部署在reflect对象上</p>
<p>修改某些object方法的返回结果, 让其变得更加合理, 如:<code>Object.defineProperty(obj, name, desc)</code> 在无法定义属性时会抛出一个错误, 而<code>Reflect.defineProperty(obj, name, desc)</code>则会返回一个false</p>
<p>让Object操作都变成函数行为, 某些object操作是命令式, 比如<code>name in obj</code>和<code>delete obj[name]</code>, 而<code>Reflect.has(obj, name)</code>和Reflect.deleteProperty(obj, name)让他们变成了函数行为</p>
<p>Reflect对象的方法和Proxy对象的方法一一对应, 只要是Proxy对象的方法, 就能在Reflect对象上找到相应的方法. 也就是说, 不管Proxy怎么修改默认行为, 你总可以在Reflect上获取默认行为</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">Proxy(target, &#123;</div><div class="line">	set: function(target, name, value, receiver) &#123;</div><div class="line">		var success = Reflect.set(target, name, value, receiver)</div><div class="line">		if(success) &#123;</div><div class="line">			log(&apos;property &apos; + name + &apos; on &apos; + target + &apos; set to &apos; + value)</div><div class="line">		&#125;</div><div class="line">		return success </div><div class="line">	&#125;</div><div class="line">&#125;)</div></pre></td></tr></table></figure>
<p>上面的代码中,proxy方法拦截了target对象的属性赋值行为, 它采用<code>Reflect.set</code>方法赋值给对象的属性, 然后再部署额外的功能. </p>
<p>(完)</p>
]]></content>
    
    <summary type="html">
    
      本系列为在我读完阮一峰老师的《ES6标准入门》第二版之后，所做的阅读笔记的整理。 系列博客将采用一个一个的样例，来说明书中的精华部分（当然，这只是我认为的），同时引导新手，快速入门ES6，并逐步将其投入到生产实践中。
    
    </summary>
    
      <category term="ES6标准入门" scheme="https://github.com/ChangerHe/categories/ES6%E6%A0%87%E5%87%86%E5%85%A5%E9%97%A8/"/>
    
    
      <category term="ES6" scheme="https://github.com/ChangerHe/tags/ES6/"/>
    
      <category term="symbol" scheme="https://github.com/ChangerHe/tags/symbol/"/>
    
      <category term="proxy" scheme="https://github.com/ChangerHe/tags/proxy/"/>
    
      <category term="reflect" scheme="https://github.com/ChangerHe/tags/reflect/"/>
    
  </entry>
  
  <entry>
    <title>Margin和Padding值设置成百分数的布局</title>
    <link href="https://github.com/ChangerHe/2017/06/30/Margin%E5%92%8CPadding%E5%80%BC%E8%AE%BE%E7%BD%AE%E6%88%90%E7%99%BE%E5%88%86%E6%95%B0%E7%9A%84%E5%B8%83%E5%B1%80/"/>
    <id>https://github.com/ChangerHe/2017/06/30/Margin和Padding值设置成百分数的布局/</id>
    <published>2017-06-30T11:36:43.000Z</published>
    <updated>2017-10-25T03:51:41.577Z</updated>
    
    <content type="html"><![CDATA[<p>Margin和Padding是我们在网页设计经常使用到的CSS样式，他们分别是间距和填充，一个作用于盒子外面，一个作用于盒子里面，默认的情况下，这些属性的值都会被计算在盒子的面积里面，在网页开发中的流体布局或者是响应式布局中，经常将Margin和Padding设置成百分数，那么到底这个百分数是多少，他是如何计算的呢？</p>
<h1 id="Margin"><a href="#Margin" class="headerlink" title="Margin"></a>Margin</h1><p>假设我们有这样的一段HTML代码，外面一个DIV宽度980px，高度500px，里面有一个子元素DIV，宽度和高度都不设置，然后给他设置margin:10% 5%，这个属性相当于margin:10% 5% 10% 5%。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">&lt;div class=&quot;demo1&quot;&gt;</div><div class="line">    &lt;div&gt;这个div设置：margin:10% 5%&lt;/div&gt;</div><div class="line">&lt;/div&gt;</div></pre></td></tr></table></figure>
<h1 id="CSS代码"><a href="#CSS代码" class="headerlink" title="CSS代码"></a>CSS代码</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">.demo1&#123; height:500px; width:980px; margin:0 auto; background:#EEE; overflow:hidden;&#125;</div><div class="line">.demo1 div&#123;margin:10% 5%; background:#666;&#125;</div></pre></td></tr></table></figure>
<p>为了方便查看效果，我们还分别为他们设置了不同的背景。</p>
<p>这里还出现了一个小的hack，就是demo1盒子不会紧挨着body，也就是不会定格布局，而且body元素上面还有一段空白，这段空白的高度刚好是.demo1 div元素的margin-top，demo1和.demo1 div元素都是顶格对其的，只要给demo1元素设置overflow:hidden，即可解决这个问题，点击这里查看示例。</p>
<p>我们根据以往的理解，<code>.demo1 div</code>的<code>margin</code>应该是：<code>50px 49px 50px 49px</code>，但是运行以后，通过查看盒模型示意图，却发现是：<code>98px 49px 98px 49px</code>，这是怎么回事呢</p>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>从上面的示例和代码，我们可以发现当margin设置成百分数的时候，其top right bottom left的值是参照父元素盒子的宽度进行计算，在w3c的规范中也是这样描述的：</p>
<blockquote>
<p>margin 的百分比值参照其包含块的宽度进行计算，同样的padding如果设置成百分数的话，其盒子模型和margin是一样的。</p>
<p>这只发生在默认的<code>writing-mode: horizontal-tb;</code>和<code>direction: ltr;</code>的情况下，当书写模式变成纵向的时候，其参照将会变成包含块的高度。</p>
</blockquote>
<p>为什么要选择宽度做参照而不是高度呢？</p>
<p>这其实更多的要从CSS设计意图上去想，因为CSS的基础需求是排版，而通常我们所见的横排文字，其水平宽度一定（仔细回想一下，如果没有显式的定义宽度 或者强制一行显示，都会遇到边界换行，而不是水平延展），垂直方向可以无限延展。但当书写模式为纵向时，其参照就变成了高度而不再是宽度了。</p>
]]></content>
    
    <summary type="html">
    
      Margin和Padding是我们在网页设计经常使用到的CSS样式，他们分别是间距和填充，一个作用于盒子外面，一个作用于盒子里面，默认的情况下，这些属性的值都会被计算在盒子的面积里面，在网页开发中的流体布局或者是响应式布局中，经常将Margin和Padding设置成百分数，那么到底这个百分数是多少，他是如何计算的呢？
    
    </summary>
    
      <category term="CSS" scheme="https://github.com/ChangerHe/categories/CSS/"/>
    
    
      <category term="CSS" scheme="https://github.com/ChangerHe/tags/CSS/"/>
    
  </entry>
  
  <entry>
    <title>《ES6标准入门》阅读笔记——-对象的扩展</title>
    <link href="https://github.com/ChangerHe/2017/06/30/%E3%80%8AES6%E6%A0%87%E5%87%86%E5%85%A5%E9%97%A8%E3%80%8B%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0%E2%80%94%E2%80%94-%E5%AF%B9%E8%B1%A1%E7%9A%84%E6%89%A9%E5%B1%95/"/>
    <id>https://github.com/ChangerHe/2017/06/30/《ES6标准入门》阅读笔记——-对象的扩展/</id>
    <published>2017-06-30T05:49:33.000Z</published>
    <updated>2017-09-23T13:50:55.999Z</updated>
    
    <content type="html"><![CDATA[<h1 id="写在前面"><a href="#写在前面" class="headerlink" title="写在前面"></a>写在前面</h1><p>本系列为在我读完阮一峰老师的《ES6标准入门》第二版之后，所做的阅读笔记的整理。</p>
<p>许多初学ES6, 同时和我一样初次阅读阮老师的这本书的时候, 读第一遍会越发的困惑, 因为阮老师上面说的很多的定义,方法,之前都是没有见过的, 读到后面才发现, 哦~原来是这样.</p>
<p>有一句话叫做”大神的世界我们不懂”, 所以我在初读第一遍《ES6标准入门》这本书的时候,也是踩了不少坑,读书的时候查阅了不少的资料.</p>
<p>所以,在这一系列的笔记教程中,我会从一个初学者的角度,向您讲述ES6的相关知识,在后面介绍的知识我会尽量不提前用,即使提前使用,也会同时做好标注,避免了阅读时各种查阅资料的烦恼.</p>
<p>系列博客将采用一个一个的样例，来说明书中的精华部分（当然，这只是我认为的），同时引导新手，快速入门ES6，并逐步将其投入到生产实践中。</p>
<p>同时,在阅读前也提醒您, 为了系统连贯性的学习ES6的基础知识,建议您从我的博客第一章开始阅读,当然,如果您对对应的知识已经有所了解,那么可以跳转到任意章节阅读,每一篇博客名中均有介绍该博客中涉及到的ES6的内容.</p>
<p>阮一峰老师的这本书是开源的，在其官方博客就可以下载到，但是我强烈建议大家去购买一本书, 一是方便自己查阅ES6中新增的众多API, 二也是表达一下对大神的敬仰.</p>
<h1 id="属性的简洁表示法"><a href="#属性的简洁表示法" class="headerlink" title="属性的简洁表示法"></a>属性的简洁表示法</h1><p>ES6允许写入变量和函数作为对象的属性和方法, 也就是说,在ES6中是允许在对象中只写属性名,不写属性值的</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">var foo = &apos;bar&apos;</div><div class="line">var baz = &#123;foo&#125;</div><div class="line">console.log(baz) // &#123;foo: &quot;bar&quot;&#125;</div><div class="line"></div><div class="line">function f(x, y) &#123;</div><div class="line">	return &#123;x,y&#125;</div><div class="line">&#125;</div><div class="line">console.log(f(1, 2)) // &#123;x: 1, y: 2&#125;</div></pre></td></tr></table></figure>
<p>除了属性简写,方法也是可以简写的</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">var o = &#123;</div><div class="line">	method() &#123;</div><div class="line">		return &apos;Hello!&apos;</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>等价于</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">var o = &#123;</div><div class="line">	method: function() &#123;</div><div class="line">		return &apos;Hello&apos;</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>CommonJS的模块输出变量就非常适合使用简洁写法</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">var ms = &#123;&#125;</div><div class="line"></div><div class="line">function getItem(key) &#123;</div><div class="line">	return key in ms ? ms[key] : null</div><div class="line">&#125;</div><div class="line"></div><div class="line">function setItem(key, value) &#123;</div><div class="line">	ms[key] = value</div><div class="line">&#125;</div><div class="line"></div><div class="line">function clear() &#123;</div><div class="line">	ms = &#123;&#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">module.exports = &#123;getItem, setItem, clear&#125;</div></pre></td></tr></table></figure>
<p>上面代码的最后一句就等价于</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">module.exports = &#123;</div><div class="line">	getItem: getItem, </div><div class="line">	setItem: setItem,</div><div class="line">	clear: clear</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h1 id="属性名表达式"><a href="#属性名表达式" class="headerlink" title="属性名表达式"></a>属性名表达式</h1><p>ES6同时开放了使用表达式放在方括号内,作为字面量的方式定义对象</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">var obj = &#123;</div><div class="line">    [propkey]: true,</div><div class="line">    [&apos;a&apos; + &apos;bc&apos;]: 123</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h1 id="方法的name属性"><a href="#方法的name属性" class="headerlink" title="方法的name属性"></a>方法的name属性</h1><p>函数的name属性返回函数名,对象方法也是函数,因此也存在name属性</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">console.log((new Function()).name) //anonymous</div></pre></td></tr></table></figure>
<p>关于方法的name属性,存在以下几个特点</p>
<blockquote>
<p>正常的情况下,函数的函数体的name值返回函数的名称</p>
<p>当我们使用get或者set方法对函数进行描述的时候,会返回对应的前缀加上函数名</p>
<p>当我们使用bind方法创造的函数,函数会有一个bound来修饰</p>
<p>当使用构造函数来创造的函数中,name值固定为anonymous</p>
<p>如果对象的方法是一个symbol值, 那么那么属性返回的是这个symbol值的描述</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">const key1 = Symbol(&apos;description&apos;)</div><div class="line">const key2 = Symbol()</div><div class="line">let obj = &#123;</div><div class="line">	[key1]() &#123;&#125;,</div><div class="line">	[key2]() &#123;&#125;</div><div class="line">&#125;</div><div class="line">console.log(obj[key1].name) // &apos;[description]&apos;</div><div class="line">console.log(obj[key2].name) // &apos;&apos;</div></pre></td></tr></table></figure>
<h1 id="Object-is"><a href="#Object-is" class="headerlink" title="Object.is()"></a>Object.is()</h1><p>Object.is() 是ES6新定义的方法,用于确定传入的两个参数是否严格相等</p>
<p>但是, 与全等 === 符号唯一不同的地方是 +0不等于-0  NaN等于自身NaN</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">console.log(-0 === +0)  // true</div><div class="line">console.log(NaN === NaN) // false</div><div class="line"></div><div class="line">console.log(Object.is(-0, +0)) // false</div><div class="line">console.log(Object.is(NaN, NaN))  // true</div></pre></td></tr></table></figure>
<p>在ES5中可以部署对应的方法, 来模拟Object.is的效果</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">Object.defineProperty(Object, &apos;is&apos;, &#123;</div><div class="line">	value: function(x, y) &#123;</div><div class="line">		if (x === y) &#123;</div><div class="line">			return x !== 0 || 1 / x === 1 / y</div><div class="line">		&#125;</div><div class="line">		return x !== x &amp;&amp; y !== y</div><div class="line">	&#125;,</div><div class="line">	configurable: true,</div><div class="line">	enumerable: false,</div><div class="line">	writable: true</div><div class="line">&#125;)</div></pre></td></tr></table></figure>
<h1 id="Object-assign"><a href="#Object-assign" class="headerlink" title="Object.assign()"></a>Object.assign()</h1><p>Object.assign() 方法将源对象的所有可枚举属性复制到目标对象</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">let target = &#123;a: 1&#125;</div><div class="line">let source1 = &#123;b: 2&#125;</div><div class="line">let source2 = &#123;c: 3&#125;</div><div class="line"></div><div class="line">Object.assign(target, source1, source2)</div><div class="line">console.log(target) // &#123;a: 1, b: 2, c: 3&#125;</div></pre></td></tr></table></figure>
<p>同样的,Object.assign 方法可以用来复制数组,但是因为会将数组视为一个对象,所以后面数组的对应数组下标的值会覆盖之前的数组的下标的值</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">var a = [1, 2, 3]</div><div class="line">var b = [4, 5]</div><div class="line">Object.assign(a, b)</div><div class="line">console.log(a) // [4,5,3]</div></pre></td></tr></table></figure>
<p>使用Object.assign可以将原始对象赋值到一个空对象, 就得到了原始对象的克隆</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">function clone(origin) &#123;</div><div class="line">	return Object.assign(&#123;&#125;, origin)</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>通过将对象赋值到一个空对象的方式,获得了这个origin对象的克隆</p>
<p>不过,采用这种方法克隆,只能克隆原始对象自身的值,而不能克隆它继承的值</p>
<p>那么,如果想要获得保持原型链的对象,那么就需要使用这样的方法</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">function clone(origin) &#123;</div><div class="line">	let originProto = Object.getPrototypeOf(origin)</div><div class="line">	return Object.assign(Object.create(originProto), origin)</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>实现方式就是这样的,使用getPropertyOf方法获取了origin的原型,然后将函数体合并到原型中,并返回</p>
<p>当使用Object.assign() 对两个对象进行合并的时候,不论前面对应对象名称的内容是什么,其内容都会被替换掉</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">var target = &#123;</div><div class="line">	a: &#123;b: &apos;c&apos;,d: &apos;e&apos;&#125;</div><div class="line">&#125;</div><div class="line">var source = &#123;</div><div class="line">	a: &#123;b: &apos;hello&apos;&#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">Object.assign(target, source)</div><div class="line">console.log(target) // a:&#123;b: &quot;hello&quot;&#125;</div></pre></td></tr></table></figure>
<h1 id="属性的可枚举性"><a href="#属性的可枚举性" class="headerlink" title="属性的可枚举性"></a>属性的可枚举性</h1><p>ES6规定,所有class的原型的方法都是不可枚举的</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">var a = Object.getOwnPropertyDescriptor(</div><div class="line">	class &#123;</div><div class="line">		foo() &#123;&#125;</div><div class="line">	&#125;.prototype, &apos;foo&apos;</div><div class="line">).enumerable</div><div class="line">console.log(a) // false</div></pre></td></tr></table></figure>
<h1 id="proto属性"><a href="#proto属性" class="headerlink" title="proto属性"></a><strong>proto</strong>属性</h1><p><strong>proto</strong>属性用来读取或设置当前对象的prototype对象, 这个属性其实在很早版本的chrome Firefox Opera等现代浏览器中都已经得到了支持,被广泛用于查找原型上的方法和属性.</p>
<p>但是IE迟迟得不到支持,在ES6中,此属性被写到了规范中</p>
<p>让人欣喜的是,IE11开始,也支持此属性了</p>
<p>对应的, ES6也同时推出了Object.setPrototypeOf()方法, 该方法的作用与<strong>proto</strong>是相同的,只不过<strong>proto</strong>是一个内部方法, 因此TC39推荐使用Object.setPrototypeOf()来设置原型对象的方法.</p>
<h1 id="对象的扩展运算符"><a href="#对象的扩展运算符" class="headerlink" title="对象的扩展运算符"></a>对象的扩展运算符</h1><p>ES7有个提案, 将rest参数,也就是扩展运算符引入对象,目前babel已经支持</p>
<p>rest参数(扩展运算符) 用于从一个对象取值,相当于将所有可遍历但尚未被读取的键但尚未读取的属性,分配到指定的对象上,所有的键及相应的值都会被赋值到新对象上</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">let &#123;x, y, ...z&#125; = &#123;</div><div class="line">	x: 1,</div><div class="line">	a: 3,</div><div class="line">	y: 2,</div><div class="line">	b: 4,</div><div class="line">&#125;</div><div class="line">console.log(x) // 1</div><div class="line">console.log(y) // 2</div><div class="line">console.log(z) // &#123;a: 3, b: 4&#125;</div></pre></td></tr></table></figure>
<p>目前在Chrome中测试, 尚未支持上面的方法</p>
<p>有一点要注意的是,rest参数的复制是浅复制</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">let obj = &#123;a: &#123;b: 1&#125;&#125;</div><div class="line">let &#123;...x&#125; = obj</div><div class="line">obj.a.b = 2</div><div class="line">console.log(x.a.b) // 2</div></pre></td></tr></table></figure>
]]></content>
    
    <summary type="html">
    
      本系列为在我读完阮一峰老师的《ES6标准入门》第二版之后，所做的阅读笔记的整理。 系列博客将采用一个一个的样例，来说明书中的精华部分（当然，这只是我认为的），同时引导新手，快速入门ES6，并逐步将其投入到生产实践中。
    
    </summary>
    
      <category term="ES6标准入门" scheme="https://github.com/ChangerHe/categories/ES6%E6%A0%87%E5%87%86%E5%85%A5%E9%97%A8/"/>
    
    
      <category term="ES6" scheme="https://github.com/ChangerHe/tags/ES6/"/>
    
      <category term="Object" scheme="https://github.com/ChangerHe/tags/Object/"/>
    
  </entry>
  
  <entry>
    <title>《ES6标准入门》阅读笔记——-函数的扩展</title>
    <link href="https://github.com/ChangerHe/2017/06/28/%E3%80%8AES6%E6%A0%87%E5%87%86%E5%85%A5%E9%97%A8%E3%80%8B%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0%E2%80%94%E2%80%94-%E5%87%BD%E6%95%B0%E7%9A%84%E6%89%A9%E5%B1%95/"/>
    <id>https://github.com/ChangerHe/2017/06/28/《ES6标准入门》阅读笔记——-函数的扩展/</id>
    <published>2017-06-28T13:36:55.000Z</published>
    <updated>2017-09-23T13:13:22.892Z</updated>
    
    <content type="html"><![CDATA[<h1 id="写在前面"><a href="#写在前面" class="headerlink" title="写在前面"></a>写在前面</h1><p>本系列为在我读完阮一峰老师的《ES6标准入门》第二版之后，所做的阅读笔记的整理。</p>
<p>许多初学ES6, 同时和我一样初次阅读阮老师的这本书的时候, 读第一遍会越发的困惑, 因为阮老师上面说的很多的定义,方法,之前都是没有见过的, 读到后面才发现, 哦~原来是这样.</p>
<p>有一句话叫做”大神的世界我们不懂”, 所以我在初读第一遍《ES6标准入门》这本书的时候,也是踩了不少坑,读书的时候查阅了不少的资料.</p>
<p>所以,在这一系列的笔记教程中,我会从一个初学者的角度,向您讲述ES6的相关知识,在后面介绍的知识我会尽量不提前用,即使提前使用,也会同时做好标注,避免了阅读时各种查阅资料的烦恼.</p>
<p>系列博客将采用一个一个的样例，来说明书中的精华部分（当然，这只是我认为的），同时引导新手，快速入门ES6，并逐步将其投入到生产实践中。</p>
<p>同时,在阅读前也提醒您, 为了系统连贯性的学习ES6的基础知识,建议您从我的博客第一章开始阅读,当然,如果您对对应的知识已经有所了解,那么可以跳转到任意章节阅读,每一篇博客名中均有介绍该博客中涉及到的ES6的内容.</p>
<p>阮一峰老师的这本书是开源的，在其官方博客就可以下载到，但是我强烈建议大家去购买一本书, 一是方便自己查阅ES6中新增的众多API, 二也是表达一下对大神的敬仰.</p>
<h1 id="函数的默认值"><a href="#函数的默认值" class="headerlink" title="函数的默认值"></a>函数的默认值</h1><p>在ES6之前,函数的默认值只能在函数体内进行判断</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">function log(x, y) &#123;</div><div class="line">	y = y || &quot;world&quot;</div><div class="line">	console.log(x, y)</div><div class="line">&#125;</div><div class="line">log(&quot;hello &quot;) // hello world</div><div class="line">// 当我们采用ES5的写法时,是存在问题的,当我们给第二个参数传入布尔值为false的值的时候,实际上并不会使用这个值而是仍然使用默认值.</div><div class="line">log(&quot;hello &quot;, false) // hello world</div><div class="line">log(&quot;hello &quot;, &quot;&quot;) // hello world</div><div class="line">log(&quot;hello &quot;, undefined) // hello world</div></pre></td></tr></table></figure>
<p>在ES6中就不会有这个烦恼了,ES6允许将参数设置默认值,直接写在参数定义的后面即可</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">function log(x, y = &quot;world&quot;) &#123;</div><div class="line">	console.log(x, y)</div><div class="line">&#125;</div><div class="line">log(&quot;hello &quot;) // hello world</div><div class="line">log(&quot;hello &quot;, false) // hello false</div><div class="line">log(&quot;hello &quot;, &quot;&quot;) // hello </div><div class="line">log(&quot;hello &quot;, undefined) // hello world</div></pre></td></tr></table></figure>
<p>由此可见,ES6的写法比之前更加自然,也更加的语义化了.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">function Point(x = 0, y = 0) &#123;</div><div class="line">	this.x = x</div><div class="line">	this.y = y</div><div class="line">&#125;</div><div class="line">var p1 = new Point()</div><div class="line">console.log(p1.x, p1.x) // 0 0</div><div class="line"></div><div class="line">var p2 = new Point(2)</div><div class="line">console.log(p2.x, p2.y) // 2 0</div></pre></td></tr></table></figure>
<p>因为变量的参数是默认声明的,所以我们在内部重新使用let或const对变量声明的时候,是会报错的</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">function foo(x = 5) &#123;</div><div class="line">	let x = 1  // 报错</div><div class="line">	const x = 1  // 报错</div><div class="line">&#125;</div><div class="line"></div><div class="line">## 函数的默认值与解构赋值默认值结合使用</div></pre></td></tr></table></figure>
<p>function foo({x, y = 5}) {<br>    console.log(x, y)<br>}<br>foo({})  // undefined 5<br>foo({x: 1})  // 1 5<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">在为函数使用解构赋值时,因为有必填的参数,所以这个情况下必须要填需要的参数,否则会报错.</div><div class="line"></div><div class="line">但是当我们在这种情况下,如果不想让它报错的话,可以使用双重解赋值的方法解决此问题</div></pre></td></tr></table></figure></p>
<p>function fetch(url, {method = “GET”} = {}) {<br>    console.log(method)<br>}<br>fetch(“<a href="http://example.com" target="_blank" rel="external">http://example.com</a>“) // GET<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">## 解构赋值的默认值和函数默认值的区别</div></pre></td></tr></table></figure></p>
<p>function m1({x = 0, y = 0} = {}) {<br>    return [x, y]<br>}<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">以上代码将函数参数默认值设置为空对象, 但设置了对象解构赋值的默认值</div><div class="line"></div><div class="line">我们在来看一下下面的代码</div></pre></td></tr></table></figure></p>
<p>function m2({x, y} = {x: 0, y: 0}) {<br>    return [x, y]<br>}<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">在函数都有参数或都没有参数的情况下,两者是相等的</div></pre></td></tr></table></figure></p>
<p>m1() // [0, 0]<br>m2() // [0, 0]<br>m1({x: 3, y: 8}) // [3, 8]<br>m2({x: 3, y: 8}) // [3, 8]<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">但是在当一个有值,一个没有值的情况下,区别就显现出来了</div></pre></td></tr></table></figure></p>
<p>m1({x: 3}) // [3, 0]<br>m2({x: 3}) // [3, undefined]<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">当我们传入的是不同的对象的时候, m1的默认值为0, 所以, 会输出0, 而因为输入的对象与解构赋值的默认值不匹配,所以会输出undefined</div></pre></td></tr></table></figure></p>
<p>m1({z: 3})  // [0, 0]<br>m2({z: 3})  // [undefined, undefined]<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">当我们将非尾部的参数设置了默认值,那么这个时候这个参数是没有办法省略的</div></pre></td></tr></table></figure></p>
<p>function f(x = 1, y) {<br>    return [x, y]<br>}<br>console.log(f()) // [1, undefined]<br>console.log(f(1)) // [1, undefined]<br>console.log(f(, 1)) // 报错<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">## 参数默认值的位置</div><div class="line"></div><div class="line">通常情况下,定义了默认值的参数应该是函数的尾参数.</div><div class="line"></div><div class="line">因为这样比较容易看出到底省略了哪些参数,如果非尾部的参数设置默认值实际上这个参数是无法省略的.</div><div class="line"> </div><div class="line">换句话说,就是当中间设置了默认值,如果要给其后的非指定默认值参数设置值的话,必须要给这个参数设置值,或者显式的设置undefined或null, 否则会报错</div></pre></td></tr></table></figure></p>
<p>function f(x, y = 5, z) {<br>    return [x, y, z]<br>}<br>console.log(f())  // [undefined, 5, undefined]<br>console.log(f(1)) // [1, 5, undefined]<br>console.log(f(1, undefined, 3)) // [1, 5, 3]<br>console.log(f(1, , 2)) // 报错<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">## 函数的length属性</div><div class="line"></div><div class="line">指定了默认值后.函数的length属性将会返回没有指定默认值的参数个数,也就是说,指定了默认值后,length属性将会失真</div><div class="line"></div><div class="line">同时,经过测试,当我们设置默认值在前时,其实显示的形参个数是设置默认值的形参前面的形参个数,后面的形参个数是不计入在内的</div></pre></td></tr></table></figure></p>
<p>console.log((function(x) {}).length)  // 1<br>console.log((function(x = 90, a, b) {}).length) // 0<br>console.log((function(x, a = 90, b) {}).length) // 1<br>console.log((function(x, a, b = 90) {}).length) // 2<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">同样的,因为rest参数,也就是俗称的三点运算符的特殊性,其长度是不会计入length属性的</div></pre></td></tr></table></figure></p>
<p>console.log((function(…args){}).length)  // 0<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">## 函数的作用域</div><div class="line"></div><div class="line">一个需要注意的地方是,如果参数默认值是一个变量,则该变量所处的作用域与其他的变量的作用域是一样的,即先是当前函数的作用域,然后才是全局作用域</div></pre></td></tr></table></figure></p>
<p>let x = 1</p>
<p>function f(x, y = x) {<br>    console.log(y) // 2<br>}<br>f(2)<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">上面的代码中,参数的默认值等于x. 调用时, 由于函数作用域内部的变量x已经生成, 所以y等于参数x而不是全局变量x</div><div class="line"></div><div class="line">但当调用的时候函数作用域内部的变量x没有生成,那么x就会指向全局变量,因为全局变量中没有这个参数,所以y依然指向自身</div><div class="line"></div><div class="line">另外说明一下,这个和阮一峰老师的书中结果是不一致的,经过在chrome59版本下测试,结果为1</div></pre></td></tr></table></figure></p>
<p>function f1(y = x) {<br>    let x = 2<br>    console.log(y) // 1<br>}<br>f1(1)<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">## 函数的参数默认值的小应用</div><div class="line"></div><div class="line">引用参数默认值,可以指定某一个参数不得省略,否则会抛出一个错误</div></pre></td></tr></table></figure></p>
<p>throwIfMissing = () =&gt; {<br>    throw new Error(‘Missing parameter’)<br>}</p>
<p>function foo(mustBeProvided = throwIfMissing()) {<br>    return mustBeProvided<br>}</p>
<p>foo() // Error: Missing parameter<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"># rest参数(三点运算符)</div><div class="line"></div><div class="line">在ES6中引入了rest参数, 用于获取函数的多余参数,这样就不需要使用arguments对象了,rest参数搭配的变量是一个数组,该变量将多余的参数放入其中</div></pre></td></tr></table></figure></p>
<p>function add(…values) {<br>    let sum = 0<br>    console.log(values) // [2, 3, 4]<br>    for (var val of values) {<br>        sum += val<br>    }<br>    return sum<br>}<br>console.log(add(2, 3, 4)) // 9<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">下面是rest参数代替arguments变量的例子</div></pre></td></tr></table></figure></p>
<p>//在ES5中<br>const shortNumbers = () =&gt; {<br>    return Array.prototype.slice.call(arguments).sort()<br>}<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">// 使用rest参数无疑让写法更加简洁自然了</div></pre></td></tr></table></figure></p>
<p>const sortNumbers = (…numbers) =&gt; {<br>    return numbers.sort()<br>}</p>
<h2 id="使用rest参数的特性-可以改写push方法"><a href="#使用rest参数的特性-可以改写push方法" class="headerlink" title="使用rest参数的特性,可以改写push方法"></a>使用rest参数的特性,可以改写push方法</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">function push(array, ...items) &#123;</div><div class="line">	items.forEach(function(item) &#123;</div><div class="line">		array.push(item)</div><div class="line">	&#125;)</div><div class="line">	return array</div><div class="line">&#125;</div><div class="line">console.log(push([1, 2, 3], 1, 2, 3, 4, 54)) </div><div class="line">// [1, 2, 3, 1, 2, 3, 4, 54]</div></pre></td></tr></table></figure>
<h1 id="扩展运算符-…"><a href="#扩展运算符-…" class="headerlink" title="扩展运算符  …"></a>扩展运算符  …</h1><p>扩展运算符好比rest参数的逆运算,将一个数组转为用逗号分隔的参数序列</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">console.log(...[1, 2, 3]) // 1 2 3</div><div class="line">console.log(1, ...[2, [[3], 4]], 5) // 1, 2, [[3], 4]], 5</div><div class="line"></div><div class="line">## 扩展运算符的应用</div><div class="line"></div><div class="line">### 替代数组的apply方法</div><div class="line"></div><div class="line">在ES5之前,我们如果需要将数组的值作为函数的参数逐一传进函数的时候,最简便的方法就是使用apply方法</div></pre></td></tr></table></figure>
<p>function f(x, y, z) {}<br>var args = [1, 2, 3]<br>f.apply(null, args)<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">在ES6中,写法是这样的</div></pre></td></tr></table></figure></p>
<p>function f2(x, y, z) {}<br>var args = [0, 1, 2]<br>f2(…args)<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">### 替代Math.max方法</div><div class="line"></div><div class="line">当我们需要对数组进行最大最小值的判断的时候,在ES5中,用法是这样的</div></pre></td></tr></table></figure></p>
<p>var a = [1, 2, 4, 12, 3, 5, 1, 12]<br>console.log(Math.max.apply(null, a)) // 12<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">但是在ES6中,我们就不必要这么麻烦了,因为扩展运算符 ... 可以将数组直接转换为普通的单个数字</div></pre></td></tr></table></figure></p>
<p>var a = [1, 2, 4, 12, 3, 5, 1, 12]<br>console.log(Math.max(…a)) // 12<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">### 替代push方法</div><div class="line"></div><div class="line">同样的,在ES5中,如果我们需要使用push方法将两个数组连接起来的时候,我们需要这样做</div></pre></td></tr></table></figure></p>
<p>var a = [1, 2, 3]<br>var b = [4, 5, 6]<br>Array.prototype.push.apply(a, b)<br>console.log(a) // [1, 2, 3, 4, 5, 6]<br>console.log(b) // [4, 5, 6]<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">因为最后需要得到扁平化的数组,所以并不能直接使用`a.push(b)`这样的方法,这样会使得到的变成多维数组</div><div class="line"></div><div class="line">同样的,ES6还提供了数组合并的新写法:</div></pre></td></tr></table></figure></p>
<p>var a = [1, 2, 3]<br>var b = [4, 5, 6]<br>a.push(…b)<br>console.log(a) // [1, 2, 3, 4, 5, 6]<br>console.log(b) // [4, 5, 6]<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">### 替代数组合并方法</div></pre></td></tr></table></figure></p>
<p>var a = [1, 2, 3]<br>var b = [4, 5, 6]<br>var c = a.concat(b)<br>console.log(c)  // [1, 2, 3, 4, 5, 6]<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">在ES6中,因为有了 ... 运算符,那么其实concat是可以省略的</div></pre></td></tr></table></figure></p>
<p>var a = [1, 2, 3]<br>var b = [4, 5, 6]<br>var d = […a, …b]<br>console.log(d)  // [1, 2, 3, 4, 5, 6]<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">### 与解构赋值结合起来,用于生成数组</div><div class="line"></div><div class="line">那么,我们先来看一下,在ES5中,是怎么做到的</div></pre></td></tr></table></figure></p>
<p>let a = [1, 2, 3, 4]<br>let b = a[0]<br>let c = a.slice(1)<br>console.log(b, c) // 1 [2, 3, 4]<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">那么在ES6中,这样的形式就很容易实现了,通过解构赋值和三点运算符结合的方式</div></pre></td></tr></table></figure></p>
<p>let a = [1, 2, 3, 4]<br>let [d, …e] = a<br>console.log(d, e) // 1 [2, 3, 4]<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">当我们对一个空的数组进行解构赋值的时候,会出现什么情况呢?</div></pre></td></tr></table></figure></p>
<p>let [f, …g] = []<br>console.log(f, g) //undefined  []<br>let [h, …i] = [‘foo’]<br>console.log(h, i) // foo  []<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">需要注意的是,我们使用扩展运算符,也就是三点运算符,这个运算是必须要放在参数的最后一位的,否则会报错</div></pre></td></tr></table></figure></p>
<p>let […j, k] = [1, 2, 3, 4]<br>console.log(j, k)<br>//报错,Rest element must be last element<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">## 扩展运算符对字符串的支持</div></pre></td></tr></table></figure></p>
<p>console.log([…’hello’]) // [“h”, “e”, “l”, “l”, “o”]<br>// 扩展运算符将字符串中的每一个值都拆分成了单个的字符组成的数组<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">当然,这还不是最重要的,重要的是, 扩展运算符对32位Unicode字符的支持</div></pre></td></tr></table></figure></p>
<p>console.log([…’x\u{20bb7}\u20bb7’].length)  // 4<br>// 可见,两个大括号完美地解决了32位字符这个bug的尴尬<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">对于unicode不太了解的童鞋, 可以先跳转到之前,看下我写的ES6中对Unicode的支持这一章节</div><div class="line"></div><div class="line">括展运算符内部调用的是数据结构的iterator接口,因此只要具有iterator接口的对象,都可以使用扩展运算符</div></pre></td></tr></table></figure></p>
<p>let map = new Map([<br>    [1, ‘one’],<br>    [2, ‘two’],<br>    [3, ‘three’]<br>])<br>let arr = […map.values()]<br>console.log(arr)<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">Generator函数运行后返回一个遍历器对象,因此也可以使用扩展运算符</div></pre></td></tr></table></figure></p>
<p>var go = function*() {<br>    yield 1<br>    yield 2<br>    yield 3</p>
<p>}<br>console.log([…go()])<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"># 函数的name属性</div><div class="line"></div><div class="line">函数的name属性返回该函数的函数名</div><div class="line"></div><div class="line">通过bind返回的函数, name属性会加上&apos;bound&apos;前缀</div></pre></td></tr></table></figure></p>
<p>function foo() {}<br>console.log(foo.name) // foo<br>function foo() {}<br>console.log(foo.bind({}).name) //bound foo<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"># ES6的箭头函数</div><div class="line"></div><div class="line">ES6允许使用箭头定义函数</div><div class="line"></div><div class="line">` var f = v =&gt; v `</div><div class="line"></div><div class="line">上面的箭头其实就等价于</div></pre></td></tr></table></figure></p>
<p>var f = function(v) {<br>    return v<br>}<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">那么,上面是需要参数的情况下,当我们不需要参数的时候怎么办呢?</div><div class="line"></div><div class="line">在这个情况下是可以使用圆括号代替的</div><div class="line"></div><div class="line">`var f = () =&gt; 5`</div><div class="line"></div><div class="line">等价于</div></pre></td></tr></table></figure></p>
<p>var f = function() {<br>    return 5<br>}<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">当存在多个参数的时候</div><div class="line"></div><div class="line">`var f = (num1, num2) =&gt; num1 + num2`</div><div class="line"></div><div class="line">等价于</div></pre></td></tr></table></figure></p>
<p>var f = function(num1, num2) {<br>    return num1 + num2<br>}<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">如果箭头函数的代码块部分多于一条语句, 就要使用大括号将其括起来, 并使用return语句返回</div><div class="line"></div><div class="line">由于大括号被解释为代码块,所以当我们需要箭头函数返回一个对象的时候,需要使用圆括号将对象括起来</div></pre></td></tr></table></figure></p>
<p>var f = id =&gt; ({<br>    id: id,<br>    name: ‘temp’<br>})<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">还有一点是,箭头函数还可以和解构赋值一起使用</div></pre></td></tr></table></figure></p>
<p>var full = ({first, last}) =&gt; first + ‘ ‘ + last<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">等价于</div></pre></td></tr></table></figure></p>
<p>var full = function(person) {<br>    return first + “ “ + last<br>}<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">箭头函数的另一个用处就是简化回调函数</div><div class="line"></div><div class="line">`[1, 2, 3].map(x =&gt; x * x)`</div><div class="line"></div><div class="line">等价于</div><div class="line"></div><div class="line">`[1, 2, 3].map(function(x) &#123;return x * x&#125;)`</div><div class="line"></div><div class="line">rest参数的写法</div><div class="line"></div><div class="line">`const headAndTail = (head, ...tail) =&gt; [head, tail]`</div><div class="line"></div><div class="line"># 箭头函数的使用注意点</div><div class="line"></div><div class="line">&gt;函数体内的this对象就是定义的时候所在的对象,而不是使用的时候所在的对象</div><div class="line"></div><div class="line">&gt;不可以拿来当做构造函数,也就是不可以拿来new一下,否则会抛出一个错误</div><div class="line"></div><div class="line">&gt;不可以使用arguments对象,该对象在函数体内是不存在的,如果需要使用,可以使用rest参数将arguments对象转为数组之后使用</div><div class="line"></div><div class="line">&gt;不可以使用yield命令,因此箭头函数不能用作Generator参数</div><div class="line"></div><div class="line"># 箭头函数中的this</div><div class="line"></div><div class="line">this的指向在之前是可变的,但是在箭头函数中是固定的</div></pre></td></tr></table></figure></p>
<p>function foo() {<br>    setTimeout(() =&gt; {<br>        console.log(‘id:’, this.id) // id: 42<br>    }, 100)<br>}</p>
<p>foo.call({id: 42})<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">而且不论嵌套多少层,都是没有问题的,朝阳指向调用的对象</div></pre></td></tr></table></figure></p>
<p>function foo3() {<br>    return () =&gt; {<br>        return () =&gt; {<br>            console.log(‘id: ‘, this.id) // id: 42<br>        }<br>    }<br>}<br>foo3.call({id: 42})()()<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">因为箭头函数没有自己的this, 所以我们在内部绑定this,是不能生效的</div></pre></td></tr></table></figure></p>
<p>var a = (function() {<br>    return [<br>        (() =&gt; this.x).bind({<br>            x: ‘inner’<br>        })<br>    ]<br>}).call({<br>    x: ‘outer’<br>})<br>console.log(a()) // () =&gt; this.x<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">箭头函数的内部还可以再使用箭头函数</div></pre></td></tr></table></figure></p>
<p>function insert(value) {<br>    return {<br>        into: function(array) {<br>            return {<br>                after: function(afterValue) {<br>                    array.splice(array.indexOf(afterValue) + 1, 0, value)<br>                }<br>            }<br>        }<br>    }<br>}</p>
<p>console.log(insert(2).into([1, 3]).after(1)) // [1, 2, 3]<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"># 函数绑定</div><div class="line"></div><div class="line">箭头函数可以绑定this对象, 大大减少了显式绑定this对象的写法, 但是因为this在箭头函数中的特殊性,因此其并不适用于所有场合</div><div class="line"></div><div class="line">所以ES7提出了函数绑定的写法, 目前浏览器暂不支持,但babel转码器已经支持</div></pre></td></tr></table></figure></p>
<p>foo::bar<br>// 等同于<br>bar.bind(foo)<br>```</p>
]]></content>
    
    <summary type="html">
    
      本系列为在我读完阮一峰老师的《ES6标准入门》第二版之后，所做的阅读笔记的整理。 系列博客将采用一个一个的样例，来说明书中的精华部分（当然，这只是我认为的），同时引导新手，快速入门ES6，并逐步将其投入到生产实践中。
    
    </summary>
    
      <category term="ES6标准入门" scheme="https://github.com/ChangerHe/categories/ES6%E6%A0%87%E5%87%86%E5%85%A5%E9%97%A8/"/>
    
    
      <category term="ES6" scheme="https://github.com/ChangerHe/tags/ES6/"/>
    
      <category term="Function" scheme="https://github.com/ChangerHe/tags/Function/"/>
    
  </entry>
  
</feed>
