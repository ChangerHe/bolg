<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>ChangerHe&#39;s Bolg|何庆畅的个人博客</title>
  <subtitle>What doesn&#39;t kill you make you stronger.</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://github.com/ChangerHe/"/>
  <updated>2017-09-30T03:41:50.749Z</updated>
  <id>https://github.com/ChangerHe/</id>
  
  <author>
    <name>ChangerHe</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Javascript中隐式类型转换的神坑</title>
    <link href="https://github.com/ChangerHe/2017/09/30/Javascript%E4%B8%AD%E9%9A%90%E5%BC%8F%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2%E7%9A%84%E7%A5%9E%E5%9D%91/"/>
    <id>https://github.com/ChangerHe/2017/09/30/Javascript中隐式类型转换的神坑/</id>
    <published>2017-09-30T06:16:09.000Z</published>
    <updated>2017-09-30T03:41:50.749Z</updated>
    
    <content type="html"><![CDATA[<p>开篇之前, 大家先思考一个问题, 下面这段代码运行出来之后的结果是多少</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">++[[]][+[]]+[+[]]</div></pre></td></tr></table></figure>
<p>首先, 不得不说, 发现并提出这个问题的人是个天才，他怎么会遇到这样的一个问题。 </p>
<p>其次，回答这个问题的人更是一个天才，我难以想象他会回答这个问题，更难以想象的是，他的回答是如此的详细和丰富和完整，真正称得上诲人不倦。</p>
<p>不卖关子了, 这道题的答案是10, String类型的, 10</p>
<p>那么, 这个问题怎么解呢? 下面跟着我一起把小车开起来~</p>
<h1 id="回归本源"><a href="#回归本源" class="headerlink" title="回归本源"></a>回归本源</h1><p>我们先复习一下: JS中有两种数据类型: 基本数据类型, 复杂数据类型</p>
<p>基本数据类型存储在栈空间中, 类型加上ES6新增的Symbol一共六种</p>
<blockquote>
<p>string</p>
<p>number</p>
<p>boolean</p>
<p>undefined</p>
<p>null</p>
<p>symbol</p>
</blockquote>
<p>复杂数据类型存储在堆空间中,包含以下三种</p>
<blockquote>
<p>function</p>
<p>object</p>
<p>array</p>
</blockquote>
<p>但是听说最近爆出了Chrome的61版本存在的安全漏洞的问题</p>
<p>因为V8团队之前做的一个优化,将函数中的内部复杂数据类型直接存储在栈空间了, 导致V8对ES6的解构, for…of,rest参数的解析功能会变慢, 当然, 这又是另外一回事了.</p>
<h1 id="当我们执行加法操作时-JS在想什么"><a href="#当我们执行加法操作时-JS在想什么" class="headerlink" title="当我们执行加法操作时,JS在想什么"></a>当我们执行加法操作时,JS在想什么</h1><p>首先还是申明一下,下面的解释是在网上查阅资料, 加上我自己的实践得出的结果, 可能和准确值存在偏差. 欢迎指正</p>
<h2 id="加法运算的隐式转换的执行顺序"><a href="#加法运算的隐式转换的执行顺序" class="headerlink" title="加法运算的隐式转换的执行顺序"></a>加法运算的隐式转换的执行顺序</h2><p>加法运算符会触发三种类型转换：</p>
<blockquote>
<p>转换为原始值</p>
<p>转换为数字</p>
<p>转换为字符串</p>
</blockquote>
<h2 id="通过-ToPrimitive-将值转换为原始值"><a href="#通过-ToPrimitive-将值转换为原始值" class="headerlink" title="通过 ToPrimitive() 将值转换为原始值"></a>通过 ToPrimitive() 将值转换为原始值</h2><p>如果操作值是个原始值，则直接返回它。</p>
<p>否则，如果操作值是一个对象。则调用 obj.valueOf() 方法。 如果返回值是一个原始值，则返回这个原始值。</p>
<p>否则，调用 obj.toString() 方法。 如果返回值是一个原始值，则返回这个原始值。</p>
<p>否则，抛出 TypeError 异常。</p>
<h2 id="通过-ToNumber-将值转换为数字"><a href="#通过-ToNumber-将值转换为数字" class="headerlink" title="通过 ToNumber() 将值转换为数字"></a>通过 ToNumber() 将值转换为数字</h2><p>下面的表格解释了 ToNumber() 是如何将原始值转换成数字的</p>
<table>
<thead>
<tr>
<th style="text-align:center">参数</th>
<th style="text-align:center">结果</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">undefined</td>
<td style="text-align:center">NaN</td>
</tr>
<tr>
<td style="text-align:center">null</td>
<td style="text-align:center">+0</td>
</tr>
<tr>
<td style="text-align:center">boolean</td>
<td style="text-align:center">true被转换为1,false转换为+0</td>
</tr>
<tr>
<td style="text-align:center">number</td>
<td style="text-align:center">无需转换</td>
</tr>
<tr>
<td style="text-align:center">string</td>
<td style="text-align:center">由字符串解析为数字。例如，”324”被转换为324</td>
</tr>
</tbody>
</table>
<h2 id="通过ToString-将值转换为字符串"><a href="#通过ToString-将值转换为字符串" class="headerlink" title="通过ToString()将值转换为字符串"></a>通过ToString()将值转换为字符串</h2><p>下面的表格解释了 ToString() 是如何将原始值转换成字符串的</p>
<table>
<thead>
<tr>
<th style="text-align:center">参数</th>
<th style="text-align:center">结果</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">undefined</td>
<td style="text-align:center">“undefined”</td>
</tr>
<tr>
<td style="text-align:center">null</td>
<td style="text-align:center">“null”</td>
</tr>
<tr>
<td style="text-align:center">boolean</td>
<td style="text-align:center">“true” 或者 “false”</td>
</tr>
<tr>
<td style="text-align:center">number</td>
<td style="text-align:center">数字作为字符串。比如，”1.765”</td>
</tr>
<tr>
<td style="text-align:center">string</td>
<td style="text-align:center">无需转换</td>
</tr>
</tbody>
</table>
<h1 id="小小的总结一下"><a href="#小小的总结一下" class="headerlink" title="小小的总结一下"></a>小小的总结一下</h1><p>其实说这么多, 最后想表达的还是一个重要思想</p>
<p>对于JS中的加法, 流程是这样的</p>
<ul>
<li><p>判断两边的值是否都为普通的String或Number类型, 如果是,则直接进行数学相加或字符串的拼接操作</p>
</li>
<li><p>如果两边并非都为数字或字符串,那么首先会对相加值中的复杂数据类型进行valueOf()操作, 首先确定一下这个复杂数据类型能否通过求值来返回一个简单数据类型, 然后将求值结果与另一个值进行相加. </p>
</li>
<li><p>如果结果不是一个原始值, 则会调用toString()方法,将复杂类型直接转为字符串,进行拼接操作.</p>
</li>
</ul>
<p>码完了, 好累啊, 那么下面我们做一些简单的测试, 对应上面列出的几条语法</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">6 + &#123; valueOf: function () &#123; return 2 &#125; &#125;  // 8</div></pre></td></tr></table></figure>
<p>上面的代码中,我们把valueOf()转为了直接返回2, 所以因为在加法运算时会直接运行所以返回了2</p>
<p>没看懂? 没事儿咱们还有一个例子来说明这个问题,再来看一个好玩的</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">Number.prototype.valueOf = function() &#123;</div><div class="line">	return 3</div><div class="line">&#125;</div><div class="line"></div><div class="line">new Number(2) == 3 // true</div></pre></td></tr></table></figure>
<p>接下来看个简单的</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">[] + [] // &quot;&quot;</div></pre></td></tr></table></figure>
<p>为什么返回空值呢? 因为[]的valueOf值就是空值啊</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">[] + &#123;&#125; // &apos;&apos;[object Object]&apos;&apos;</div></pre></td></tr></table></figure>
<p>同样的,因为{} 的valueOf()返回的是<code>[object Object]</code>, 加上前面的<code>`, 所以返回了</code>[object Object]`</p>
<h1 id="开始的结果解析"><a href="#开始的结果解析" class="headerlink" title="开始的结果解析"></a>开始的结果解析</h1><p>看完这些之后,我们再看一下开始的代码</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">++[[]][+[]]+[+[]]</div></pre></td></tr></table></figure>
<p>其实这样就很好解释了</p>
<p>根据优先级,会先计算括号内的元素</p>
<p><code>[[]]</code> 变成了 <code>[&#39;&#39;]</code></p>
<p><code>[+[]]</code> 变成了 <code>[0]</code></p>
<p>上面的代码可以简化为</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">++[&apos;&apos;][0] + [0]</div></pre></td></tr></table></figure>
<p>而<code>[&#39;&#39;][0]</code> , 数组的第零位,也就是<code>&#39;&#39;</code>, 进行自加操作时进行上述的隐式类型转换, 变成了0, 自加1, 所以变成了1</p>
<p>同样的 <code>[0]</code> 会被转换为 0 , 注意是字符类型的 0</p>
<p>所以最后的结果是</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">1 + &quot;0&quot;</div></pre></td></tr></table></figure>
<p>所以答案是 ‘10’</p>
<p>(完)</p>
]]></content>
    
    <summary type="html">
    
      开篇之前, 大家先思考一个问题, 下面这段代码运行出来之后的结果是多少 ++[[]][+[]]+[+[]]   
    
    </summary>
    
      <category term="JavaScript 学习笔记" scheme="https://github.com/ChangerHe/categories/JavaScript-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="JavaScript" scheme="https://github.com/ChangerHe/tags/JavaScript/"/>
    
  </entry>
  
  <entry>
    <title>基于MongoDB 2dSphere索引查找最近的点</title>
    <link href="https://github.com/ChangerHe/2017/07/21/%E5%9F%BA%E4%BA%8EMongoDB-2dSphere%E7%B4%A2%E5%BC%95%E6%9F%A5%E6%89%BE%E6%9C%80%E8%BF%91%E7%9A%84%E7%82%B9/"/>
    <id>https://github.com/ChangerHe/2017/07/21/基于MongoDB-2dSphere索引查找最近的点/</id>
    <published>2017-07-21T15:27:22.000Z</published>
    <updated>2017-09-24T15:35:44.241Z</updated>
    
    <content type="html"><![CDATA[<p>在移动端普及的今天，LBS应用需求也越来越大。比如查找附近的人，最近的餐厅等。面对这些需求，MongoDB提供了功能完备的解决方案。下面通过一个案例来解释一下MongoDB的2dSphere</p>
<p><img src="http://img.blog.csdn.net/20160923111644414" alt=""></p>
<p>在这个图片中，有A B C D E F G,假如我是搜索点A。我想查找离自己最近的点。下面是具体的操作步骤： </p>
<h1 id="建立集合和索引。sp为建立索引的字段名，我们建立的索引类型是2dsphere"><a href="#建立集合和索引。sp为建立索引的字段名，我们建立的索引类型是2dsphere" class="headerlink" title="建立集合和索引。sp为建立索引的字段名，我们建立的索引类型是2dsphere"></a>建立集合和索引。sp为建立索引的字段名，我们建立的索引类型是2dsphere</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"># 创建2dsphere索引</div><div class="line"> db.sphere.ensureIndex(&#123;&quot;sp&quot;:&quot;2dsphere&quot;&#125;)</div></pre></td></tr></table></figure>
<h1 id="向集合中插入测试数据，我们插入的是实际的经纬度。"><a href="#向集合中插入测试数据，我们插入的是实际的经纬度。" class="headerlink" title="向集合中插入测试数据，我们插入的是实际的经纬度。"></a>向集合中插入测试数据，我们插入的是实际的经纬度。</h1><p>这里需要注意的是，如果我们如果用的是2dsphere索引，那么插入的应该是GeoJson数据。GeoJson的格式是 </p>
<p><code>{ type: ‘GeoJSON type’ , coordinates: ‘coordinates’ }</code></p>
<p>其中type指的是类型，可以是Point(本例中用的)，LineString，Polygon等，coordinates是一个坐标数组。英语好的同学可以去官网看看<a href="https://docs.mongodb.com/manual/reference/geojson/" target="_blank" rel="external">https://docs.mongodb.com/manual/reference/geojson/</a></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"># 插入Point数据</div><div class="line">db.sphere.insert(&#123;name:&quot;A&quot;,sp:&#123;type:&quot;Point&quot;,coordinates:[105.754484701156,41.689607057699]&#125;&#125;)</div><div class="line">db.sphere.insert(&#123;name:&quot;B&quot;,sp:&#123;type:&quot;Point&quot;,coordinates:[105.304045248031,41.783456183240]&#125;&#125;)</div><div class="line">db.sphere.insert(&#123;name:&quot;C&quot;,sp:&#123;type:&quot;Point&quot;,coordinates:[105.084318685531,41.389027478812]&#125;&#125;)</div><div class="line">db.sphere.insert(&#123;name:&quot;D&quot;,sp:&#123;type:&quot;Point&quot;,coordinates:[105.831388998031,41.285916385493]&#125;&#125;)</div><div class="line">db.sphere.insert(&#123;name:&quot;E&quot;,sp:&#123;type:&quot;Point&quot;,coordinates:[106.128706502914,42.086868474465]&#125;&#125;)</div><div class="line">db.sphere.insert(&#123;name:&quot;F&quot;,sp:&#123;type:&quot;Point&quot;,coordinates:[105.431074666976,42.009365053841]&#125;&#125;)</div><div class="line">db.sphere.insert(&#123;name:&quot;G&quot;,sp:&#123;type:&quot;Point&quot;,coordinates:[104.705977010726,41.921549795110]&#125;&#125;)</div></pre></td></tr></table></figure>
<h1 id="进行查询。介绍一下其中的参数"><a href="#进行查询。介绍一下其中的参数" class="headerlink" title="进行查询。介绍一下其中的参数"></a>进行查询。介绍一下其中的参数</h1><blockquote>
<p>（1）geoNear:我们要查询的集合名称 </p>
<p>（2）near:就是基于那个点进行搜索，这里是我们的搜索点A </p>
<p>（3）spherical:是个布尔值，如果为true，表示将计算实际的物理距离比如两点之间有多少km,若为false,则会基于点的单位进行计算 </p>
<p>（4）minDistance:搜索的最小距离，这里的单位是米 </p>
<p>（5）maxDistance:搜索的最大距离</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">db.runCommand(&#123;</div><div class="line">    geoNear:&quot;sphere&quot;,</div><div class="line">    near:&#123;type:&quot;Point&quot;,coordinates:[105.794621276855,41.869574065014]&#125;,</div><div class="line">    spherical:true,</div><div class="line">    minDistance:25000,</div><div class="line">    maxDistance:40000,</div><div class="line">    &#125;)</div></pre></td></tr></table></figure>
<h1 id="结果分析"><a href="#结果分析" class="headerlink" title="结果分析"></a>结果分析</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div></pre></td><td class="code"><pre><div class="line">&#123;</div><div class="line">    &quot;waitedMS&quot; : NumberLong(0),</div><div class="line">    &quot;results&quot; : [ </div><div class="line">        &#123;</div><div class="line">            &quot;dis&quot; : 33887.5416611258,</div><div class="line">            &quot;obj&quot; : &#123;</div><div class="line">                &quot;_id&quot; : ObjectId(&quot;57e3857e6a4a326367ae0d05&quot;),</div><div class="line">                &quot;name&quot; : &quot;F&quot;,</div><div class="line">                &quot;sp&quot; : &#123;</div><div class="line">                    &quot;type&quot; : &quot;Point&quot;,</div><div class="line">                    &quot;coordinates&quot; : [ </div><div class="line">                        105.431074666976, </div><div class="line">                        42.009365053841</div><div class="line">                    ]</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">        &#125;, </div><div class="line">        &#123;</div><div class="line">            &quot;dis&quot; : 36734.9748784127,</div><div class="line">            &quot;obj&quot; : &#123;</div><div class="line">                &quot;_id&quot; : ObjectId(&quot;57e3857e6a4a326367ae0d04&quot;),</div><div class="line">                &quot;name&quot; : &quot;E&quot;,</div><div class="line">                &quot;sp&quot; : &#123;</div><div class="line">                    &quot;type&quot; : &quot;Point&quot;,</div><div class="line">                    &quot;coordinates&quot; : [ </div><div class="line">                        106.128706502914, </div><div class="line">                        42.086868474465</div><div class="line">                    ]</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    ],</div><div class="line">    &quot;stats&quot; : &#123;</div><div class="line">        &quot;nscanned&quot; : 24,</div><div class="line">        &quot;objectsLoaded&quot; : 20,</div><div class="line">        &quot;avgDistance&quot; : 35311.2582697693,</div><div class="line">        &quot;maxDistance&quot; : 36734.9748784127,</div><div class="line">        &quot;time&quot; : 87</div><div class="line">    &#125;,</div><div class="line">    &quot;ok&quot; : 1.0</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>在results中，我们搜索到了点F和E。每个文档都加上了一个dis字段，他表示这个点离你搜索点的距离。</p>
<p>比如说，在结果中name为F的点的dis为33887.5416611258。表示F点距离搜索点的距离是33887米。这个结果对于LBS应用是非常有用的。 </p>
]]></content>
    
    <summary type="html">
    
      在移动端普及的今天，LBS应用需求也越来越大。比如查找附近的人，最近的餐厅等。面对这些需求，MongoDB提供了功能完备的解决方案。下面通过一个案例来解释一下MongoDB的2dSphere
    
    </summary>
    
      <category term="MongoDB学习笔记" scheme="https://github.com/ChangerHe/categories/MongoDB%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="MongoDB" scheme="https://github.com/ChangerHe/tags/MongoDB/"/>
    
      <category term="2dSphere" scheme="https://github.com/ChangerHe/tags/2dSphere/"/>
    
  </entry>
  
  <entry>
    <title>《ES6标准入门》阅读笔记——-Module</title>
    <link href="https://github.com/ChangerHe/2017/07/20/%E3%80%8AES6%E6%A0%87%E5%87%86%E5%85%A5%E9%97%A8%E3%80%8B%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0%E2%80%94%E2%80%94-Module/"/>
    <id>https://github.com/ChangerHe/2017/07/20/《ES6标准入门》阅读笔记——-Module/</id>
    <published>2017-07-19T16:23:13.000Z</published>
    <updated>2017-09-18T00:42:20.342Z</updated>
    
    <content type="html"><![CDATA[<h1 id="写在前面"><a href="#写在前面" class="headerlink" title="写在前面"></a>写在前面</h1><p>本系列为在我读完阮一峰老师的《ES6标准入门》第二版之后，所做的阅读笔记的整理。</p>
<p>许多初学ES6, 同时和我一样初次阅读阮老师的这本书的时候, 读第一遍会越发的困惑, 因为阮老师上面说的很多的定义,方法,之前都是没有见过的, 读到后面才发现, 哦~原来是这样.</p>
<p>有一句话叫做”大神的世界我们不懂”, 所以我在初读第一遍《ES6标准入门》这本书的时候,也是踩了不少坑,读书的时候查阅了不少的资料.</p>
<p>所以,在这一系列的笔记教程中,我会从一个初学者的角度,向您讲述ES6的相关知识,在后面介绍的知识我会尽量不提前用,即使提前使用,也会同时做好标注,避免了阅读时各种查阅资料的烦恼.</p>
<p>系列博客将采用一个一个的样例，来说明书中的精华部分（当然，这只是我认为的），同时引导新手，快速入门ES6，并逐步将其投入到生产实践中。</p>
<p>同时,在阅读前也提醒您, 为了系统连贯性的学习ES6的基础知识,建议您从我的博客第一章开始阅读,当然,如果您对对应的知识已经有所了解,那么可以跳转到任意章节阅读,每一篇博客名中均有介绍该博客中涉及到的ES6的内容.</p>
<p>阮一峰老师的这本书是开源的，在其官方博客就可以下载到，但是我强烈建议大家去购买一本书, 一是方便自己查阅ES6中新增的众多API, 二也是表达一下对大神的敬仰.</p>
]]></content>
    
    <summary type="html">
    
      本系列为在我读完阮一峰老师的《ES6标准入门》第二版之后，所做的阅读笔记的整理。 系列博客将采用一个一个的样例，来说明书中的精华部分（当然，这只是我认为的），同时引导新手，快速入门ES6，并逐步将其投入到生产实践中。
    
    </summary>
    
      <category term="ES6标准入门" scheme="https://github.com/ChangerHe/categories/ES6%E6%A0%87%E5%87%86%E5%85%A5%E9%97%A8/"/>
    
    
      <category term="ES6" scheme="https://github.com/ChangerHe/tags/ES6/"/>
    
      <category term="Module" scheme="https://github.com/ChangerHe/tags/Module/"/>
    
  </entry>
  
  <entry>
    <title>《ES6标准入门》阅读笔记——-Class</title>
    <link href="https://github.com/ChangerHe/2017/07/16/%E3%80%8AES6%E6%A0%87%E5%87%86%E5%85%A5%E9%97%A8%E3%80%8B%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0%E2%80%94%E2%80%94-Class/"/>
    <id>https://github.com/ChangerHe/2017/07/16/《ES6标准入门》阅读笔记——-Class/</id>
    <published>2017-07-16T15:52:52.000Z</published>
    <updated>2017-09-18T00:42:14.635Z</updated>
    
    <content type="html"><![CDATA[<h1 id="写在前面"><a href="#写在前面" class="headerlink" title="写在前面"></a>写在前面</h1><p>本系列为在我读完阮一峰老师的《ES6标准入门》第二版之后，所做的阅读笔记的整理。</p>
<p>许多初学ES6, 同时和我一样初次阅读阮老师的这本书的时候, 读第一遍会越发的困惑, 因为阮老师上面说的很多的定义,方法,之前都是没有见过的, 读到后面才发现, 哦~原来是这样.</p>
<p>有一句话叫做”大神的世界我们不懂”, 所以我在初读第一遍《ES6标准入门》这本书的时候,也是踩了不少坑,读书的时候查阅了不少的资料.</p>
<p>所以,在这一系列的笔记教程中,我会从一个初学者的角度,向您讲述ES6的相关知识,在后面介绍的知识我会尽量不提前用,即使提前使用,也会同时做好标注,避免了阅读时各种查阅资料的烦恼.</p>
<p>系列博客将采用一个一个的样例，来说明书中的精华部分（当然，这只是我认为的），同时引导新手，快速入门ES6，并逐步将其投入到生产实践中。</p>
<p>同时,在阅读前也提醒您, 为了系统连贯性的学习ES6的基础知识,建议您从我的博客第一章开始阅读,当然,如果您对对应的知识已经有所了解,那么可以跳转到任意章节阅读,每一篇博客名中均有介绍该博客中涉及到的ES6的内容.</p>
<p>阮一峰老师的这本书是开源的，在其官方博客就可以下载到，但是我强烈建议大家去购买一本书, 一是方便自己查阅ES6中新增的众多API, 二也是表达一下对大神的敬仰.</p>
]]></content>
    
    <summary type="html">
    
      本系列为在我读完阮一峰老师的《ES6标准入门》第二版之后，所做的阅读笔记的整理。 系列博客将采用一个一个的样例，来说明书中的精华部分（当然，这只是我认为的），同时引导新手，快速入门ES6，并逐步将其投入到生产实践中。
    
    </summary>
    
      <category term="ES6标准入门" scheme="https://github.com/ChangerHe/categories/ES6%E6%A0%87%E5%87%86%E5%85%A5%E9%97%A8/"/>
    
    
      <category term="ES6" scheme="https://github.com/ChangerHe/tags/ES6/"/>
    
      <category term="Class" scheme="https://github.com/ChangerHe/tags/Class/"/>
    
  </entry>
  
  <entry>
    <title>记一次简单的Nodejs爬虫</title>
    <link href="https://github.com/ChangerHe/2017/07/13/%E8%AE%B0%E4%B8%80%E6%AC%A1%E7%AE%80%E5%8D%95%E7%9A%84Nodejs%E7%88%AC%E8%99%AB/"/>
    <id>https://github.com/ChangerHe/2017/07/13/记一次简单的Nodejs爬虫/</id>
    <published>2017-07-13T10:32:57.000Z</published>
    <updated>2017-09-27T09:13:27.086Z</updated>
    
    <content type="html"><![CDATA[<p>作为初学nodejs的小学森, 不玩一把爬虫真的都不好意思说自己学过nodejs</p>
<p>所以, 本次教程本着严谨的教学角度, 向大家传授一下严谨的老司机绝技</p>
<p>学完之后, 自己写点儿小程序, 爬一爬某些不可描述的小图片啊, 小电影啊什么的, 也是可以的</p>
<p>所以我要在这里再次重申一下啊, 这真的是一篇严谨的教学博客</p>
<p>一入*门深似海, 从此节操是路人</p>
<h1 id="准备工作"><a href="#准备工作" class="headerlink" title="准备工作"></a>准备工作</h1><p>看到这篇博客时, 默认您已经掌握了nodejs的基本知识以及模块化的相关理念, 以及npm包管理的简单使用方法(也就一个cmd命令, npm i),所以基本上是看一遍之后就可以非常简单的上手的.</p>
<p>本次的数据库是直接使用的mongoDB, 简单上手,值得拥有.</p>
<h2 id="mongoDB的配置"><a href="#mongoDB的配置" class="headerlink" title="mongoDB的配置"></a>mongoDB的配置</h2><p>这个下载就不用说了吧, 老司机都知道上度娘.</p>
<p>关键是配置这块, 安装好之后,我们在项目的文件夹下创建一个db文件夹, 当然,项目文件夹是要存储你待会儿写的代码用的,新建一个就好</p>
<p>下好之后, 可以启动cmd(win + r, 然后回车) 输入mongo</p>
<p>输完了吗? 是不是没有看到结果? </p>
<p>没有结果就对了,因为我没教你配置环境变量啊</p>
<h3 id="配置环境变量"><a href="#配置环境变量" class="headerlink" title="配置环境变量"></a>配置环境变量</h3><p>首先,进入安装目录的bin文件夹,比如我是直接在安装的时候全部点的下一步,所以我的安装目录在<code>C:\Program Files\MongoDB\Server\3.2\bin</code>, 找到这个地方之后,在地址栏, 将这个文件路径复制下来,粘贴到环境变量的对应地方</p>
<p>环境变量的位置在: 我的电脑右键&gt; 属性 &gt; 高级系统设置 &gt; 环境变量 &gt; 管理员的用户变量</p>
<p>注意不要动系统变量,不然一旦操作不慎是会造成系统宕机的. </p>
<p>我们在用户变量的PATH中,鼠标光标点到最后,在它后面插上一个小分号</p>
<p>哎, 怎么有了一种邪恶的感觉</p>
<p>咳咳~ 插进去之后, 将我们之前bin目录的文件路径复制上去,然后确定</p>
<p>现在我们要做一下简单的配置让mongoDB启动起来:</p>
<p><code>mongod  --storageEngine mmapv1 --dbpath &quot;d:\mongodb\db&quot; --logpath &quot;d:\mongodb\log\MongoDB.log</code></p>
<p>下面详细讲一下配置的参数:</p>
<blockquote>
<p><code>mongod</code> mongoDB的命令,这个不用说</p>
<p><code>--storageEngine mmapv1</code> 这是一个比较老的mongoDB的存储引擎, 32位系统的童鞋需要有这条命令, 64位系统的可以不用, </p>
<p><code>--dbpath &quot;d:\mongodb\db&quot;</code> 数据库路径,找到项目文件夹, 把自己的项目文件夹的db路径替换掉上面的路径</p>
<p><code>--logpath &quot;d:\mongodb\log\MongoDB.log</code> 日志路径,一般我们会放在和db一起, 也是一样的, 把自己的log文件夹的路径替换掉上面的路径,因为刚开始是没有MongoDB.log这个文件的,所以需要新建一个.</p>
</blockquote>
<p>执行成功之后,如果没有看到ERROR的提示, 那么恭喜你,mongo的服务已经成功启动了, 报错的可以再往上翻一下是不是有步骤遗漏, 因为我也是纯手工码字, 难免可能自己也有遗漏的地方, 确实不懂的地方也可以度娘或google</p>
<p>以上,mongo的配置就搞定了,mongo服务默认跑在27017端口, 如果不需要长期使用, 保持cmd挂起服务就正常运行的, 记住不能关掉哦</p>
<p>如果需要长期使用mongo服务的, 可以将mongo服务设置为系统服务,开机即启动, 可以在cmd中执行以下代码, 用于创建mongo服务进程</p>
<p><code>mongod  --storageEngine mmapv1 --dbpath &quot;d:\mongodb\db&quot; --logpath &quot;d:\mongodb\log\MongoDB.log&quot; --install --serviceName &quot;MongoDB&quot;</code></p>
<p>这个是mongo的指令,所以要在cmd状态下,不要在mongo的交互状态下执行这个命令,否则会报错的</p>
<p>完成以上指令, 就已经成功创建了系统服务了, 我们现在来启动它, 在cmd中输入:</p>
<p><code>NET START MongoDB</code></p>
<p>提示服务器启动成功, bongo~</p>
<h1 id="安装依赖"><a href="#安装依赖" class="headerlink" title="安装依赖"></a>安装依赖</h1><p>进入项目文件夹, 在cmd中输入<code>npm init</code> 创建一个json文件, 然后使用<code>npm i *</code> 一次安装express, cheerio, mongoose, superagent这几个依赖, 所以需要将指令中的<code>*</code>改为以上的依赖名称</p>
<p>万事俱备只欠东风了, 我们新建一个app.js文件, 并引入刚刚安装的依赖</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">var express = require(&apos;express&apos;)</div><div class="line">var cheerio = require(&apos;cheerio&apos;)</div><div class="line">var superagent = require(&apos;superagent&apos;)</div><div class="line">var mongoose = require(&apos;mongoose&apos;)</div></pre></td></tr></table></figure>
<p>下面来大概说明一下这几个模块的作用</p>
<blockquote>
<p>express: 一个极简快速灵活的web开发框架, 用来快速搭建web服务器的</p>
<p>cheerio: nodejs中的jQuery</p>
<p>superagent 用来做客户端请求代理的, 直接点儿说就是代我们上网站拉网页代码的</p>
<p>mongoose: 用来连接mongoDB和处理mongo的请求</p>
</blockquote>
<p>好了解完之后,我们要正式开始写代码了</p>
<p>首先一步,还是连接mongo数据库, 不然我们趴下来的数据就没地儿存了</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line">// 连接到mongoDB数据库,端口是27017, 我们将内容存储在cnodejs这个数据库中</div><div class="line">mongoose.connect(&apos;mongodb://localhost:27017/cnodejs&apos;,function(err) &#123;</div><div class="line">    if(err) &#123;</div><div class="line">        throw err</div><div class="line">    &#125; else &#123;</div><div class="line">        console.log(&apos;服务器连接成功...&apos;)</div><div class="line">    &#125;</div><div class="line">&#125;)</div><div class="line"></div><div class="line">// 实例化一个骨架,定义我们要传入的内容的键名及键值</div><div class="line">var schema = new mongoose.Schema(&#123;</div><div class="line">    title: String,</div><div class="line">    href: String</div><div class="line">&#125;)</div><div class="line"></div><div class="line">// 定义一个模型变量, 我们将模型名称定义为List, 将爬取的内容存储在list这个文档中</div><div class="line">var model = mongoose.model(&apos;List&apos;, schema, &apos;list&apos;)</div></pre></td></tr></table></figure>
<p>然后,我们再实例一个express, 方便我们进行操作</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">var app = express()</div></pre></td></tr></table></figure>
<p>使用代码来进行抓取</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div></pre></td><td class="code"><pre><div class="line">app.get(&apos;/&apos;, function(req, res, next)&#123;</div><div class="line">    // 使用superagent去抓取https://cnodejs.org的内容</div><div class="line">    superagent.get(&apos;https://cnodejs.org/&apos;).end(function(err, sres)&#123;</div><div class="line">        // 常规的错误处理</div><div class="line">        if(err) return next(err)</div><div class="line">		</div><div class="line">        // sres.text里面存储着网页的html内容, 将它传给cheerio.load之后</div><div class="line">		//就可以得到一个实现了jQuery接口的变量,我们习惯性将其命名为 &apos;$&apos;</div><div class="line">        var $ = cheerio.load(sres.text)</div><div class="line">		</div><div class="line">        var items = []</div><div class="line"></div><div class="line">        // 使用cheerio获取到爬取到的东西的内容</div><div class="line">        $(&apos;#topic_list .topic_title&apos;).each((idx, element)=&gt; &#123;</div><div class="line">		</div><div class="line">            // 预定义一个变量,从而提升整体的程序性能</div><div class="line">            var $element = $(element);</div><div class="line">			</div><div class="line">            var listModel = new model()</div><div class="line">			</div><div class="line">            listModel.title = $element.attr(&apos;title&apos;)</div><div class="line">			</div><div class="line">            listModel.href = $element.attr(&apos;href&apos;)</div><div class="line">			</div><div class="line">			// 将内容保存到数据库</div><div class="line">            listModel.save((err) =&gt; &#123;</div><div class="line">                if(err) &#123;</div><div class="line">                    throw err</div><div class="line">                &#125; else &#123;</div><div class="line">                    console.log(&apos;保存成功...&apos;)</div><div class="line">                &#125;</div><div class="line">            &#125;)</div><div class="line">        &#125;)</div><div class="line">    &#125;)</div><div class="line">&#125;)</div></pre></td></tr></table></figure>
<p>最后一步, 指定服务器的监听端口</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">app.listen(8090, function(err) &#123;</div><div class="line">	if(err) &#123;</div><div class="line">		throw err</div><div class="line">	&#125; else &#123;</div><div class="line">		console.log(&apos;服务器启动成功.. &apos;)	</div><div class="line">	&#125;</div><div class="line">&#125;)</div></pre></td></tr></table></figure>
<p>全部搞定,我们使用cmd输入命令 node app 或者使用webstorm的ctrl + f9启动一下</p>
<p>到浏览器中,输入刚刚设置的本地服务器加端口号: <code>localhost:8090</code> </p>
<p>回来一看,我靠,好多的保存成功啊</p>
<p>至此,我们的爬取工作就已经全部完成了, 看下成果呗:</p>
<h1 id="在mongoDB中查看自己的爬取结果"><a href="#在mongoDB中查看自己的爬取结果" class="headerlink" title="在mongoDB中查看自己的爬取结果"></a>在mongoDB中查看自己的爬取结果</h1><p>如果不想麻烦的话, 可以直接安装一个ROBO 3T, 傻瓜式操作</p>
<p>也可以自己输入指令查看</p>
<p>在cmd中输入mongo, 进入mongo的交互</p>
<p>输入指令: <code>use cnodejs</code> 转到我们的cnodejs这个数据库中</p>
<p>然后输入指令: ‘db.list.find().pretty()’ 爬取的结果就都出来了</p>
<h1 id="结束"><a href="#结束" class="headerlink" title="结束"></a>结束</h1><p>爬取的过程至此圆满结束</p>
<p>当然, 作为一个负责任的老司机, 怎么可能会不告诉你, 爬取出来的小电影小图片怎么看呢.</p>
<p>很简单, 使用ejs或者handlebars这类的模板引擎, 将数据库的内容渲染出来就好了</p>
]]></content>
    
    <summary type="html">
    
      作为初学nodejs的小学森, 不玩一把爬虫真的都不好意思说自己学过nodejs. 所以, 本次教程本着严谨的教学角度, 向大家传授一下严谨的老司机绝技
    
    </summary>
    
      <category term="Nodejs学习笔记" scheme="https://github.com/ChangerHe/categories/Nodejs%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="Nodejs" scheme="https://github.com/ChangerHe/tags/Nodejs/"/>
    
      <category term="爬虫" scheme="https://github.com/ChangerHe/tags/%E7%88%AC%E8%99%AB/"/>
    
  </entry>
  
  <entry>
    <title>《ES6标准入门》阅读笔记——-Promise</title>
    <link href="https://github.com/ChangerHe/2017/07/11/%E3%80%8AES6%E6%A0%87%E5%87%86%E5%85%A5%E9%97%A8%E3%80%8B%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0%E2%80%94%E2%80%94-Promise/"/>
    <id>https://github.com/ChangerHe/2017/07/11/《ES6标准入门》阅读笔记——-Promise/</id>
    <published>2017-07-11T14:23:54.000Z</published>
    <updated>2017-09-18T00:42:09.303Z</updated>
    
    <content type="html"><![CDATA[<h1 id="写在前面"><a href="#写在前面" class="headerlink" title="写在前面"></a>写在前面</h1><p>本系列为在我读完阮一峰老师的《ES6标准入门》第二版之后，所做的阅读笔记的整理。</p>
<p>许多初学ES6, 同时和我一样初次阅读阮老师的这本书的时候, 读第一遍会越发的困惑, 因为阮老师上面说的很多的定义,方法,之前都是没有见过的, 读到后面才发现, 哦~原来是这样.</p>
<p>有一句话叫做”大神的世界我们不懂”, 所以我在初读第一遍《ES6标准入门》这本书的时候,也是踩了不少坑,读书的时候查阅了不少的资料.</p>
<p>所以,在这一系列的笔记教程中,我会从一个初学者的角度,向您讲述ES6的相关知识,在后面介绍的知识我会尽量不提前用,即使提前使用,也会同时做好标注,避免了阅读时各种查阅资料的烦恼.</p>
<p>系列博客将采用一个一个的样例，来说明书中的精华部分（当然，这只是我认为的），同时引导新手，快速入门ES6，并逐步将其投入到生产实践中。</p>
<p>同时,在阅读前也提醒您, 为了系统连贯性的学习ES6的基础知识,建议您从我的博客第一章开始阅读,当然,如果您对对应的知识已经有所了解,那么可以跳转到任意章节阅读,每一篇博客名中均有介绍该博客中涉及到的ES6的内容.</p>
<p>阮一峰老师的这本书是开源的，在其官方博客就可以下载到，但是我强烈建议大家去购买一本书, 一是方便自己查阅ES6中新增的众多API, 二也是表达一下对大神的敬仰.</p>
]]></content>
    
    <summary type="html">
    
      本系列为在我读完阮一峰老师的《ES6标准入门》第二版之后，所做的阅读笔记的整理。 系列博客将采用一个一个的样例，来说明书中的精华部分（当然，这只是我认为的），同时引导新手，快速入门ES6，并逐步将其投入到生产实践中。
    
    </summary>
    
      <category term="ES6标准入门" scheme="https://github.com/ChangerHe/categories/ES6%E6%A0%87%E5%87%86%E5%85%A5%E9%97%A8/"/>
    
    
      <category term="ES6" scheme="https://github.com/ChangerHe/tags/ES6/"/>
    
      <category term="Promise" scheme="https://github.com/ChangerHe/tags/Promise/"/>
    
  </entry>
  
  <entry>
    <title>《ES6标准入门》阅读笔记——-Iterator和Generator</title>
    <link href="https://github.com/ChangerHe/2017/07/07/%E3%80%8AES6%E6%A0%87%E5%87%86%E5%85%A5%E9%97%A8%E3%80%8B%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0%E2%80%94%E2%80%94-Iterator%E5%92%8CGenerator/"/>
    <id>https://github.com/ChangerHe/2017/07/07/《ES6标准入门》阅读笔记——-Iterator和Generator/</id>
    <published>2017-07-07T15:11:34.000Z</published>
    <updated>2017-09-18T00:42:03.573Z</updated>
    
    <content type="html"><![CDATA[<h1 id="写在前面"><a href="#写在前面" class="headerlink" title="写在前面"></a>写在前面</h1><p>本系列为在我读完阮一峰老师的《ES6标准入门》第二版之后，所做的阅读笔记的整理。</p>
<p>许多初学ES6, 同时和我一样初次阅读阮老师的这本书的时候, 读第一遍会越发的困惑, 因为阮老师上面说的很多的定义,方法,之前都是没有见过的, 读到后面才发现, 哦~原来是这样.</p>
<p>有一句话叫做”大神的世界我们不懂”, 所以我在初读第一遍《ES6标准入门》这本书的时候,也是踩了不少坑,读书的时候查阅了不少的资料.</p>
<p>所以,在这一系列的笔记教程中,我会从一个初学者的角度,向您讲述ES6的相关知识,在后面介绍的知识我会尽量不提前用,即使提前使用,也会同时做好标注,避免了阅读时各种查阅资料的烦恼.</p>
<p>系列博客将采用一个一个的样例，来说明书中的精华部分（当然，这只是我认为的），同时引导新手，快速入门ES6，并逐步将其投入到生产实践中。</p>
<p>同时,在阅读前也提醒您, 为了系统连贯性的学习ES6的基础知识,建议您从我的博客第一章开始阅读,当然,如果您对对应的知识已经有所了解,那么可以跳转到任意章节阅读,每一篇博客名中均有介绍该博客中涉及到的ES6的内容.</p>
<p>阮一峰老师的这本书是开源的，在其官方博客就可以下载到，但是我强烈建议大家去购买一本书, 一是方便自己查阅ES6中新增的众多API, 二也是表达一下对大神的敬仰.</p>
]]></content>
    
    <summary type="html">
    
      本系列为在我读完阮一峰老师的《ES6标准入门》第二版之后，所做的阅读笔记的整理。 系列博客将采用一个一个的样例，来说明书中的精华部分（当然，这只是我认为的），同时引导新手，快速入门ES6，并逐步将其投入到生产实践中。
    
    </summary>
    
      <category term="ES6标准入门" scheme="https://github.com/ChangerHe/categories/ES6%E6%A0%87%E5%87%86%E5%85%A5%E9%97%A8/"/>
    
    
      <category term="ES6" scheme="https://github.com/ChangerHe/tags/ES6/"/>
    
      <category term="Iterator" scheme="https://github.com/ChangerHe/tags/Iterator/"/>
    
      <category term="Generator" scheme="https://github.com/ChangerHe/tags/Generator/"/>
    
  </entry>
  
  <entry>
    <title>《ES6标准入门》阅读笔记——-set和map</title>
    <link href="https://github.com/ChangerHe/2017/07/03/%E3%80%8AES6%E6%A0%87%E5%87%86%E5%85%A5%E9%97%A8%E3%80%8B%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0%E2%80%94%E2%80%94-set%E5%92%8Cmap/"/>
    <id>https://github.com/ChangerHe/2017/07/03/《ES6标准入门》阅读笔记——-set和map/</id>
    <published>2017-07-03T03:37:44.000Z</published>
    <updated>2017-10-09T09:51:25.926Z</updated>
    
    <content type="html"><![CDATA[<h1 id="写在前面"><a href="#写在前面" class="headerlink" title="写在前面"></a>写在前面</h1><p>本系列为在我读完阮一峰老师的《ES6标准入门》第二版之后，所做的阅读笔记的整理。</p>
<p>许多初学ES6, 同时和我一样初次阅读阮老师的这本书的时候, 读第一遍会越发的困惑, 因为阮老师上面说的很多的定义,方法,之前都是没有见过的, 读到后面才发现, 哦~原来是这样.</p>
<p>有一句话叫做”大神的世界我们不懂”, 所以我在初读第一遍《ES6标准入门》这本书的时候,也是踩了不少坑,读书的时候查阅了不少的资料.</p>
<p>所以,在这一系列的笔记教程中,我会从一个初学者的角度,向您讲述ES6的相关知识,在后面介绍的知识我会尽量不提前用,即使提前使用,也会同时做好标注,避免了阅读时各种查阅资料的烦恼.</p>
<p>系列博客将采用一个一个的样例，来说明书中的精华部分（当然，这只是我认为的），同时引导新手，快速入门ES6，并逐步将其投入到生产实践中。</p>
<p>同时,在阅读前也提醒您, 为了系统连贯性的学习ES6的基础知识,建议您从我的博客第一章开始阅读,当然,如果您对对应的知识已经有所了解,那么可以跳转到任意章节阅读,每一篇博客名中均有介绍该博客中涉及到的ES6的内容.</p>
<p>阮一峰老师的这本书是开源的，在其官方博客就可以下载到，但是我强烈建议大家去购买一本书, 一是方便自己查阅ES6中新增的众多API, 二也是表达一下对大神的敬仰.</p>
<h1 id="Set"><a href="#Set" class="headerlink" title="Set"></a>Set</h1><p>ES6提供了一种新的数据结构Set,类似于数组,但成员值是唯一的,没有重复值. set本身是一个构造函数,用来生成set数据结构</p>
<p>因此, 利用set这个结构的特性, 就可以很容易地进行数组去重了</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">let s = new Set();</div><div class="line">let a = [1, 2, 3, 4, 5, 5, 6, 2, 12, 53, 34, 5, 1, 2, 5, 3, 1, 1].map(x =&gt; s.add(x))</div><div class="line">console.log(...s)  // 1 2 3 4 5 6 12 53 34</div></pre></td></tr></table></figure>
<p>向set加入值的时候不会发生类型转换,所以 5 和 ‘5’ 是两个不同的值</p>
<p>在set内部判断两数是否相等使用的是精确相等运算符, 也就是说,当我们比较对象是否相等的时候,两个不同引用空间的对象是永远不相等的</p>
<p>有一个例外是,当我们使用NaN的时候,会发现两个NaN其实是相等的,而在ES5的时候NaN会被认为是一个Object从而判定两者不相等</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">let set = new Set([1, 2, 3, NaN, NaN])</div><div class="line">console.log(set.size)  // 4</div><div class="line">set.add(&#123;&#125;)</div><div class="line">set.add(&#123;&#125;)</div><div class="line">console.log(set.size)  // 6</div></pre></td></tr></table></figure>
<p>由上面的打印结果很明显的能看到, 两个NaN是相等的, 但是两个对象是不等的</p>
<p>set结构的实例是默认可遍历的</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">let set = new Set([&apos;red&apos;, &apos;green&apos;, &apos;blue&apos;])</div><div class="line">for (let x of set) &#123;</div><div class="line">	console.log(x) // red green blue</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>由于扩展运算符内部使用for…of循环,所以也可以用于set结构</p>
<h1 id="set的使用技巧"><a href="#set的使用技巧" class="headerlink" title="set的使用技巧"></a>set的使用技巧</h1><p>利用set可以很容易地实现并集 交集 差集的操作</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">let a = new Set([1, 2, 3])</div><div class="line">let b = new Set([2, 3, 4])</div><div class="line"></div><div class="line">// 求并集</div><div class="line">let union = new Set([...a, ...b])</div><div class="line">console.log(union)  // Set(4) &#123;1, 2, 3, 4&#125;</div><div class="line"></div><div class="line">// 求交集</div><div class="line">let intersect = new Set([...a].filter(x =&gt; b.has(x)))</div><div class="line">console.log(intersect) // Set(2) &#123;2, 3&#125;</div><div class="line"></div><div class="line">// 求差集</div><div class="line">let difference = new Set([...a].filter(x =&gt; !b.has(x)))</div><div class="line">console.log(difference) // Set(1) &#123;1&#125;</div></pre></td></tr></table></figure>
<h1 id="WeakSet"><a href="#WeakSet" class="headerlink" title="WeakSet"></a>WeakSet</h1><p>WeakSet的结构和Set类似,也是不重复的值的集合.但是,它与Set有两个区别</p>
<ul>
<li><ol>
<li>weakset成员只能是对象,不能是其他类型的值</li>
</ol>
</li>
<li><ol>
<li>weakset对象都是弱引用,即垃圾回收机制不考虑</li>
</ol>
</li>
</ul>
<p>weakset对该对象的引用,如果其他对象都不再引用该对象,那么该对象就会被GC回收.  </p>
<p>这一特点意味着无法引用weakset的成员,因此weakset是不可遍历的</p>
<h1 id="Map"><a href="#Map" class="headerlink" title="Map"></a>Map</h1><p>javascript的对象本质上是键值对的集合,但是只能用字符串作为键名</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">let data = &#123;&#125;</div><div class="line">let element = document.getElementById(&apos;myDiv&apos;)</div><div class="line"></div><div class="line">data[element] = metadata // 报错</div><div class="line"></div><div class="line">console.log(data[&apos;[Object HTMLElement]&apos;])</div></pre></td></tr></table></figure>
<p>ES6提供了Map数据结构,它类似于对象,也是键值对的集合,但是键的范围不限于字符串,各种类型的值都可以当做键名</p>
<p>因此,map是比object更加合适的键值对结构</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">let m = new Map()</div><div class="line">let o = &#123;</div><div class="line">	p: &apos;Hello world&apos;</div><div class="line">&#125;</div><div class="line">m.set(o, &apos;content&apos;)</div><div class="line">console.log(m.get(o))  // content</div><div class="line"></div><div class="line">console.log(m.has(o))  // true</div><div class="line">console.log(m.delete(o))  // true</div><div class="line">console.log(m.has(o))  // false</div></pre></td></tr></table></figure>
<p>另外有一点需要注意的是,map的键是和内存地址绑定的,只要内存地址不一样,那么就会被视为两个键, 这样就解决了同名属性的碰撞问题</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">let map = new Map()</div><div class="line"></div><div class="line">let k1 = [&apos;a&apos;]</div><div class="line">let k2 = [&apos;a&apos;]</div><div class="line"></div><div class="line">map.set(k1, 111)</div><div class="line">map.set(k2, 222)</div><div class="line"></div><div class="line">console.log(map.get(k1))  // 111</div><div class="line">console.log(map.get(k2))  // 222</div></pre></td></tr></table></figure>
<p>那么同样的,当我们使用简单数据类型时,只要两值完全相等,map就将其视为一个键</p>
<p>包括+0 和 -0 , 以及NaN</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">let map = new Map()</div><div class="line"></div><div class="line">map.set(NaN, 123)</div><div class="line">console.log(map.get(NaN)) // 123</div><div class="line"></div><div class="line">map.set(-0, 321)</div><div class="line">console.log(map.get(+0))  // 321</div></pre></td></tr></table></figure>
<p>map结构转为数组结构比较方便的方法就是使用三点运算符,或者说是扩展运算符,或者说是rest参数</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">let map = new Map([</div><div class="line">	[1, &apos;one&apos;],</div><div class="line">	[2, &apos;two&apos;],</div><div class="line">	[3, &apos;three&apos;]</div><div class="line">])</div><div class="line"></div><div class="line">console.log([...map.keys()])</div><div class="line">// 1  2  3</div><div class="line">console.log([...map.values()])</div><div class="line">// &quot;one&quot;  &quot;two&quot;  &quot;three&quot;</div><div class="line">console.log([...map.entries()])</div><div class="line">// [1, &quot;one&quot;]  [2, &quot;two&quot;]  [3, &quot;three&quot;]</div><div class="line">console.log([...map]) </div><div class="line">// [1, &quot;one&quot;]  [2, &quot;two&quot;]  [3, &quot;three&quot;]</div></pre></td></tr></table></figure>
<h1 id="WeakMap"><a href="#WeakMap" class="headerlink" title="WeakMap"></a>WeakMap</h1><p>Weakmap的结构和map结构基本类似,但是weakmap只接受对象作为键名,不接受其他类型的值作为键名</p>
<p>weakmap的应用典型场景就是在DOM节点作为键名的时候</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">let myElement = document.getElementById(&apos;logo&apos;)</div><div class="line">let myWeakmap = new WeakMap()</div><div class="line"></div><div class="line">myWeakmap.set(myElement, &#123;</div><div class="line">	timesClicked: 0</div><div class="line">&#125;)</div><div class="line"></div><div class="line">myElement.addEventListener(&apos;click&apos;, () =&gt; &#123;</div><div class="line">	let logoData = myWeakmap.get(myElement)</div><div class="line">	logoData.timesClicked++</div><div class="line">		myWeakmap.set(myElement, logoData)</div><div class="line">&#125;, false)</div></pre></td></tr></table></figure>
<p>(完)</p>
]]></content>
    
    <summary type="html">
    
      本系列为在我读完阮一峰老师的《ES6标准入门》第二版之后，所做的阅读笔记的整理。 系列博客将采用一个一个的样例，来说明书中的精华部分（当然，这只是我认为的），同时引导新手，快速入门ES6，并逐步将其投入到生产实践中。
    
    </summary>
    
      <category term="ES6标准入门" scheme="https://github.com/ChangerHe/categories/ES6%E6%A0%87%E5%87%86%E5%85%A5%E9%97%A8/"/>
    
    
      <category term="ES6" scheme="https://github.com/ChangerHe/tags/ES6/"/>
    
      <category term="set" scheme="https://github.com/ChangerHe/tags/set/"/>
    
      <category term="map" scheme="https://github.com/ChangerHe/tags/map/"/>
    
  </entry>
  
  <entry>
    <title>《ES6标准入门》阅读笔记——-symbol及proxy/reflect</title>
    <link href="https://github.com/ChangerHe/2017/07/01/%E3%80%8AES6%E6%A0%87%E5%87%86%E5%85%A5%E9%97%A8%E3%80%8B%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0%E2%80%94%E2%80%94-symbol%E5%8F%8Aproxy-reflect/"/>
    <id>https://github.com/ChangerHe/2017/07/01/《ES6标准入门》阅读笔记——-symbol及proxy-reflect/</id>
    <published>2017-07-01T05:51:28.000Z</published>
    <updated>2017-10-09T09:10:47.950Z</updated>
    
    <content type="html"><![CDATA[<h1 id="写在前面"><a href="#写在前面" class="headerlink" title="写在前面"></a>写在前面</h1><p>本系列为在我读完阮一峰老师的《ES6标准入门》第二版之后，所做的阅读笔记的整理。</p>
<p>许多初学ES6, 同时和我一样初次阅读阮老师的这本书的时候, 读第一遍会越发的困惑, 因为阮老师上面说的很多的定义,方法,之前都是没有见过的, 读到后面才发现, 哦~原来是这样.</p>
<p>有一句话叫做”大神的世界我们不懂”, 所以我在初读第一遍《ES6标准入门》这本书的时候,也是踩了不少坑,读书的时候查阅了不少的资料.</p>
<p>所以,在这一系列的笔记教程中,我会从一个初学者的角度,向您讲述ES6的相关知识,在后面介绍的知识我会尽量不提前用,即使提前使用,也会同时做好标注,避免了阅读时各种查阅资料的烦恼.</p>
<p>系列博客将采用一个一个的样例，来说明书中的精华部分（当然，这只是我认为的），同时引导新手，快速入门ES6，并逐步将其投入到生产实践中。</p>
<p>同时,在阅读前也提醒您, 为了系统连贯性的学习ES6的基础知识,建议您从我的博客第一章开始阅读,当然,如果您对对应的知识已经有所了解,那么可以跳转到任意章节阅读,每一篇博客名中均有介绍该博客中涉及到的ES6的内容.</p>
<p>阮一峰老师的这本书是开源的，在其官方博客就可以下载到，但是我强烈建议大家去购买一本书, 一是方便自己查阅ES6中新增的众多API, 二也是表达一下对大神的敬仰.</p>
<h1 id="Symbol"><a href="#Symbol" class="headerlink" title="Symbol"></a>Symbol</h1><p>在ES6之前,当我们命名变量的时候,总是会担心,如果我把之前的变量改写了该怎么办呢</p>
<p>那么,现在ES6推出了继 null undefined string number boolean 这五中数据类型以外的第六种简单数据类型symbol</p>
<p>推出的主要目的在于,解决属性名冲突的问题</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">let s = Symbol()</div><div class="line">console.log(typeof s) // symbol</div></pre></td></tr></table></figure>
<p>symbol一般会传入一个字符串作为不同symbol实例的描述,方便进行区分</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">let a = Symbol(&apos;a&apos;)</div><div class="line">let b = Symbol(&apos;b&apos;)</div><div class="line">console.log(a, b)  // Symbol(a) Symbol(b)</div><div class="line">console.log(a.toString(), b.toString()) // Symbol(a) Symbol(b)</div></pre></td></tr></table></figure>
<p>我们查看控制台的打印结果,会发现symbol的值是以红色显示的,而普通字符串则以灰色显示</p>
<h2 id="symbol的几个特征"><a href="#symbol的几个特征" class="headerlink" title="symbol的几个特征"></a>symbol的几个特征</h2><blockquote>
<p>symbol函数的参数只表示对当前symbol值的表示,因此相同参数的symbol函数的返回值是不相等的</p>
<p>symbol无法与其他类型值进行运算,否则会报错</p>
<p>symbol可以转为布尔值,但是无法转为数值</p>
<p>symbol作为变量时,不能使用点运算符</p>
</blockquote>
<p>因为symbol是一个特殊的基本类型,因此使用点运算符是不行的,这样会被理解为是在使用字符串作为变量名称</p>
<p>那么这个时候,可以使用方括号加上symbol名称的方式,来调取这个symbol值</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">var mySymbol = Symbol(&apos;aaa&apos;)</div><div class="line">var a = &#123;&#125;</div><div class="line">a.mySymbol = &apos;hello&apos;</div><div class="line">console.log(a[mySymbol]) // undefined</div><div class="line">console.log(a.mySymbol) // hello</div><div class="line">console.log(a[&apos;mySymbol&apos;]) // hello</div><div class="line"></div><div class="line">let c = Symbol</div><div class="line">let d = c</div><div class="line">console.log(d, d === c) // ƒ Symbol() &#123; [native code] &#125; true</div></pre></td></tr></table></figure>
<h2 id="作为属性名的symbol"><a href="#作为属性名的symbol" class="headerlink" title="作为属性名的symbol"></a>作为属性名的symbol</h2><p>symbol作为属性名,该属性不会出现在for…in for…of 循环中,也不会被Object.keys()/Object.getOwnPropertyNames()返回</p>
<p>但它也不是私有属性,有一个Object.getOwnPropertSymbols方法可以获取指定对象的所有symbol属性名</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">var obj = &#123;&#125;</div><div class="line">var a = Symbol(&apos;a&apos;)</div><div class="line">var b = Symbol.for(&apos;b&apos;)</div><div class="line"></div><div class="line">obj[a] = &apos;hello&apos;</div><div class="line">obj[b] = &apos;world&apos;</div><div class="line"></div><div class="line">var objectSymbols = Object.getOwnPropertySymbols(obj)</div><div class="line">console.log(objectSymbols) // [Symbol(a), Symbol(b)]</div><div class="line"></div><div class="line">var symbolNames = Object.getOwnPropertyNames(obj)</div><div class="line">console.log(symbolNames) // []</div></pre></td></tr></table></figure>
<p>由以上可知,使用getOwnPropertySymbols() 方法可以得到对应的symbol值,而getOwnPropertyNames() 是得不到对应的symbol值的</p>
<h2 id="Reflect-ownKeys-obj"><a href="#Reflect-ownKeys-obj" class="headerlink" title="Reflect.ownKeys(obj)"></a>Reflect.ownKeys(obj)</h2><p>ES6中定义了一个新的API Reflect.ownKeys(obj) 可以返回所有类型的键名称,包括常规键名和symbol键名</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">let obj = &#123;</div><div class="line">	[Symbol(&apos;my_key&apos;)]: 1,</div><div class="line">	enum: 2,</div><div class="line">	nonEnum: 3</div><div class="line">&#125;</div><div class="line"></div><div class="line">console.log(Object.keys(obj)) // [&quot;enum&quot;, &quot;nonEnum&quot;]</div><div class="line"></div><div class="line">console.log(Reflect.ownKeys(obj)) </div><div class="line">//[&quot;enum&quot;, &quot;nonEnum&quot;, Symbol(my_key)]</div></pre></td></tr></table></figure>
<h2 id="Symbol-for-和-Symbol-keyFor"><a href="#Symbol-for-和-Symbol-keyFor" class="headerlink" title="Symbol.for() 和 Symbol.keyFor()"></a>Symbol.for() 和 Symbol.keyFor()</h2><p>有时候我们希望重新使用同一个symbol值, Symbol.for方法可以做到这一点,它接收一个字符串作为参数,然后搜索没有以该字符串作为名称的Symbol值. 如果有,就返回这个Symbol值, 否则就新建一个以该字符串为名称的Symbol值</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">let s1 = Symbol.for(&apos;foo&apos;)</div><div class="line">let s2 = Symbol.for(&apos;foo&apos;)</div><div class="line"></div><div class="line">console.log(s1 === s2) // true</div></pre></td></tr></table></figure>
<p>上面的代码中,虽然s1和s2都是Symbol值,但是它们都是同一个Symbol.for生成的,所以是同一个值</p>
<p>Symbol()和Symbol.for()两种写法,都会生成新的Symbol,但是后者会被登记在全局环境中供 搜索,但是前者不会</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">console.log(Symbol.for(&apos;bar&apos;) === Symbol.for(&apos;bar&apos;)) // true</div><div class="line">console.log(Symbol(&apos;bar&apos;) === Symbol(&apos;bar&apos;)) // false</div></pre></td></tr></table></figure>
<p>上面的代码中,由于Symbol()没有登记机制,所以每次调用都会返回不同的值</p>
<p>Symbol.keyFor()方法用于返回一个已经登记的Symbol类型值的key</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">let s3 = Symbol.for(&apos;aaa&apos;)</div><div class="line">let s4 = Symbol(&apos;bbb&apos;)</div><div class="line"></div><div class="line">console.log(Symbol.keyFor(s3)) // aaa</div><div class="line">console.log(Symbol.keyFor(s4)) // undefined</div></pre></td></tr></table></figure>
<h1 id="Proxy概述"><a href="#Proxy概述" class="headerlink" title="Proxy概述"></a>Proxy概述</h1><p>proxy 用于修改某些操作的默认行为,等同于在语言层面做出修改,所以属于一种元编程, 即对编程语言进行编程</p>
<p>Proxy 可以理解为在目标对象前架设一个拦截层,外界对该对象的访问都必须先通过这一层拦截,因此提供了一钟机制来对外界的访问进行过滤和改写</p>
<p>所以,Proxy 也可以理解为一种代理器</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">let obj = new Proxy(&#123;&#125;, &#123;</div><div class="line">	get: function(target, key, receiver) &#123;</div><div class="line">		console.log(`getting $&#123;key&#125;`)</div><div class="line">		return Reflect.get(target, key, receiver)</div><div class="line">	&#125;,</div><div class="line">	set: function(target, key, value, receiver) &#123;</div><div class="line">		console.log(`setting $&#123;key&#125;`)</div><div class="line">		return Reflect.set(target, key, value, receiver)</div><div class="line">	&#125;</div><div class="line">&#125;)</div><div class="line"></div><div class="line">obj.count = 1  // setting count   </div><div class="line">obj.count++  // getting count   setting count</div></pre></td></tr></table></figure>
<p>上面的代码说明, proxy实际上重载了点运算符, 即用自己的定义覆盖了语言的原始定义</p>
<p>一个小技巧是,可以将Proxy对象设置到object.proxy属性,从而可以在object对象上调用</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">var object = &#123;</div><div class="line">    proxy: new Proxy(target, handler)</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>那么我们就可以直接定义一个proxy对象,并在需要的时候使用Object.create() 进行对象的创建即可</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">var proxy = new Proxy(&#123;&#125;, &#123;</div><div class="line">	get: function(target, property) &#123;</div><div class="line">		return 35</div><div class="line">	&#125;</div><div class="line">&#125;)</div><div class="line"></div><div class="line">let obj = Object.create(proxy)</div><div class="line"></div><div class="line">console.log(obj.time)</div></pre></td></tr></table></figure>
<h1 id="Reflect"><a href="#Reflect" class="headerlink" title="Reflect"></a>Reflect</h1><p>Reflect对象和Proxy对象一样, 也是ES6为了操作对象而提供的新api</p>
<p>reflect对象的设计目的主要有以下几个</p>
<blockquote>
<p>将object对象的一些明显属于语言层面的方法放到reflect对象上. 现阶段, 某些方法同时在object和reflect对象上部署, 未来的新方法将只部署在reflect对象上</p>
<p>修改某些object方法的返回结果, 让其变得更加合理, 如:<code>Object.defineProperty(obj, name, desc)</code> 在无法定义属性时会抛出一个错误, 而<code>Reflect.defineProperty(obj, name, desc)</code>则会返回一个false</p>
<p>让Object操作都变成函数行为, 某些object操作是命令式, 比如<code>name in obj</code>和<code>delete obj[name]</code>, 而<code>Reflect.has(obj, name)</code>和Reflect.deleteProperty(obj, name)让他们变成了函数行为</p>
<p>Reflect对象的方法和Proxy对象的方法一一对应, 只要是Proxy对象的方法, 就能在Reflect对象上找到相应的方法. 也就是说, 不管Proxy怎么修改默认行为, 你总可以在Reflect上获取默认行为</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">Proxy(target, &#123;</div><div class="line">	set: function(target, name, value, receiver) &#123;</div><div class="line">		var success = Reflect.set(target, name, value, receiver)</div><div class="line">		if(success) &#123;</div><div class="line">			log(&apos;property &apos; + name + &apos; on &apos; + target + &apos; set to &apos; + value)</div><div class="line">		&#125;</div><div class="line">		return success </div><div class="line">	&#125;</div><div class="line">&#125;)</div></pre></td></tr></table></figure>
<p>上面的代码中,proxy方法拦截了target对象的属性赋值行为, 它采用<code>Reflect.set</code>方法赋值给对象的属性, 然后再部署额外的功能. </p>
<p>(完)</p>
]]></content>
    
    <summary type="html">
    
      本系列为在我读完阮一峰老师的《ES6标准入门》第二版之后，所做的阅读笔记的整理。 系列博客将采用一个一个的样例，来说明书中的精华部分（当然，这只是我认为的），同时引导新手，快速入门ES6，并逐步将其投入到生产实践中。
    
    </summary>
    
      <category term="ES6标准入门" scheme="https://github.com/ChangerHe/categories/ES6%E6%A0%87%E5%87%86%E5%85%A5%E9%97%A8/"/>
    
    
      <category term="ES6" scheme="https://github.com/ChangerHe/tags/ES6/"/>
    
      <category term="symbol" scheme="https://github.com/ChangerHe/tags/symbol/"/>
    
      <category term="proxy" scheme="https://github.com/ChangerHe/tags/proxy/"/>
    
      <category term="reflect" scheme="https://github.com/ChangerHe/tags/reflect/"/>
    
  </entry>
  
  <entry>
    <title>《ES6标准入门》阅读笔记——-对象的扩展</title>
    <link href="https://github.com/ChangerHe/2017/06/30/%E3%80%8AES6%E6%A0%87%E5%87%86%E5%85%A5%E9%97%A8%E3%80%8B%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0%E2%80%94%E2%80%94-%E5%AF%B9%E8%B1%A1%E7%9A%84%E6%89%A9%E5%B1%95/"/>
    <id>https://github.com/ChangerHe/2017/06/30/《ES6标准入门》阅读笔记——-对象的扩展/</id>
    <published>2017-06-30T05:49:33.000Z</published>
    <updated>2017-09-23T13:50:55.999Z</updated>
    
    <content type="html"><![CDATA[<h1 id="写在前面"><a href="#写在前面" class="headerlink" title="写在前面"></a>写在前面</h1><p>本系列为在我读完阮一峰老师的《ES6标准入门》第二版之后，所做的阅读笔记的整理。</p>
<p>许多初学ES6, 同时和我一样初次阅读阮老师的这本书的时候, 读第一遍会越发的困惑, 因为阮老师上面说的很多的定义,方法,之前都是没有见过的, 读到后面才发现, 哦~原来是这样.</p>
<p>有一句话叫做”大神的世界我们不懂”, 所以我在初读第一遍《ES6标准入门》这本书的时候,也是踩了不少坑,读书的时候查阅了不少的资料.</p>
<p>所以,在这一系列的笔记教程中,我会从一个初学者的角度,向您讲述ES6的相关知识,在后面介绍的知识我会尽量不提前用,即使提前使用,也会同时做好标注,避免了阅读时各种查阅资料的烦恼.</p>
<p>系列博客将采用一个一个的样例，来说明书中的精华部分（当然，这只是我认为的），同时引导新手，快速入门ES6，并逐步将其投入到生产实践中。</p>
<p>同时,在阅读前也提醒您, 为了系统连贯性的学习ES6的基础知识,建议您从我的博客第一章开始阅读,当然,如果您对对应的知识已经有所了解,那么可以跳转到任意章节阅读,每一篇博客名中均有介绍该博客中涉及到的ES6的内容.</p>
<p>阮一峰老师的这本书是开源的，在其官方博客就可以下载到，但是我强烈建议大家去购买一本书, 一是方便自己查阅ES6中新增的众多API, 二也是表达一下对大神的敬仰.</p>
<h1 id="属性的简洁表示法"><a href="#属性的简洁表示法" class="headerlink" title="属性的简洁表示法"></a>属性的简洁表示法</h1><p>ES6允许写入变量和函数作为对象的属性和方法, 也就是说,在ES6中是允许在对象中只写属性名,不写属性值的</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">var foo = &apos;bar&apos;</div><div class="line">var baz = &#123;foo&#125;</div><div class="line">console.log(baz) // &#123;foo: &quot;bar&quot;&#125;</div><div class="line"></div><div class="line">function f(x, y) &#123;</div><div class="line">	return &#123;x,y&#125;</div><div class="line">&#125;</div><div class="line">console.log(f(1, 2)) // &#123;x: 1, y: 2&#125;</div></pre></td></tr></table></figure>
<p>除了属性简写,方法也是可以简写的</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">var o = &#123;</div><div class="line">	method() &#123;</div><div class="line">		return &apos;Hello!&apos;</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>等价于</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">var o = &#123;</div><div class="line">	method: function() &#123;</div><div class="line">		return &apos;Hello&apos;</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>CommonJS的模块输出变量就非常适合使用简洁写法</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">var ms = &#123;&#125;</div><div class="line"></div><div class="line">function getItem(key) &#123;</div><div class="line">	return key in ms ? ms[key] : null</div><div class="line">&#125;</div><div class="line"></div><div class="line">function setItem(key, value) &#123;</div><div class="line">	ms[key] = value</div><div class="line">&#125;</div><div class="line"></div><div class="line">function clear() &#123;</div><div class="line">	ms = &#123;&#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">module.exports = &#123;getItem, setItem, clear&#125;</div></pre></td></tr></table></figure>
<p>上面代码的最后一句就等价于</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">module.exports = &#123;</div><div class="line">	getItem: getItem, </div><div class="line">	setItem: setItem,</div><div class="line">	clear: clear</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h1 id="属性名表达式"><a href="#属性名表达式" class="headerlink" title="属性名表达式"></a>属性名表达式</h1><p>ES6同时开放了使用表达式放在方括号内,作为字面量的方式定义对象</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">var obj = &#123;</div><div class="line">    [propkey]: true,</div><div class="line">    [&apos;a&apos; + &apos;bc&apos;]: 123</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h1 id="方法的name属性"><a href="#方法的name属性" class="headerlink" title="方法的name属性"></a>方法的name属性</h1><p>函数的name属性返回函数名,对象方法也是函数,因此也存在name属性</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">console.log((new Function()).name) //anonymous</div></pre></td></tr></table></figure>
<p>关于方法的name属性,存在以下几个特点</p>
<blockquote>
<p>正常的情况下,函数的函数体的name值返回函数的名称</p>
<p>当我们使用get或者set方法对函数进行描述的时候,会返回对应的前缀加上函数名</p>
<p>当我们使用bind方法创造的函数,函数会有一个bound来修饰</p>
<p>当使用构造函数来创造的函数中,name值固定为anonymous</p>
<p>如果对象的方法是一个symbol值, 那么那么属性返回的是这个symbol值的描述</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">const key1 = Symbol(&apos;description&apos;)</div><div class="line">const key2 = Symbol()</div><div class="line">let obj = &#123;</div><div class="line">	[key1]() &#123;&#125;,</div><div class="line">	[key2]() &#123;&#125;</div><div class="line">&#125;</div><div class="line">console.log(obj[key1].name) // &apos;[description]&apos;</div><div class="line">console.log(obj[key2].name) // &apos;&apos;</div></pre></td></tr></table></figure>
<h1 id="Object-is"><a href="#Object-is" class="headerlink" title="Object.is()"></a>Object.is()</h1><p>Object.is() 是ES6新定义的方法,用于确定传入的两个参数是否严格相等</p>
<p>但是, 与全等 === 符号唯一不同的地方是 +0不等于-0  NaN等于自身NaN</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">console.log(-0 === +0)  // true</div><div class="line">console.log(NaN === NaN) // false</div><div class="line"></div><div class="line">console.log(Object.is(-0, +0)) // false</div><div class="line">console.log(Object.is(NaN, NaN))  // true</div></pre></td></tr></table></figure>
<p>在ES5中可以部署对应的方法, 来模拟Object.is的效果</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">Object.defineProperty(Object, &apos;is&apos;, &#123;</div><div class="line">	value: function(x, y) &#123;</div><div class="line">		if (x === y) &#123;</div><div class="line">			return x !== 0 || 1 / x === 1 / y</div><div class="line">		&#125;</div><div class="line">		return x !== x &amp;&amp; y !== y</div><div class="line">	&#125;,</div><div class="line">	configurable: true,</div><div class="line">	enumerable: false,</div><div class="line">	writable: true</div><div class="line">&#125;)</div></pre></td></tr></table></figure>
<h1 id="Object-assign"><a href="#Object-assign" class="headerlink" title="Object.assign()"></a>Object.assign()</h1><p>Object.assign() 方法将源对象的所有可枚举属性复制到目标对象</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">let target = &#123;a: 1&#125;</div><div class="line">let source1 = &#123;b: 2&#125;</div><div class="line">let source2 = &#123;c: 3&#125;</div><div class="line"></div><div class="line">Object.assign(target, source1, source2)</div><div class="line">console.log(target) // &#123;a: 1, b: 2, c: 3&#125;</div></pre></td></tr></table></figure>
<p>同样的,Object.assign 方法可以用来复制数组,但是因为会将数组视为一个对象,所以后面数组的对应数组下标的值会覆盖之前的数组的下标的值</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">var a = [1, 2, 3]</div><div class="line">var b = [4, 5]</div><div class="line">Object.assign(a, b)</div><div class="line">console.log(a) // [4,5,3]</div></pre></td></tr></table></figure>
<p>使用Object.assign可以将原始对象赋值到一个空对象, 就得到了原始对象的克隆</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">function clone(origin) &#123;</div><div class="line">	return Object.assign(&#123;&#125;, origin)</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>通过将对象赋值到一个空对象的方式,获得了这个origin对象的克隆</p>
<p>不过,采用这种方法克隆,只能克隆原始对象自身的值,而不能克隆它继承的值</p>
<p>那么,如果想要获得保持原型链的对象,那么就需要使用这样的方法</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">function clone(origin) &#123;</div><div class="line">	let originProto = Object.getPrototypeOf(origin)</div><div class="line">	return Object.assign(Object.create(originProto), origin)</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>实现方式就是这样的,使用getPropertyOf方法获取了origin的原型,然后将函数体合并到原型中,并返回</p>
<p>当使用Object.assign() 对两个对象进行合并的时候,不论前面对应对象名称的内容是什么,其内容都会被替换掉</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">var target = &#123;</div><div class="line">	a: &#123;b: &apos;c&apos;,d: &apos;e&apos;&#125;</div><div class="line">&#125;</div><div class="line">var source = &#123;</div><div class="line">	a: &#123;b: &apos;hello&apos;&#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">Object.assign(target, source)</div><div class="line">console.log(target) // a:&#123;b: &quot;hello&quot;&#125;</div></pre></td></tr></table></figure>
<h1 id="属性的可枚举性"><a href="#属性的可枚举性" class="headerlink" title="属性的可枚举性"></a>属性的可枚举性</h1><p>ES6规定,所有class的原型的方法都是不可枚举的</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">var a = Object.getOwnPropertyDescriptor(</div><div class="line">	class &#123;</div><div class="line">		foo() &#123;&#125;</div><div class="line">	&#125;.prototype, &apos;foo&apos;</div><div class="line">).enumerable</div><div class="line">console.log(a) // false</div></pre></td></tr></table></figure>
<h1 id="proto属性"><a href="#proto属性" class="headerlink" title="proto属性"></a><strong>proto</strong>属性</h1><p><strong>proto</strong>属性用来读取或设置当前对象的prototype对象, 这个属性其实在很早版本的chrome Firefox Opera等现代浏览器中都已经得到了支持,被广泛用于查找原型上的方法和属性.</p>
<p>但是IE迟迟得不到支持,在ES6中,此属性被写到了规范中</p>
<p>让人欣喜的是,IE11开始,也支持此属性了</p>
<p>对应的, ES6也同时推出了Object.setPrototypeOf()方法, 该方法的作用与<strong>proto</strong>是相同的,只不过<strong>proto</strong>是一个内部方法, 因此TC39推荐使用Object.setPrototypeOf()来设置原型对象的方法.</p>
<h1 id="对象的扩展运算符"><a href="#对象的扩展运算符" class="headerlink" title="对象的扩展运算符"></a>对象的扩展运算符</h1><p>ES7有个提案, 将rest参数,也就是扩展运算符引入对象,目前babel已经支持</p>
<p>rest参数(扩展运算符) 用于从一个对象取值,相当于将所有可遍历但尚未被读取的键但尚未读取的属性,分配到指定的对象上,所有的键及相应的值都会被赋值到新对象上</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">let &#123;x, y, ...z&#125; = &#123;</div><div class="line">	x: 1,</div><div class="line">	a: 3,</div><div class="line">	y: 2,</div><div class="line">	b: 4,</div><div class="line">&#125;</div><div class="line">console.log(x) // 1</div><div class="line">console.log(y) // 2</div><div class="line">console.log(z) // &#123;a: 3, b: 4&#125;</div></pre></td></tr></table></figure>
<p>目前在Chrome中测试, 尚未支持上面的方法</p>
<p>有一点要注意的是,rest参数的复制是浅复制</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">let obj = &#123;a: &#123;b: 1&#125;&#125;</div><div class="line">let &#123;...x&#125; = obj</div><div class="line">obj.a.b = 2</div><div class="line">console.log(x.a.b) // 2</div></pre></td></tr></table></figure>
]]></content>
    
    <summary type="html">
    
      本系列为在我读完阮一峰老师的《ES6标准入门》第二版之后，所做的阅读笔记的整理。 系列博客将采用一个一个的样例，来说明书中的精华部分（当然，这只是我认为的），同时引导新手，快速入门ES6，并逐步将其投入到生产实践中。
    
    </summary>
    
      <category term="ES6标准入门" scheme="https://github.com/ChangerHe/categories/ES6%E6%A0%87%E5%87%86%E5%85%A5%E9%97%A8/"/>
    
    
      <category term="ES6" scheme="https://github.com/ChangerHe/tags/ES6/"/>
    
      <category term="Object" scheme="https://github.com/ChangerHe/tags/Object/"/>
    
  </entry>
  
  <entry>
    <title>《ES6标准入门》阅读笔记——-函数的扩展</title>
    <link href="https://github.com/ChangerHe/2017/06/28/%E3%80%8AES6%E6%A0%87%E5%87%86%E5%85%A5%E9%97%A8%E3%80%8B%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0%E2%80%94%E2%80%94-%E5%87%BD%E6%95%B0%E7%9A%84%E6%89%A9%E5%B1%95/"/>
    <id>https://github.com/ChangerHe/2017/06/28/《ES6标准入门》阅读笔记——-函数的扩展/</id>
    <published>2017-06-28T13:36:55.000Z</published>
    <updated>2017-09-23T13:13:22.892Z</updated>
    
    <content type="html"><![CDATA[<h1 id="写在前面"><a href="#写在前面" class="headerlink" title="写在前面"></a>写在前面</h1><p>本系列为在我读完阮一峰老师的《ES6标准入门》第二版之后，所做的阅读笔记的整理。</p>
<p>许多初学ES6, 同时和我一样初次阅读阮老师的这本书的时候, 读第一遍会越发的困惑, 因为阮老师上面说的很多的定义,方法,之前都是没有见过的, 读到后面才发现, 哦~原来是这样.</p>
<p>有一句话叫做”大神的世界我们不懂”, 所以我在初读第一遍《ES6标准入门》这本书的时候,也是踩了不少坑,读书的时候查阅了不少的资料.</p>
<p>所以,在这一系列的笔记教程中,我会从一个初学者的角度,向您讲述ES6的相关知识,在后面介绍的知识我会尽量不提前用,即使提前使用,也会同时做好标注,避免了阅读时各种查阅资料的烦恼.</p>
<p>系列博客将采用一个一个的样例，来说明书中的精华部分（当然，这只是我认为的），同时引导新手，快速入门ES6，并逐步将其投入到生产实践中。</p>
<p>同时,在阅读前也提醒您, 为了系统连贯性的学习ES6的基础知识,建议您从我的博客第一章开始阅读,当然,如果您对对应的知识已经有所了解,那么可以跳转到任意章节阅读,每一篇博客名中均有介绍该博客中涉及到的ES6的内容.</p>
<p>阮一峰老师的这本书是开源的，在其官方博客就可以下载到，但是我强烈建议大家去购买一本书, 一是方便自己查阅ES6中新增的众多API, 二也是表达一下对大神的敬仰.</p>
<h1 id="函数的默认值"><a href="#函数的默认值" class="headerlink" title="函数的默认值"></a>函数的默认值</h1><p>在ES6之前,函数的默认值只能在函数体内进行判断</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">function log(x, y) &#123;</div><div class="line">	y = y || &quot;world&quot;</div><div class="line">	console.log(x, y)</div><div class="line">&#125;</div><div class="line">log(&quot;hello &quot;) // hello world</div><div class="line">// 当我们采用ES5的写法时,是存在问题的,当我们给第二个参数传入布尔值为false的值的时候,实际上并不会使用这个值而是仍然使用默认值.</div><div class="line">log(&quot;hello &quot;, false) // hello world</div><div class="line">log(&quot;hello &quot;, &quot;&quot;) // hello world</div><div class="line">log(&quot;hello &quot;, undefined) // hello world</div></pre></td></tr></table></figure>
<p>在ES6中就不会有这个烦恼了,ES6允许将参数设置默认值,直接写在参数定义的后面即可</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">function log(x, y = &quot;world&quot;) &#123;</div><div class="line">	console.log(x, y)</div><div class="line">&#125;</div><div class="line">log(&quot;hello &quot;) // hello world</div><div class="line">log(&quot;hello &quot;, false) // hello false</div><div class="line">log(&quot;hello &quot;, &quot;&quot;) // hello </div><div class="line">log(&quot;hello &quot;, undefined) // hello world</div></pre></td></tr></table></figure>
<p>由此可见,ES6的写法比之前更加自然,也更加的语义化了.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">function Point(x = 0, y = 0) &#123;</div><div class="line">	this.x = x</div><div class="line">	this.y = y</div><div class="line">&#125;</div><div class="line">var p1 = new Point()</div><div class="line">console.log(p1.x, p1.x) // 0 0</div><div class="line"></div><div class="line">var p2 = new Point(2)</div><div class="line">console.log(p2.x, p2.y) // 2 0</div></pre></td></tr></table></figure>
<p>因为变量的参数是默认声明的,所以我们在内部重新使用let或const对变量声明的时候,是会报错的</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">function foo(x = 5) &#123;</div><div class="line">	let x = 1  // 报错</div><div class="line">	const x = 1  // 报错</div><div class="line">&#125;</div><div class="line"></div><div class="line">## 函数的默认值与解构赋值默认值结合使用</div></pre></td></tr></table></figure>
<p>function foo({x, y = 5}) {<br>    console.log(x, y)<br>}<br>foo({})  // undefined 5<br>foo({x: 1})  // 1 5<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">在为函数使用解构赋值时,因为有必填的参数,所以这个情况下必须要填需要的参数,否则会报错.</div><div class="line"></div><div class="line">但是当我们在这种情况下,如果不想让它报错的话,可以使用双重解赋值的方法解决此问题</div></pre></td></tr></table></figure></p>
<p>function fetch(url, {method = “GET”} = {}) {<br>    console.log(method)<br>}<br>fetch(“<a href="http://example.com" target="_blank" rel="external">http://example.com</a>“) // GET<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">## 解构赋值的默认值和函数默认值的区别</div></pre></td></tr></table></figure></p>
<p>function m1({x = 0, y = 0} = {}) {<br>    return [x, y]<br>}<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">以上代码将函数参数默认值设置为空对象, 但设置了对象解构赋值的默认值</div><div class="line"></div><div class="line">我们在来看一下下面的代码</div></pre></td></tr></table></figure></p>
<p>function m2({x, y} = {x: 0, y: 0}) {<br>    return [x, y]<br>}<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">在函数都有参数或都没有参数的情况下,两者是相等的</div></pre></td></tr></table></figure></p>
<p>m1() // [0, 0]<br>m2() // [0, 0]<br>m1({x: 3, y: 8}) // [3, 8]<br>m2({x: 3, y: 8}) // [3, 8]<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">但是在当一个有值,一个没有值的情况下,区别就显现出来了</div></pre></td></tr></table></figure></p>
<p>m1({x: 3}) // [3, 0]<br>m2({x: 3}) // [3, undefined]<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">当我们传入的是不同的对象的时候, m1的默认值为0, 所以, 会输出0, 而因为输入的对象与解构赋值的默认值不匹配,所以会输出undefined</div></pre></td></tr></table></figure></p>
<p>m1({z: 3})  // [0, 0]<br>m2({z: 3})  // [undefined, undefined]<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">当我们将非尾部的参数设置了默认值,那么这个时候这个参数是没有办法省略的</div></pre></td></tr></table></figure></p>
<p>function f(x = 1, y) {<br>    return [x, y]<br>}<br>console.log(f()) // [1, undefined]<br>console.log(f(1)) // [1, undefined]<br>console.log(f(, 1)) // 报错<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">## 参数默认值的位置</div><div class="line"></div><div class="line">通常情况下,定义了默认值的参数应该是函数的尾参数.</div><div class="line"></div><div class="line">因为这样比较容易看出到底省略了哪些参数,如果非尾部的参数设置默认值实际上这个参数是无法省略的.</div><div class="line"> </div><div class="line">换句话说,就是当中间设置了默认值,如果要给其后的非指定默认值参数设置值的话,必须要给这个参数设置值,或者显式的设置undefined或null, 否则会报错</div></pre></td></tr></table></figure></p>
<p>function f(x, y = 5, z) {<br>    return [x, y, z]<br>}<br>console.log(f())  // [undefined, 5, undefined]<br>console.log(f(1)) // [1, 5, undefined]<br>console.log(f(1, undefined, 3)) // [1, 5, 3]<br>console.log(f(1, , 2)) // 报错<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">## 函数的length属性</div><div class="line"></div><div class="line">指定了默认值后.函数的length属性将会返回没有指定默认值的参数个数,也就是说,指定了默认值后,length属性将会失真</div><div class="line"></div><div class="line">同时,经过测试,当我们设置默认值在前时,其实显示的形参个数是设置默认值的形参前面的形参个数,后面的形参个数是不计入在内的</div></pre></td></tr></table></figure></p>
<p>console.log((function(x) {}).length)  // 1<br>console.log((function(x = 90, a, b) {}).length) // 0<br>console.log((function(x, a = 90, b) {}).length) // 1<br>console.log((function(x, a, b = 90) {}).length) // 2<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">同样的,因为rest参数,也就是俗称的三点运算符的特殊性,其长度是不会计入length属性的</div></pre></td></tr></table></figure></p>
<p>console.log((function(…args){}).length)  // 0<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">## 函数的作用域</div><div class="line"></div><div class="line">一个需要注意的地方是,如果参数默认值是一个变量,则该变量所处的作用域与其他的变量的作用域是一样的,即先是当前函数的作用域,然后才是全局作用域</div></pre></td></tr></table></figure></p>
<p>let x = 1</p>
<p>function f(x, y = x) {<br>    console.log(y) // 2<br>}<br>f(2)<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">上面的代码中,参数的默认值等于x. 调用时, 由于函数作用域内部的变量x已经生成, 所以y等于参数x而不是全局变量x</div><div class="line"></div><div class="line">但当调用的时候函数作用域内部的变量x没有生成,那么x就会指向全局变量,因为全局变量中没有这个参数,所以y依然指向自身</div><div class="line"></div><div class="line">另外说明一下,这个和阮一峰老师的书中结果是不一致的,经过在chrome59版本下测试,结果为1</div></pre></td></tr></table></figure></p>
<p>function f1(y = x) {<br>    let x = 2<br>    console.log(y) // 1<br>}<br>f1(1)<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">## 函数的参数默认值的小应用</div><div class="line"></div><div class="line">引用参数默认值,可以指定某一个参数不得省略,否则会抛出一个错误</div></pre></td></tr></table></figure></p>
<p>throwIfMissing = () =&gt; {<br>    throw new Error(‘Missing parameter’)<br>}</p>
<p>function foo(mustBeProvided = throwIfMissing()) {<br>    return mustBeProvided<br>}</p>
<p>foo() // Error: Missing parameter<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"># rest参数(三点运算符)</div><div class="line"></div><div class="line">在ES6中引入了rest参数, 用于获取函数的多余参数,这样就不需要使用arguments对象了,rest参数搭配的变量是一个数组,该变量将多余的参数放入其中</div></pre></td></tr></table></figure></p>
<p>function add(…values) {<br>    let sum = 0<br>    console.log(values) // [2, 3, 4]<br>    for (var val of values) {<br>        sum += val<br>    }<br>    return sum<br>}<br>console.log(add(2, 3, 4)) // 9<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">下面是rest参数代替arguments变量的例子</div></pre></td></tr></table></figure></p>
<p>//在ES5中<br>const shortNumbers = () =&gt; {<br>    return Array.prototype.slice.call(arguments).sort()<br>}<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">// 使用rest参数无疑让写法更加简洁自然了</div></pre></td></tr></table></figure></p>
<p>const sortNumbers = (…numbers) =&gt; {<br>    return numbers.sort()<br>}</p>
<h2 id="使用rest参数的特性-可以改写push方法"><a href="#使用rest参数的特性-可以改写push方法" class="headerlink" title="使用rest参数的特性,可以改写push方法"></a>使用rest参数的特性,可以改写push方法</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">function push(array, ...items) &#123;</div><div class="line">	items.forEach(function(item) &#123;</div><div class="line">		array.push(item)</div><div class="line">	&#125;)</div><div class="line">	return array</div><div class="line">&#125;</div><div class="line">console.log(push([1, 2, 3], 1, 2, 3, 4, 54)) </div><div class="line">// [1, 2, 3, 1, 2, 3, 4, 54]</div></pre></td></tr></table></figure>
<h1 id="扩展运算符-…"><a href="#扩展运算符-…" class="headerlink" title="扩展运算符  …"></a>扩展运算符  …</h1><p>扩展运算符好比rest参数的逆运算,将一个数组转为用逗号分隔的参数序列</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">console.log(...[1, 2, 3]) // 1 2 3</div><div class="line">console.log(1, ...[2, [[3], 4]], 5) // 1, 2, [[3], 4]], 5</div><div class="line"></div><div class="line">## 扩展运算符的应用</div><div class="line"></div><div class="line">### 替代数组的apply方法</div><div class="line"></div><div class="line">在ES5之前,我们如果需要将数组的值作为函数的参数逐一传进函数的时候,最简便的方法就是使用apply方法</div></pre></td></tr></table></figure>
<p>function f(x, y, z) {}<br>var args = [1, 2, 3]<br>f.apply(null, args)<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">在ES6中,写法是这样的</div></pre></td></tr></table></figure></p>
<p>function f2(x, y, z) {}<br>var args = [0, 1, 2]<br>f2(…args)<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">### 替代Math.max方法</div><div class="line"></div><div class="line">当我们需要对数组进行最大最小值的判断的时候,在ES5中,用法是这样的</div></pre></td></tr></table></figure></p>
<p>var a = [1, 2, 4, 12, 3, 5, 1, 12]<br>console.log(Math.max.apply(null, a)) // 12<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">但是在ES6中,我们就不必要这么麻烦了,因为扩展运算符 ... 可以将数组直接转换为普通的单个数字</div></pre></td></tr></table></figure></p>
<p>var a = [1, 2, 4, 12, 3, 5, 1, 12]<br>console.log(Math.max(…a)) // 12<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">### 替代push方法</div><div class="line"></div><div class="line">同样的,在ES5中,如果我们需要使用push方法将两个数组连接起来的时候,我们需要这样做</div></pre></td></tr></table></figure></p>
<p>var a = [1, 2, 3]<br>var b = [4, 5, 6]<br>Array.prototype.push.apply(a, b)<br>console.log(a) // [1, 2, 3, 4, 5, 6]<br>console.log(b) // [4, 5, 6]<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">因为最后需要得到扁平化的数组,所以并不能直接使用`a.push(b)`这样的方法,这样会使得到的变成多维数组</div><div class="line"></div><div class="line">同样的,ES6还提供了数组合并的新写法:</div></pre></td></tr></table></figure></p>
<p>var a = [1, 2, 3]<br>var b = [4, 5, 6]<br>a.push(…b)<br>console.log(a) // [1, 2, 3, 4, 5, 6]<br>console.log(b) // [4, 5, 6]<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">### 替代数组合并方法</div></pre></td></tr></table></figure></p>
<p>var a = [1, 2, 3]<br>var b = [4, 5, 6]<br>var c = a.concat(b)<br>console.log(c)  // [1, 2, 3, 4, 5, 6]<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">在ES6中,因为有了 ... 运算符,那么其实concat是可以省略的</div></pre></td></tr></table></figure></p>
<p>var a = [1, 2, 3]<br>var b = [4, 5, 6]<br>var d = […a, …b]<br>console.log(d)  // [1, 2, 3, 4, 5, 6]<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">### 与解构赋值结合起来,用于生成数组</div><div class="line"></div><div class="line">那么,我们先来看一下,在ES5中,是怎么做到的</div></pre></td></tr></table></figure></p>
<p>let a = [1, 2, 3, 4]<br>let b = a[0]<br>let c = a.slice(1)<br>console.log(b, c) // 1 [2, 3, 4]<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">那么在ES6中,这样的形式就很容易实现了,通过解构赋值和三点运算符结合的方式</div></pre></td></tr></table></figure></p>
<p>let a = [1, 2, 3, 4]<br>let [d, …e] = a<br>console.log(d, e) // 1 [2, 3, 4]<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">当我们对一个空的数组进行解构赋值的时候,会出现什么情况呢?</div></pre></td></tr></table></figure></p>
<p>let [f, …g] = []<br>console.log(f, g) //undefined  []<br>let [h, …i] = [‘foo’]<br>console.log(h, i) // foo  []<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">需要注意的是,我们使用扩展运算符,也就是三点运算符,这个运算是必须要放在参数的最后一位的,否则会报错</div></pre></td></tr></table></figure></p>
<p>let […j, k] = [1, 2, 3, 4]<br>console.log(j, k)<br>//报错,Rest element must be last element<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">## 扩展运算符对字符串的支持</div></pre></td></tr></table></figure></p>
<p>console.log([…’hello’]) // [“h”, “e”, “l”, “l”, “o”]<br>// 扩展运算符将字符串中的每一个值都拆分成了单个的字符组成的数组<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">当然,这还不是最重要的,重要的是, 扩展运算符对32位Unicode字符的支持</div></pre></td></tr></table></figure></p>
<p>console.log([…’x\u{20bb7}\u20bb7’].length)  // 4<br>// 可见,两个大括号完美地解决了32位字符这个bug的尴尬<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">对于unicode不太了解的童鞋, 可以先跳转到之前,看下我写的ES6中对Unicode的支持这一章节</div><div class="line"></div><div class="line">括展运算符内部调用的是数据结构的iterator接口,因此只要具有iterator接口的对象,都可以使用扩展运算符</div></pre></td></tr></table></figure></p>
<p>let map = new Map([<br>    [1, ‘one’],<br>    [2, ‘two’],<br>    [3, ‘three’]<br>])<br>let arr = […map.values()]<br>console.log(arr)<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">Generator函数运行后返回一个遍历器对象,因此也可以使用扩展运算符</div></pre></td></tr></table></figure></p>
<p>var go = function*() {<br>    yield 1<br>    yield 2<br>    yield 3</p>
<p>}<br>console.log([…go()])<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"># 函数的name属性</div><div class="line"></div><div class="line">函数的name属性返回该函数的函数名</div><div class="line"></div><div class="line">通过bind返回的函数, name属性会加上&apos;bound&apos;前缀</div></pre></td></tr></table></figure></p>
<p>function foo() {}<br>console.log(foo.name) // foo<br>function foo() {}<br>console.log(foo.bind({}).name) //bound foo<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"># ES6的箭头函数</div><div class="line"></div><div class="line">ES6允许使用箭头定义函数</div><div class="line"></div><div class="line">` var f = v =&gt; v `</div><div class="line"></div><div class="line">上面的箭头其实就等价于</div></pre></td></tr></table></figure></p>
<p>var f = function(v) {<br>    return v<br>}<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">那么,上面是需要参数的情况下,当我们不需要参数的时候怎么办呢?</div><div class="line"></div><div class="line">在这个情况下是可以使用圆括号代替的</div><div class="line"></div><div class="line">`var f = () =&gt; 5`</div><div class="line"></div><div class="line">等价于</div></pre></td></tr></table></figure></p>
<p>var f = function() {<br>    return 5<br>}<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">当存在多个参数的时候</div><div class="line"></div><div class="line">`var f = (num1, num2) =&gt; num1 + num2`</div><div class="line"></div><div class="line">等价于</div></pre></td></tr></table></figure></p>
<p>var f = function(num1, num2) {<br>    return num1 + num2<br>}<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">如果箭头函数的代码块部分多于一条语句, 就要使用大括号将其括起来, 并使用return语句返回</div><div class="line"></div><div class="line">由于大括号被解释为代码块,所以当我们需要箭头函数返回一个对象的时候,需要使用圆括号将对象括起来</div></pre></td></tr></table></figure></p>
<p>var f = id =&gt; ({<br>    id: id,<br>    name: ‘temp’<br>})<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">还有一点是,箭头函数还可以和解构赋值一起使用</div></pre></td></tr></table></figure></p>
<p>var full = ({first, last}) =&gt; first + ‘ ‘ + last<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">等价于</div></pre></td></tr></table></figure></p>
<p>var full = function(person) {<br>    return first + “ “ + last<br>}<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">箭头函数的另一个用处就是简化回调函数</div><div class="line"></div><div class="line">`[1, 2, 3].map(x =&gt; x * x)`</div><div class="line"></div><div class="line">等价于</div><div class="line"></div><div class="line">`[1, 2, 3].map(function(x) &#123;return x * x&#125;)`</div><div class="line"></div><div class="line">rest参数的写法</div><div class="line"></div><div class="line">`const headAndTail = (head, ...tail) =&gt; [head, tail]`</div><div class="line"></div><div class="line"># 箭头函数的使用注意点</div><div class="line"></div><div class="line">&gt;函数体内的this对象就是定义的时候所在的对象,而不是使用的时候所在的对象</div><div class="line"></div><div class="line">&gt;不可以拿来当做构造函数,也就是不可以拿来new一下,否则会抛出一个错误</div><div class="line"></div><div class="line">&gt;不可以使用arguments对象,该对象在函数体内是不存在的,如果需要使用,可以使用rest参数将arguments对象转为数组之后使用</div><div class="line"></div><div class="line">&gt;不可以使用yield命令,因此箭头函数不能用作Generator参数</div><div class="line"></div><div class="line"># 箭头函数中的this</div><div class="line"></div><div class="line">this的指向在之前是可变的,但是在箭头函数中是固定的</div></pre></td></tr></table></figure></p>
<p>function foo() {<br>    setTimeout(() =&gt; {<br>        console.log(‘id:’, this.id) // id: 42<br>    }, 100)<br>}</p>
<p>foo.call({id: 42})<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">而且不论嵌套多少层,都是没有问题的,朝阳指向调用的对象</div></pre></td></tr></table></figure></p>
<p>function foo3() {<br>    return () =&gt; {<br>        return () =&gt; {<br>            console.log(‘id: ‘, this.id) // id: 42<br>        }<br>    }<br>}<br>foo3.call({id: 42})()()<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">因为箭头函数没有自己的this, 所以我们在内部绑定this,是不能生效的</div></pre></td></tr></table></figure></p>
<p>var a = (function() {<br>    return [<br>        (() =&gt; this.x).bind({<br>            x: ‘inner’<br>        })<br>    ]<br>}).call({<br>    x: ‘outer’<br>})<br>console.log(a()) // () =&gt; this.x<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">箭头函数的内部还可以再使用箭头函数</div></pre></td></tr></table></figure></p>
<p>function insert(value) {<br>    return {<br>        into: function(array) {<br>            return {<br>                after: function(afterValue) {<br>                    array.splice(array.indexOf(afterValue) + 1, 0, value)<br>                }<br>            }<br>        }<br>    }<br>}</p>
<p>console.log(insert(2).into([1, 3]).after(1)) // [1, 2, 3]<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"># 函数绑定</div><div class="line"></div><div class="line">箭头函数可以绑定this对象, 大大减少了显式绑定this对象的写法, 但是因为this在箭头函数中的特殊性,因此其并不适用于所有场合</div><div class="line"></div><div class="line">所以ES7提出了函数绑定的写法, 目前浏览器暂不支持,但babel转码器已经支持</div></pre></td></tr></table></figure></p>
<p>foo::bar<br>// 等同于<br>bar.bind(foo)<br>```</p>
]]></content>
    
    <summary type="html">
    
      本系列为在我读完阮一峰老师的《ES6标准入门》第二版之后，所做的阅读笔记的整理。 系列博客将采用一个一个的样例，来说明书中的精华部分（当然，这只是我认为的），同时引导新手，快速入门ES6，并逐步将其投入到生产实践中。
    
    </summary>
    
      <category term="ES6标准入门" scheme="https://github.com/ChangerHe/categories/ES6%E6%A0%87%E5%87%86%E5%85%A5%E9%97%A8/"/>
    
    
      <category term="ES6" scheme="https://github.com/ChangerHe/tags/ES6/"/>
    
      <category term="Function" scheme="https://github.com/ChangerHe/tags/Function/"/>
    
  </entry>
  
  <entry>
    <title>《ES6标准入门》阅读笔记——-数组的扩展</title>
    <link href="https://github.com/ChangerHe/2017/06/25/%E3%80%8AES6%E6%A0%87%E5%87%86%E5%85%A5%E9%97%A8%E3%80%8B%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0%E2%80%94%E2%80%94-%E6%95%B0%E7%BB%84%E7%9A%84%E6%89%A9%E5%B1%95/"/>
    <id>https://github.com/ChangerHe/2017/06/25/《ES6标准入门》阅读笔记——-数组的扩展/</id>
    <published>2017-06-25T14:34:21.000Z</published>
    <updated>2017-09-18T02:59:23.397Z</updated>
    
    <content type="html"><![CDATA[<h1 id="写在前面"><a href="#写在前面" class="headerlink" title="写在前面"></a>写在前面</h1><p>本系列为在我读完阮一峰老师的《ES6标准入门》第二版之后，所做的阅读笔记的整理。</p>
<p>许多初学ES6, 同时和我一样初次阅读阮老师的这本书的时候, 读第一遍会越发的困惑, 因为阮老师上面说的很多的定义,方法,之前都是没有见过的, 读到后面才发现, 哦~原来是这样.</p>
<p>有一句话叫做”大神的世界我们不懂”, 所以我在初读第一遍《ES6标准入门》这本书的时候,也是踩了不少坑,读书的时候查阅了不少的资料.</p>
<p>所以,在这一系列的笔记教程中,我会从一个初学者的角度,向您讲述ES6的相关知识,在后面介绍的知识我会尽量不提前用,即使提前使用,也会同时做好标注,避免了阅读时各种查阅资料的烦恼.</p>
<p>系列博客将采用一个一个的样例，来说明书中的精华部分（当然，这只是我认为的），同时引导新手，快速入门ES6，并逐步将其投入到生产实践中。</p>
<p>同时,在阅读前也提醒您, 为了系统连贯性的学习ES6的基础知识,建议您从我的博客第一章开始阅读,当然,如果您对对应的知识已经有所了解,那么可以跳转到任意章节阅读,每一篇博客名中均有介绍该博客中涉及到的ES6的内容.</p>
<p>阮一峰老师的这本书是开源的，在其官方博客就可以下载到，但是我强烈建议大家去购买一本书, 一是方便自己查阅ES6中新增的众多API, 二也是表达一下对大神的敬仰.</p>
<h1 id="新增的API–Array-from"><a href="#新增的API–Array-from" class="headerlink" title="新增的API–Array.from()"></a>新增的API–Array.from()</h1><p>Array.from() 方法将两类对象转为真正的数组:类数组对象和可遍历对象 </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">let arrayLike = &#123;</div><div class="line">	&apos;0&apos;: &apos;a&apos;,</div><div class="line">	&apos;1&apos;: &apos;b&apos;,</div><div class="line">	&apos;2&apos;: &apos;c&apos;,</div><div class="line">	length: 3</div><div class="line">&#125;</div><div class="line">var arr1 = Array.prototype.slice.call(arrayLike)</div><div class="line">console.log(arr1)  // [1,2,3]</div><div class="line"></div><div class="line">let arr2 = Array.from(arrayLike)</div><div class="line">console.log(arr2)  // [1,2,3]</div></pre></td></tr></table></figure>
<p>可见,在将类数组转换为数组的过程中,使用ES6定义的新方法能够更好且更简单地将类数组转换为真正的数组.</p>
<p>在实际应用中,我们最常见的对象是DOM操作返回的NodeList集合,同样的,使用这个方法就可以实现将相应的类数组对象转换为数组</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">let nameSet = new Set([&apos;a&apos;, &apos;b&apos;])</div><div class="line">var a = Array.from(nameSet)</div><div class="line">console.log(a)  // [&apos;a&apos;, &apos;b&apos;]</div></pre></td></tr></table></figure>
<p>注: Set是ES6中的新的数据结构, 类似于数组, 但是成员的值都是唯一的, 没有重复的值, 这是Set结构的最大特征.</p>
<p>如果对象是一个真的数组,那么使用Array.from() 方法会返回一个和原来一模一样的新数组</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">let a = [1, 2, 3]</div><div class="line">let b = Array.from(a)</div><div class="line">a = [3, 2, 1]</div><div class="line">console.log(a) // [3,2,1]</div><div class="line">console.log(b) // [1,2,3]</div></pre></td></tr></table></figure>
<p>扩展运算符也可以将某些数据结构转为数组<br>那么,我们可以对函数的变量arguments进行相应的处理,让其变成真正的数组</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">function foo() &#123;</div><div class="line">	var args = [...arguments]</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>那么同样的,我们也可以对HTML的元素对象进行相应的操作</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">[...document.querySelectorAll(&apos;div&apos;)]</div></pre></td></tr></table></figure>
<p>扩展运算符背后调用的是遍历器接口Iterator, 如果一个对象没有部署该接口就无法进行转换, Iterator将在后面详细讲解.</p>
<p>但是,所有的转换,一个最大的前提条件是,必须要有一个length对象,保存一个数值,没有这个属性的话是没有办法转为数组的</p>
<p>对于没有部署Array.from() 方法的浏览器,我们可以使用对应的老方法和新方法进行结合模拟</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">const toArray = (() =&gt;</div><div class="line">	Array.from ? Array.from : obj =&gt; [].slice.call(obj)</div><div class="line">)</div></pre></td></tr></table></figure>
<p>注: 箭头函数也是ES6中新定义的方法, 其实是一种语法糖,方便我们进行编程而已.<br><code>() =&gt; console.log(1)</code>   等价于  <code>function() {console.log(1)}</code></p>
<p>Array.from 方法还可以接受第二个参数,作用类似于数组的map方法,用来对每个元素进行处理,并将处理后的值放入返回的数组</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">let arrayLike = &#123;</div><div class="line">	&apos;0&apos;: &apos;a&apos;,</div><div class="line">	&apos;1&apos;: &apos;b&apos;,</div><div class="line">	&apos;2&apos;: &apos;c&apos;,</div><div class="line">	length: 3</div><div class="line">&#125;</div><div class="line">Array.from(arrayLike, x =&gt; x * x)</div><div class="line">// 其实上面的方法就等同于下面的方法</div><div class="line">Array.from(arrayLike).map(function(x) &#123;</div><div class="line">	return x * x</div><div class="line">&#125;)</div><div class="line">// 上面是使用ES5的方法所写的方法,我们可以将函数转换为箭头函数的形式</div><div class="line">Array.from(arrayLike).map(x =&gt; x * x)</div></pre></td></tr></table></figure>
<p>利用这个特性,可以很容易地将数组的空位置零</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">let a = Array.from([1,,2,,5], (x) =&gt; x || 0)</div><div class="line">console.log(a) // [1,0,2,0,5]</div></pre></td></tr></table></figure>
<h1 id="数组的Array-of-方法"><a href="#数组的Array-of-方法" class="headerlink" title="数组的Array.of()方法"></a>数组的Array.of()方法</h1><p>Array.of() 方法用于将一组值转换为数组</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">console.log(Array.of(1, 8, 3))  // [1,8,3]</div><div class="line">console.log(Array.of(3)) // [3]</div><div class="line">console.log(Array.of()) // []</div></pre></td></tr></table></figure>
<p>其实这个方法的主要目的,是弥补构造函数Array的不足, 因为参数的不同会导致Array的行为有所差异</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">console.log(Array())  // []</div><div class="line">console.log(Array(3)) // [,,,]</div><div class="line">console.log(1,2,3) // [1,2,3]</div></pre></td></tr></table></figure>
<p>因此, 不同于直接使用Array方法, 使用Array.of()方法不论你传入的是一个数,还是几个数,其实最后都是返回的数组对象, 而不同于使用Array, 会产生不同的行为.</p>
<h1 id="数组的copyWithin-方法"><a href="#数组的copyWithin-方法" class="headerlink" title="数组的copyWithin() 方法"></a>数组的copyWithin() 方法</h1><p>数组的copyWithin()方法, 主要的作用是在当前数组内部将指定位置的成员复制到其他位置, 此方法接受三个参数</p>
<blockquote>
<p>target 必需值,从该位置开始替换数据, 也就是说, 从这个地方开始要更改数组了<br>atart  可选值,从该位置开始读取数据,默认为0 , 若为负值,则表示倒数, 也就是说, 我要更改数组,总得找个东西替换这些个之前的数组呀. 那么我就从这个位置开始截取数组的值,把它放到要更改的地方<br>end    到该位置前停止读取数据,默认等于数组长度,如果为负值,表示倒数, 也就是说,截取也不能截取个没完嘛,所以需要在这个地方停止截取, 然后就把截取的值丢到target的那个位置了.</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">let a = [1, 2, 3, 4, 5]</div><div class="line">a.copyWithin(3, 1, 2)</div><div class="line">console.log(a)  // [1, 2, 3, 2, 5]</div></pre></td></tr></table></figure>
<p>由上可见,其实copyWithin()最终更改了, 第四个位置, 也就是a[3] 的值</p>
<h1 id="数组的find-方法和findIndex-方法"><a href="#数组的find-方法和findIndex-方法" class="headerlink" title="数组的find() 方法和findIndex() 方法"></a>数组的find() 方法和findIndex() 方法</h1><p>数组的find() 方法,用于找出第一个符合条件的数组成员.数组成员依次执行其后的回调函数,直到找出第一个匹配的成员,否则返回undefined</p>
<p>下面的代码找出了数组中小于0 的成员, 并将其打印出来</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">let a = [1, 2, 3, -4, 3]</div><div class="line">console.log(a.find((x) =&gt; x &lt; 0)) // -4</div></pre></td></tr></table></figure>
<p>find方法可以接受三个参数, 依次为当前值, 当前位置和原数组.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">let b = [1, 5, 10, 15].find((value, index, arr) =&gt; value &gt; 9)</div><div class="line">console.log(a) // 10</div></pre></td></tr></table></figure>
<p>数组的findeIndex() 方法返回第一个符合条件的数组成员的位置, 如果所有成员都不符合条件,则返回-1</p>
<p>这两个方法还可以接受第二个参数,用来绑定回调函数的this对象</p>
<p>还有重要的一点是,这两个方法都可以发现NaN,弥补了之前NaN支持的不足</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">let a = [NaN].indexOf(NaN)</div><div class="line">console.log(a) // -1</div><div class="line"></div><div class="line">let b = [NaN].findIndex(y =&gt; Object.is(NaN, y))</div><div class="line">console.log(b) // 0</div></pre></td></tr></table></figure>
<p>注: Object.is() 用来比较两个值是否严格相等. 它与全等运算符表现基本一致, 但增加了NaN的支持.</p>
<h1 id="数组的fill-方法"><a href="#数组的fill-方法" class="headerlink" title="数组的fill() 方法"></a>数组的fill() 方法</h1><p>数组实例的fill() 该方法使用给定值填充数组</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">console.log([&apos;a&apos;, &apos;b&apos;, &apos;c&apos;].fill(1)) // [1, 1, 1]</div><div class="line">console.log([&apos;a&apos;, &apos;b&apos;, &apos;c&apos;].fill(7, 1, 2)) // [&quot;a&quot;, 7, &quot;c&quot;]</div></pre></td></tr></table></figure>
<p>这样对数组进行初始化非常的方便,该方法还可接受另外两个可选参数,规定填充的起始和结束位置</p>
<h1 id="数组遍历"><a href="#数组遍历" class="headerlink" title="数组遍历"></a>数组遍历</h1><p>ES6提供了三个新方法用于遍历数组</p>
<blockquote>
<p>keys() 对键名的遍历<br>values() 对键值的遍历<br>entries() 对键值对的遍历</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">for (let index of [&apos;a&apos;, &apos;b&apos;].keys()) &#123;</div><div class="line">	console.log(index) // 0  // 1</div><div class="line">&#125;</div><div class="line">for (let index of [&apos;a&apos;, &apos;b&apos;].values()) &#123;</div><div class="line">	console.log(index) // &apos;a&apos;  // &apos;b&apos;</div><div class="line">&#125;</div><div class="line">for (let index of [&apos;a&apos;, &apos;b&apos;].entries()) &#123;</div><div class="line">	console.log(index) // 0 &apos;a&apos;  // 1 &apos;b&apos;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>注: for…of 遍历也是对循环的一种补充,与for…in类似,但不会枚举出对象上的可枚举属性</p>
<h1 id="数组的includes"><a href="#数组的includes" class="headerlink" title="数组的includes()"></a>数组的includes()</h1><p>includes() 方法返回一个实例,表示某数组是否包含给定的值</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">let a = [1, 2, 3]</div><div class="line">console.log(a.includes(2)) // true</div><div class="line">console.log(a.includes(4)) // false</div></pre></td></tr></table></figure>
<p>当浏览器不兼容的时候,可以使用indexOf方法进行替代<br>但是indexOf有一个弊端,原因是indexOf内部使用的是全等操作符进行匹配,所以这个时候当我们判定NaN的时候,是无法判定成功的, 因为NaN!==NaN</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">console.log([NaN].indexOf(NaN)) // -1</div></pre></td></tr></table></figure>
<h1 id="数组的空位"><a href="#数组的空位" class="headerlink" title="数组的空位"></a>数组的空位</h1><p>ES5在很多情况下,对于数组的空位是直接忽略的,例如forEach filter every some 等方法会跳过空位, map 会跳过空位,但会保留这个值, join 和 toString 会将空位视为undefined 而undefined和null会被处理为字符串</p>
<p>下面是ES5下的方法</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">[, &apos;a&apos;].forEach((x, i) =&gt; console.log(i)); </div><div class="line">// 1 因为第零个是空位,被忽略了</div><div class="line">console.log([, &apos;a&apos;].filter((x, i) =&gt; true)); </div><div class="line">// [&quot;a&quot;]  小红书有讲过的方法,使用true将数组的空位去除</div><div class="line">console.log([, &apos;a&apos;].every((x, i) =&gt; x !== undefined)) </div><div class="line">// true</div><div class="line">console.log([, &apos;a&apos;].some((x, i) =&gt; x === undefined)) </div><div class="line">// false</div><div class="line">console.log([, &apos;a&apos;].map((x, i) =&gt; 1));</div><div class="line">// [empty × 1, 1]</div><div class="line">console.log([, &apos;a&apos;, undefined, null].join(&apos;#&apos;)) </div><div class="line">// #a##</div><div class="line"></div><div class="line">`</div></pre></td></tr></table></figure>
<p>但在ES6中,空位会被明确转为undefined</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">console.log([...[&apos;a&apos;, , &apos;b&apos;]]) </div><div class="line">//[&quot;a&quot;, undefined, &quot;b&quot;]</div></pre></td></tr></table></figure>
<p>copyWithin()会连空位一起复制</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">[, &apos;a&apos;, &apos;b&apos;, ,].copyWithin(2, 0) //[empty × 1, &quot;a&quot;, empty × 1, &quot;a&quot;]</div></pre></td></tr></table></figure>
<p>fill()会将空位视为正常的数组位置</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">new Array(3).fill(&apos;a&apos;) // [&apos;a&apos;, &apos;a&apos;, &apos;a&apos;]</div></pre></td></tr></table></figure>
<p>for…of循环也会遍历空位, 而map却不会遍历空位</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">let arr = [, ,]</div><div class="line">for(let i of arr) &#123;</div><div class="line">	console.log(1) // 1 // 1</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h1 id="数组推导"><a href="#数组推导" class="headerlink" title="数组推导"></a>数组推导</h1><p>数组推导是ES7中的新方法,允许直接通过现有数组生成新数组.</p>
<p>本来TC39是计划将其放入ES6的,但TC39仍然想完善它,让其支持所有数组结构. 所以推迟到了ES7.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">let a1 = [1, 2, 3, 4]</div><div class="line">var a2 = [</div><div class="line">	for (i of a1) i * 2</div><div class="line">];</div><div class="line">console.log(a2)  // [2, 4, 6, 8]</div></pre></td></tr></table></figure>
<p>(完)</p>
]]></content>
    
    <summary type="html">
    
      本系列为在我读完阮一峰老师的《ES6标准入门》第二版之后，所做的阅读笔记的整理。 系列博客将采用一个一个的样例，来说明书中的精华部分（当然，这只是我认为的），同时引导新手，快速入门ES6，并逐步将其投入到生产实践中。
    
    </summary>
    
      <category term="ES6标准入门" scheme="https://github.com/ChangerHe/categories/ES6%E6%A0%87%E5%87%86%E5%85%A5%E9%97%A8/"/>
    
    
      <category term="ES6" scheme="https://github.com/ChangerHe/tags/ES6/"/>
    
      <category term="Array" scheme="https://github.com/ChangerHe/tags/Array/"/>
    
  </entry>
  
  <entry>
    <title>《ES6标准入门》阅读笔记——-number类型的扩展</title>
    <link href="https://github.com/ChangerHe/2017/06/22/%E3%80%8AES6%E6%A0%87%E5%87%86%E5%85%A5%E9%97%A8%E3%80%8B%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0%E2%80%94%E2%80%94-number%E7%B1%BB%E5%9E%8B%E7%9A%84%E6%89%A9%E5%B1%95/"/>
    <id>https://github.com/ChangerHe/2017/06/22/《ES6标准入门》阅读笔记——-number类型的扩展/</id>
    <published>2017-06-22T15:41:23.000Z</published>
    <updated>2017-09-18T00:41:30.254Z</updated>
    
    <content type="html"><![CDATA[<h1 id="写在前面"><a href="#写在前面" class="headerlink" title="写在前面"></a>写在前面</h1><p>本系列为在我读完阮一峰老师的《ES6标准入门》第二版之后，所做的阅读笔记的整理。</p>
<p>许多初学ES6, 同时和我一样初次阅读阮老师的这本书的时候, 读第一遍会越发的困惑, 因为阮老师上面说的很多的定义,方法,之前都是没有见过的, 读到后面才发现, 哦~原来是这样.</p>
<p>有一句话叫做”大神的世界我们不懂”, 所以我在初读第一遍《ES6标准入门》这本书的时候,也是踩了不少坑,读书的时候查阅了不少的资料.</p>
<p>所以,在这一系列的笔记教程中,我会从一个初学者的角度,向您讲述ES6的相关知识,在后面介绍的知识我会尽量不提前用,即使提前使用,也会同时做好标注,避免了阅读时各种查阅资料的烦恼.</p>
<p>系列博客将采用一个一个的样例，来说明书中的精华部分（当然，这只是我认为的），同时引导新手，快速入门ES6，并逐步将其投入到生产实践中。</p>
<p>同时,在阅读前也提醒您, 为了系统连贯性的学习ES6的基础知识,建议您从我的博客第一章开始阅读,当然,如果您对对应的知识已经有所了解,那么可以跳转到任意章节阅读,每一篇博客名中均有介绍该博客中涉及到的ES6的内容.</p>
<p>阮一峰老师的这本书是开源的，在其官方博客就可以下载到，但是我强烈建议大家去购买一本书, 一是方便自己查阅ES6中新增的众多API, 二也是表达一下对大神的敬仰.</p>
<h1 id="二进制和八进制的新写法"><a href="#二进制和八进制的新写法" class="headerlink" title="二进制和八进制的新写法"></a>二进制和八进制的新写法</h1><p>ES6的更新同时带来了二进制和八进制数组的新写法, 分别使用0b 和 0o表示</p>
<p>不同于之前在ES5中,我们使用八进制字面量, 在严格模式下是无效的:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">&quot;use strict&quot;</div><div class="line">var octalNum = 070</div><div class="line">console.log(octalNum)</div></pre></td></tr></table></figure>
<p>(不过经过测试,在ES6环境下,这个语句可以正常运行. 这要归功于ES6带来的强大的性能, 这一点需要说明一下)</p>
<p>在ES6环境下,我们可以直接使用</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">console.log(0o11 === 011)  // true</div><div class="line">&apos;use strict&apos;</div><div class="line">console.log(0o11 === 011)  // true</div><div class="line">console.log(Number(&apos;0b111&apos;))  // 7</div><div class="line">console.log(Number(&apos;0o10&apos;))  // 8</div></pre></td></tr></table></figure>
<h1 id="Number-isFinite"><a href="#Number-isFinite" class="headerlink" title="Number.isFinite()"></a>Number.isFinite()</h1><p>ES6提供了判断数字是否有穷的方法 Number.isFinite()</p>
<p>到这里很多同学很惊讶,这个isFinite()方法不是应该是ES5所出现的吗? </p>
<p>其实是这样的, 在ES6之前,我们调用这个方法是直接在window 上面调用的, 而在ES6中, 将这些数学方法集成到了Number类中. </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">console.log(Number.isFinite(15))  // true</div><div class="line">console.log(Number.isFinite(&apos;15&apos;))  // false</div><div class="line">console.log(Number.isFinite(NaN))  // false</div><div class="line">console.log(Number.isFinite(Infinity))  // false</div></pre></td></tr></table></figure>
<p>需要注意的是,当我们传入字符串进去的时候,是不会对我们传入值进行隐式类型转换的</p>
<h1 id="Number-isNaN"><a href="#Number-isNaN" class="headerlink" title="Number.isNaN()"></a>Number.isNaN()</h1><p>同样的, 本来之前在window上面的方法isNaN()也被同时放到了Number类上</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">console.log(Number.isNaN(NaN)) // true</div><div class="line">console.log(Number.isNaN(15)) // false</div><div class="line">console.log(Number.isNaN(&apos;15&apos;)) // false</div><div class="line">console.log(Number.isNaN(&apos;true&apos; / &apos;true&apos;)) // true</div></pre></td></tr></table></figure>
<h1 id="两种方法的区别"><a href="#两种方法的区别" class="headerlink" title="两种方法的区别"></a>两种方法的区别</h1><p>那么,为了遵循线性增强的规则, ES6中也保留了在ES5中的之前的方法. 但是两种方法是存在区别的, 最大的区别在于, Number类下的方法不会进行隐式类型转换</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">console.log(isFinite(25))  // true</div><div class="line">console.log(isFinite(&apos;25&apos;))  // true</div><div class="line">console.log(Number.isFinite(25))   // true</div><div class="line">console.log(Number.isFinite(&apos;25&apos;)) // 因为不存在隐式类型转换的过程,所以这里打印值为false</div></pre></td></tr></table></figure>
<p>综上所述, ES6在数值类上的一个创新是,将一些数组类的全局方法逐步转移到Number类型下来,从而达到逐步减少全局方法的目的,实现语言的逐步模块化</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">console.log(Number.parseFloat === parseFloat) // true</div></pre></td></tr></table></figure>
<h1 id="Number-isInterger"><a href="#Number-isInterger" class="headerlink" title="Number.isInterger()"></a>Number.isInterger()</h1><p>Number.isInterger() 方法,用来判断一个值是否为整数,需要注意的是,在javascript内部,整数和浮点数是采用的相同的存储方法的,所以3 和 3.0 其实是全等的</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">console.log(3 === 3.0)</div><div class="line">console.log(Number.isInteger(3))</div><div class="line">console.log(Number.isInteger(3.0)) // true</div><div class="line">console.log(Number.isInteger(3.1)) // false</div></pre></td></tr></table></figure>
<h1 id="Number-EPSILON"><a href="#Number-EPSILON" class="headerlink" title="Number.EPSILON"></a>Number.EPSILON</h1><p>Number.EPSILON 是Number对象引入的一个极小的常量,目的在于解决浮点数计算不精确的问题</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">console.log(Number.EPSILON) //2.220446049250313e-16</div><div class="line">// 当两者相减,误差小于Number.EPSILON的时候,我们可以判定两数是完全相等的</div><div class="line">function equal(num1, num2) &#123;</div><div class="line">return Math.abs(num1 - num2) &lt; Number.EPSILON ? true : false;</div><div class="line"></div><div class="line">console.log(equal(.1 + .2, .3))  // true</div></pre></td></tr></table></figure>
<p>要知道,在这之前, .1 + .2 != .3 因为浮点的运算精度问题,导致出现了一点点的小误差</p>
<h1 id="安全整数"><a href="#安全整数" class="headerlink" title="安全整数"></a>安全整数</h1><p>javascript可以准确地表示在2的负53次方到2的正53次方之间的整数,超出则无法精确显示</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">console.log(Math.pow(2, 53) === Math.pow(2, 53) - 1) // 返回的是false,书上的有问题</div></pre></td></tr></table></figure>
<h1 id="数学对象处理的其他方法"><a href="#数学对象处理的其他方法" class="headerlink" title="数学对象处理的其他方法"></a>数学对象处理的其他方法</h1><p>在ES6中,新增了17个对数学对象处理相关的方法</p>
<blockquote>
<p>   Math.trunc() 用于取出一个数的小数部分,返回整数部分<br>   Math.sign()  用于判断一个数到底是整数,还是负数,还是零<br>   Math.cbrt()  用于计算一个数的立方根<br>   Math.clz32() 用于返回一个数的32位二进制的数值表示的数,前面有多少个前导零<br>   Math.imul()  返回两个数以32位带符号整数形式相乘的结果,返回的也是一个32位带符号整数<br>   Math.fround()返回数值的单精度浮点数的数值表示,也就是以64位存储的浮点数<br>   Math.hypot() 返回所有参数的平方和的平方根<br>   Math.expm1(x) 返回其相应的指数减一  即 e ^ x -1<br>   Math.log1p(x) 返回 ln(1+x) 等价于 Math.log(1 + x)<br>   Math.log10(x) 返回以10为底的对数<br>   Math.log2()  返回以2为底的对数</p>
</blockquote>
<p>下面是打印出来的测试用例</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line">console.log(Math.trunc(4.9)) //4</div><div class="line">console.log(Math.trunc(-4.9)) //-4</div><div class="line">console.log(Math.sign(5)) //1  (表示是正数)</div><div class="line">console.log(Math.sign(-0)) //-0 表示是负零</div><div class="line">console.log(Math.sign(0))</div><div class="line">console.log(Math.sign()) //NaN 表示为非数值</div><div class="line">console.log(Math.cbrt(8)) //2</div><div class="line">console.log(Math.clz32(1)) //31  表示1的32位二进制的数值,1前面一共有21个零</div><div class="line">console.log(Math.clz32(1.9)) //31  对于有小数的情况,只返回相应的整数部分</div><div class="line">console.log(Math.clz32(NaN)) //32  此方法有隐式类型转换的机制</div><div class="line">console.log(Math.imul(2, 4)) // 8</div><div class="line">console.log(Math.fround(1.337)) //1.3370000123977661 丧失了精度</div><div class="line">console.log(Math.hypot(3, 4)) //5</div><div class="line">console.log(Math.expm1(0)) //0</div><div class="line">console.log(Math.expm1(1)) //1.718281828459045</div><div class="line">console.log(Math.log10(10)) //1.718281828459045</div><div class="line">console.log(Math.log2(2)) //1.718281828459045</div></pre></td></tr></table></figure>
<h1 id="指数运算符"><a href="#指数运算符" class="headerlink" title="指数运算符"></a>指数运算符</h1><p>ES7还新增了一个指数运算符,目前babel转码器已经支持</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">console.log(2 ** 2) //4</div><div class="line">console.log(2 ** 3) //8</div><div class="line">	// 同时,指数运算符还可与等号结合,形成一个新的赋值运算符 **=</div><div class="line">let a = 3</div><div class="line">console.log(a **= 2) // 9</div><div class="line">let b = 2</div><div class="line">console.log(b **= 3) // 8</div></pre></td></tr></table></figure>
<p>(完)</p>
]]></content>
    
    <summary type="html">
    
      本系列为在我读完阮一峰老师的《ES6标准入门》第二版之后，所做的阅读笔记的整理。 系列博客将采用一个一个的样例，来说明书中的精华部分（当然，这只是我认为的），同时引导新手，快速入门ES6，并逐步将其投入到生产实践中。
    
    </summary>
    
      <category term="ES6标准入门" scheme="https://github.com/ChangerHe/categories/ES6%E6%A0%87%E5%87%86%E5%85%A5%E9%97%A8/"/>
    
    
      <category term="ES6" scheme="https://github.com/ChangerHe/tags/ES6/"/>
    
      <category term="number" scheme="https://github.com/ChangerHe/tags/number/"/>
    
  </entry>
  
  <entry>
    <title>《ES6标准入门》阅读笔记——-正则表达式的扩展</title>
    <link href="https://github.com/ChangerHe/2017/06/20/%E3%80%8AES6%E6%A0%87%E5%87%86%E5%85%A5%E9%97%A8%E3%80%8B%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0%E2%80%94%E2%80%94-%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F%E7%9A%84%E6%89%A9%E5%B1%95/"/>
    <id>https://github.com/ChangerHe/2017/06/20/《ES6标准入门》阅读笔记——-正则表达式的扩展/</id>
    <published>2017-06-20T12:45:51.000Z</published>
    <updated>2017-09-18T00:41:22.071Z</updated>
    
    <content type="html"><![CDATA[<h1 id="写在前面"><a href="#写在前面" class="headerlink" title="写在前面"></a>写在前面</h1><p>本系列为在我读完阮一峰老师的《ES6标准入门》第二版之后，所做的阅读笔记的整理。</p>
<p>许多初学ES6, 同时和我一样初次阅读阮老师的这本书的时候, 读第一遍会越发的困惑, 因为阮老师上面说的很多的定义,方法,之前都是没有见过的, 读到后面才发现, 哦~原来是这样.</p>
<p>有一句话叫做”大神的世界我们不懂”, 所以我在初读第一遍《ES6标准入门》这本书的时候,也是踩了不少坑,读书的时候查阅了不少的资料.</p>
<p>所以,在这一系列的笔记教程中,我会从一个初学者的角度,向您讲述ES6的相关知识,在后面介绍的知识我会尽量不提前用,即使提前使用,也会同时做好标注,避免了阅读时各种查阅资料的烦恼.</p>
<p>系列博客将采用一个一个的样例，来说明书中的精华部分（当然，这只是我认为的），同时引导新手，快速入门ES6，并逐步将其投入到生产实践中。</p>
<p>同时,在阅读前也提醒您, 为了系统连贯性的学习ES6的基础知识,建议您从我的博客第一章开始阅读,当然,如果您对对应的知识已经有所了解,那么可以跳转到任意章节阅读,每一篇博客名中均有介绍该博客中涉及到的ES6的内容.</p>
<p>阮一峰老师的这本书是开源的，在其官方博客就可以下载到，但是我强烈建议大家去购买一本书, 一是方便自己查阅ES6中新增的众多API, 二也是表达一下对大神的敬仰.</p>
<h1 id="正则表达式的扩展"><a href="#正则表达式的扩展" class="headerlink" title="正则表达式的扩展"></a>正则表达式的扩展</h1><p>在ES6以前,正则表达式的构造函数只能接受字符串作为参数</p>
<p>但在ES6中,是允许RegExp构造函数使用正则表达式作为参数的,这时候会返回一个原有正则表达式的拷贝</p>
<p>如果在使用正则表达式的第二个参数时,则它将会使用第二个修饰符而忽略原有的正则表达式修饰符<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">var reg = new RegExp(/abc/ig, &apos;g&apos;).flags // .flags表示查找正则表达式的修饰符,如ige等</div><div class="line">console.log(reg) // g</div></pre></td></tr></table></figure></p>
<p>ES6新增了u修饰符,含义为Unicode模式, 用来正确处理大于\uFFFF 的Unicode字符</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">console.log(/^\ud83d/u.test(&apos;\ud83d\udc2a&apos;))</div><div class="line">console.log(/^\ud83d/.test(&apos;\ud83d\udc2a&apos;)) // 当不使用u操作符的时候,使用utf-16编码的字符无法被正常识别</div></pre></td></tr></table></figure>
<p>对于点字符,当字符为utf-16编码是,是无法正常被识别的,此时必须加上u修饰符</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">console.log(&apos;\u&#123;20bb7&#125;&apos;)</div><div class="line">var s = &apos;\u&#123;20bb7&#125;&apos;</div><div class="line">console.log(/^.$/.test(s)) // 当正则表达式的标识符不加u时,是不会被识别的,不会被匹配为任意字符,当然,主要原因还是因为它被当成两个字符了</div><div class="line">console.log(/^.$/u.test(s)) // true</div></pre></td></tr></table></figure>
<p>同时,ES6新增了使用大括号表示Unicode的表示法,这种表示法在正则表达式中必须加上u修饰符才能被识别</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">console.log(/\u&#123;61&#125;/.test(&apos;a&apos;))</div><div class="line"> // 当不使用u作为修饰符时,此正则表达式会被认为是u的61个重复</div><div class="line">console.log(/\u&#123;61&#125;/u.test(&apos;a&apos;))</div><div class="line"> // 使用u修饰符后,所有量词都会正确识别码点大于0xFFFF的Unicode字符</div><div class="line">console.log(/𠮷&#123;2&#125;/u.test(&apos;𠮷𠮷&apos;))</div><div class="line"> // 当我们使用\S(非空格字符)对四字节的字符进行匹配的时候,同样会产生问题:无法正常匹配,原因还是一样,之前ES5将这个字符理解成了两个字符了</div><div class="line">console.log(/^\S$/.test(&apos;𠮷&apos;))</div><div class="line">console.log(/^\S$/u.test(&apos;𠮷&apos;))</div></pre></td></tr></table></figure>
<p>除了u修饰符,ES6还为正则表达式添加了y修饰符,叫做黏连修饰符(y)</p>
<p>y修饰符的作用与g修饰符类似,也是全局匹配,后一次的匹配都会从上一次匹配成功的下一个位置开始.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">var s = &apos;sss_ss_s&apos;</div><div class="line">var r1 = /s+/g</div><div class="line">var r2 = /s+/yg</div><div class="line">console.log(s.match(r1))</div><div class="line">console.log(s.match(r2)) </div><div class="line">// 我们使用y修饰符进行匹配,因为同样的s是没有连贯性的出现在一起,所以导致后面的就无法匹配了</div><div class="line">var r3 = /s+_/g</div><div class="line">var r4 = /s+_/y</div><div class="line">console.log(s.match(r3))</div><div class="line">console.log(s.match(r4))</div><div class="line">console.log(s.match(r4))</div></pre></td></tr></table></figure>
<p>ES6为正则表达式提供了flags 和 source 方法,用于返回正则表达式的修饰符 和匹配正文</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">var r = /s/igy</div><div class="line">console.log(r.source)</div><div class="line">console.log(r.flags)</div></pre></td></tr></table></figure>
<p>(完)</p>
]]></content>
    
    <summary type="html">
    
      本系列为在我读完阮一峰老师的《ES6标准入门》第二版之后，所做的阅读笔记的整理。 系列博客将采用一个一个的样例，来说明书中的精华部分（当然，这只是我认为的），同时引导新手，快速入门ES6，并逐步将其投入到生产实践中。
    
    </summary>
    
      <category term="ES6标准入门" scheme="https://github.com/ChangerHe/categories/ES6%E6%A0%87%E5%87%86%E5%85%A5%E9%97%A8/"/>
    
    
      <category term="ES6" scheme="https://github.com/ChangerHe/tags/ES6/"/>
    
      <category term="RegExp" scheme="https://github.com/ChangerHe/tags/RegExp/"/>
    
  </entry>
  
  <entry>
    <title>《ES6标准入门》阅读笔记——-Unicode</title>
    <link href="https://github.com/ChangerHe/2017/06/19/%E3%80%8AES6%E6%A0%87%E5%87%86%E5%85%A5%E9%97%A8%E3%80%8B%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0%E2%80%94%E2%80%94-Unicode/"/>
    <id>https://github.com/ChangerHe/2017/06/19/《ES6标准入门》阅读笔记——-Unicode/</id>
    <published>2017-06-19T14:11:34.000Z</published>
    <updated>2017-09-18T00:41:10.344Z</updated>
    
    <content type="html"><![CDATA[<h1 id="写在前面"><a href="#写在前面" class="headerlink" title="写在前面"></a>写在前面</h1><p>本系列为在我读完阮一峰老师的《ES6标准入门》第二版之后，所做的阅读笔记的整理。</p>
<p>许多初学ES6, 同时和我一样初次阅读阮老师的这本书的时候, 读第一遍会越发的困惑, 因为阮老师上面说的很多的定义,方法,之前都是没有见过的, 读到后面才发现, 哦~原来是这样.</p>
<p>有一句话叫做”大神的世界我们不懂”, 所以我在初读第一遍《ES6标准入门》这本书的时候,也是踩了不少坑,读书的时候查阅了不少的资料.</p>
<p>所以,在这一系列的笔记教程中,我会从一个初学者的角度,向您讲述ES6的相关知识,在后面介绍的知识我会尽量不提前用,即使提前使用,也会同时做好标注,避免了阅读时各种查阅资料的烦恼.</p>
<p>系列博客将采用一个一个的样例，来说明书中的精华部分（当然，这只是我认为的），同时引导新手，快速入门ES6，并逐步将其投入到生产实践中。</p>
<p>同时,在阅读前也提醒您, 为了系统连贯性的学习ES6的基础知识,建议您从我的博客第一章开始阅读,当然,如果您对对应的知识已经有所了解,那么可以跳转到任意章节阅读,每一篇博客名中均有介绍该博客中涉及到的ES6的内容.</p>
<p>阮一峰老师的这本书是开源的，在其官方博客就可以下载到，但是我强烈建议大家去购买一本书, 一是方便自己查阅ES6中新增的众多API, 二也是表达一下对大神的敬仰.</p>
<h1 id="ES6加强了对Unicode的支持-并扩展了字符串对象"><a href="#ES6加强了对Unicode的支持-并扩展了字符串对象" class="headerlink" title="ES6加强了对Unicode的支持,并扩展了字符串对象"></a>ES6加强了对Unicode的支持,并扩展了字符串对象</h1><p>ES6对Unicode的主要的新增支持是,已经开始支持32位的字符了,要知道在之前,32位的字符是会被JS判定为两个字符的.</p>
<p>codePointAt()方法,可以很方便地判定字符是由2字节还是4字节组成</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">let a = &apos;\uD842\uDFB7&apos;</div><div class="line">console.log(a);  // 𠮷 在ES5中会被判定为两个字符</div><div class="line">let b = &apos;\u20BB7&apos;</div><div class="line">let c = &apos;\u&#123;20BB7&#125;&apos;</div><div class="line">console.log(b) // □7  未被识别</div><div class="line">console.log(c) // 𠮷</div><div class="line">let d = &apos;𠮷a&apos;</div><div class="line">console.log(d.length) // 3 把第一个字符当两个字符了</div><div class="line">console.log(d.charAt(0)) // 乱码</div><div class="line">console.log(d.charAt(1)) // 乱码</div><div class="line">console.log(d.charAt(2)) // a</div><div class="line">console.log(d.charAt(3)) // </div><div class="line">console.log(d.codePointAt(0)) // 134071</div><div class="line">console.log(d.codePointAt(1)) // 57271</div></pre></td></tr></table></figure>
<p>要知道在之前es5中定义的fromCharCode()方法中,只能够识别16位的字符,并将其转换为相应字符,但是当我们需要进行32位字符码点转换为字符的时候,就无能为力了,这个时候ES6定义了一个新的方法: fromCodePoint()</p>
<p>在ES6中新定义的for-of循环可以实现识别使用32位编码的字符</p>
<p>for of 循环也是ES6中新定义的循环方式,可以用来遍历数组,遍历的同时不同于for  in循环,for of循环不会遍历到你定义的原型上的可枚举属性,去除了for in循环的糟粕, 同时也避免了forEach循环不能跳出循环队列的问题,for of是可以随时跳出循环队列的. 同样的for of循环也可以遍历数组,对象等.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">let text = String.fromCodePoint(0x20bb7);</div><div class="line">for (let i = 0; i &lt; text.length; i++) &#123;</div><div class="line">	console.log(text[i])  // 乱码</div><div class="line">	console.log(i)  // 1</div><div class="line">&#125;</div><div class="line">for (let i of text) &#123;</div><div class="line">	console.log(i)  // 𠮷</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>ES5为字符串对象提供了charAt方法,返回给定位置的字符,该方法不能识别码点大于0xFFFF的字符</p>
<p>因此,ES7定义了at方法,用于识别码点大于0xFFFF的字符</p>
<p>但是,现在谷歌浏览器暂不支持, 需要通过babel转码</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">console.log(&apos;𠮷a&apos;.charAt(0)) // 乱码</div><div class="line">console.log(&apos;𠮷&apos;.at(0))  // 报错</div></pre></td></tr></table></figure>
<p>ES6新增了一些查找字符串的相应方法</p>
<blockquote>
<p>  includes() 返回布尔值,表示是否找到了参数字符串<br>  startsWith() 返回布尔值,表示字符串是否在元字符串的头部<br>  endsWith()  返回布尔值,表示参数自粗换是否在源字符串的头部<br>  repeat()  返回一个新字符串,表示将原字符串重复n次</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">var str = &apos;hello&apos;</div><div class="line">console.log(str.startsWith(&apos;he&apos;)) // true</div><div class="line">console.log(str.endsWith(&apos;lo&apos;)) // true</div><div class="line">console.log(str.includes(&apos;lo&apos;)) // true</div><div class="line">console.log(str.repeat(3))  // hellohellohello</div></pre></td></tr></table></figure>
<h1 id="ES6的模板字符串"><a href="#ES6的模板字符串" class="headerlink" title="ES6的模板字符串"></a>ES6的模板字符串</h1><p>使用变量直接添加到相应的字符串中 用法很简单,添加到相应的字符串中</p>
<p>需要注意的是,使用模板字符串的时候,需要使用反向引号将整体的字符串引起来,否则是无效的</p>
<p>模板字符串,其实就是模块化了的,放在${}里面的js代码</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">let name = &apos;Bob&apos;,</div><div class="line">	time = &apos;today&apos;</div><div class="line">console.log(`hello $&#123;name&#125;, how are you $&#123;time&#125;?`) </div><div class="line">// hello Bob, how are you today?</div><div class="line">console.log(&apos;hello $&#123;name&#125;&apos;) </div><div class="line">// hello $&#123;name&#125;</div></pre></td></tr></table></figure>
<p>模板字符串还拥有更加灵活的用法</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">let a = 1,</div><div class="line">	b = 2;</div><div class="line">console.log(`$&#123;a&#125; + $&#123;b&#125; = $&#123;a+b&#125;`)  // 1 + 2 = 3</div><div class="line"></div><div class="line">function foo() &#123;</div><div class="line">	return &apos;hello&apos;</div><div class="line">&#125;</div><div class="line"></div><div class="line">console.log(`$&#123;foo()&#125; world`) // hello world</div></pre></td></tr></table></figure>
<p>(完)</p>
]]></content>
    
    <summary type="html">
    
      本系列为在我读完阮一峰老师的《ES6标准入门》第二版之后，所做的阅读笔记的整理。 系列博客将采用一个一个的样例，来说明书中的精华部分（当然，这只是我认为的），同时引导新手，快速入门ES6，并逐步将其投入到生产实践中。
    
    </summary>
    
      <category term="ES6标准入门" scheme="https://github.com/ChangerHe/categories/ES6%E6%A0%87%E5%87%86%E5%85%A5%E9%97%A8/"/>
    
    
      <category term="ES6" scheme="https://github.com/ChangerHe/tags/ES6/"/>
    
      <category term="Unicode" scheme="https://github.com/ChangerHe/tags/Unicode/"/>
    
  </entry>
  
  <entry>
    <title>理解Node.js里的process.nextTick()</title>
    <link href="https://github.com/ChangerHe/2017/06/19/%E7%90%86%E8%A7%A3Nodejs%E9%87%8C%E7%9A%84process-nextTick/"/>
    <id>https://github.com/ChangerHe/2017/06/19/理解Nodejs里的process-nextTick/</id>
    <published>2017-06-19T12:00:32.000Z</published>
    <updated>2017-09-17T12:25:37.601Z</updated>
    
    <content type="html"><![CDATA[<p>Nodejs的事件驱动,异步IO模型另异步编程变得异常风行,它借助了异步IO模型及V8高性能引擎,突破了单线程的性能瓶颈. 让Jacascript在后端达到了其应有的使用价值. </p>
<p>另外一方面,它也统一了前后端的javascript编程模型.</p>
<p>异步编程也给前端程序猿带来了诸多的痛苦和不适应. 这也是我今天着重想提<code>process.nextTick()</code>这个API的原因之一.</p>
<h1 id="异常处理"><a href="#异常处理" class="headerlink" title="异常处理"></a>异常处理</h1><p>在过去,我们处理异常一般使用try catch fanily这个语句块进行异常捕获和处理</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">try &#123;</div><div class="line">	JSON.parse(jsonObj)</div><div class="line">&#125; catch(e) &#123;</div><div class="line">	// do something...</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>但是这个方法对异步编程而言是并不适用的, 举个很简单的例子,也是我们在日常开发中常常使用的一个小技巧: 当我们想要某个在文档中间的语句块在整个脚本的最后执行的时候,可以使用setTimeout将这个语句块包起来,将延时时间设为0, 那么这个时候它就会等待所有同步的进程全部执行完毕之后再执行.</p>
<p>在try中,我们进行异步的方式处理JSON.parse的时候,那么它也会被放到文档流的最后执行而try catch先执行了,这就是导致出现这个问题的原因</p>
<p>那么这个时候,就需要们的主角登场了</p>
<p>同样的,我们再来一个例子</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">function foo() &#123;</div><div class="line">	console.error(&apos;foo&apos;);</div><div class="line">&#125;</div><div class="line">process.nextTick(foo);</div><div class="line">console.error(&apos;bar&apos;);</div></pre></td></tr></table></figure>
<p>运行上面的代码，你从下面终端打印的信息会看到，”bar”的输出在“foo”的前面。这就验证了上面的说法，foo()是在下一个时间点运行的。</p>
<p>但在内部的处理机制上，process.nextTick()和setTimeout(fn, 0)是不同的，process.nextTick()不是一个单纯的延时，他有更多的 特性。</p>
<p>更精确的说，process.nextTick()定义的调用会创建一个新的子堆栈。在当前的栈里，你可以执行任意多的操作。但一旦调用netxTick，函数就必须返回到父堆栈。然后事件轮询机制又重新等待处理新的事件，如果发现nextTick的调用，就会创建一个新的栈。</p>
<p>下面我们来看看，什么情况下使用process.nextTick()：</p>
<h1 id="在多个事件里交叉执行CPU运算密集型的任务："><a href="#在多个事件里交叉执行CPU运算密集型的任务：" class="headerlink" title="在多个事件里交叉执行CPU运算密集型的任务："></a>在多个事件里交叉执行CPU运算密集型的任务：</h1><p>在下面的例子里有一个compute()，我们希望这个函数尽可能持续的执行，来进行一些运算密集的任务。</p>
<p>但与此同时，我们还希望系统不要被这个函数堵塞住，还需要能响应处理别的事件。这个应用模式就像一个单线程的web服务server。在这里我们就可以使用process.nextTick()来交叉执行compute()和正常的事件响应。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">var http = require(&apos;http&apos;);</div><div class="line"></div><div class="line">function compute() &#123;</div><div class="line">    // performs complicated calculations continuously</div><div class="line">    // ...</div><div class="line">    process.nextTick(compute);</div><div class="line">&#125;</div><div class="line"> </div><div class="line">http.createServer(function(req, res) &#123;</div><div class="line">     res.writeHead(200, &#123;&apos;Content-Type&apos;: &apos;text/plain&apos;&#125;);</div><div class="line">     res.end(&apos;Hello World&apos;);</div><div class="line">&#125;).listen(5000, &apos;127.0.0.1&apos;);</div><div class="line"> </div><div class="line">compute();</div></pre></td></tr></table></figure>
<p>在这种模式下，我们不需要递归的调用compute()，我们只需要在事件循环中使用process.nextTick()定义compute()在下一个时间点执行即可。在这个过程中，如果有新的http请求进来，事件循环机制会先处理新的请求，然后再调用compute()。反之，如果你把compute()放在一个递归调用里，那系统就会一直阻塞在compute()里，无法处理新的http请求了。你可以自己试试。</p>
<p>当然，我们无法通过process.nextTick()来获得多CPU下并行执行的真正好处，这只是模拟同一个应用在CPU上分段执行而已。</p>
<h1 id="保持回调函数异步执行的原则"><a href="#保持回调函数异步执行的原则" class="headerlink" title="保持回调函数异步执行的原则"></a>保持回调函数异步执行的原则</h1><p>当你给一个函数定义一个回调函数时，你要确保这个回调是被异步执行的。下面我们看一个例子，例子中的回调违反了这一原则：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">function asyncFake(data, callback) &#123;  </div><div class="line">    if(data === &apos;foo&apos;) callback(true);</div><div class="line">    else callback(false);</div><div class="line">&#125;</div><div class="line"> </div><div class="line">asyncFake(&apos;bar&apos;, function(result) &#123;</div><div class="line">    // this callback is actually called synchronously!</div><div class="line">&#125;);</div></pre></td></tr></table></figure>
<p>为什么这样不好呢？我们来看Node.js 文档里一段代码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">var client = net.connect(8124, function() &#123; </div><div class="line">    console.log(&apos;client connected&apos;);</div><div class="line">    client.write(&apos;world!\r\n&apos;);</div><div class="line">&#125;);</div></pre></td></tr></table></figure>
<p>在上面的代码里，如果因为某种原因，net.connect()变成同步执行的了，回调函数就会被立刻执行，因此回调函数写到客户端的变量就永远不会被初始化了。</p>
<p>这种情况下我们就可以使用process.nextTick()把上面asyncFake()改成异步执行的：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">function asyncReal(data, callback) &#123;</div><div class="line">    process.nextTick(function() &#123;</div><div class="line">        callback(data === &apos;foo&apos;);   </div><div class="line">    &#125;);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h1 id="用在事件触发过程中"><a href="#用在事件触发过程中" class="headerlink" title="用在事件触发过程中"></a>用在事件触发过程中</h1><p>来看一个例子，你想写一个库实现这样的功能：从源文件里读取数据，当读取完毕后，触发一个事件同时传递读取的数据。可能你会这样写：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">var EventEmitter = require(&apos;events&apos;).EventEmitter;</div><div class="line"> </div><div class="line">function StreamLibrary(resourceName) &#123; </div><div class="line">    this.emit(&apos;start&apos;);</div><div class="line"> </div><div class="line">    // read from the file, and for every chunk read, do: </div><div class="line">    this.emit(&apos;data&apos;, chunkRead);      </div><div class="line">&#125;</div><div class="line">StreamLibrary.prototype.__proto__ = EventEmitter.prototype;   </div><div class="line">// inherit from EventEmitter</div></pre></td></tr></table></figure>
<p>下面是一段调用这个库的客户端程序，我们想在程序中监听这些事件：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">var stream = new StreamLibrary(&apos;fooResource&apos;);</div><div class="line"> </div><div class="line">stream.on(&apos;start&apos;, function() &#123;</div><div class="line">    console.log(&apos;Reading has started&apos;);</div><div class="line">&#125;);</div><div class="line"> </div><div class="line">stream.on(&apos;data&apos;, function(chunk) &#123;</div><div class="line">    console.log(&apos;Received: &apos; + chunk);</div><div class="line">&#125;);</div></pre></td></tr></table></figure>
<p>但是上面的代码中，将永远接收不到“start”事件，因为在这个库实例化的时候，“start”事件会被立刻触发执行，但此时事件的回调函数还没有准备好，所以在客户端根本无法接收到这个事件。同样，我们可以用process.nextTick()来改写事件触发的过程，下面是一个正确的版本：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">function StreamLibrary(resourceName) &#123;      </div><div class="line">    var self = this;</div><div class="line"> </div><div class="line">    process.nextTick(function() &#123;</div><div class="line">        self.emit(&apos;start&apos;);</div><div class="line">    &#125;);</div><div class="line"> </div><div class="line">    // read from the file, and for every chunk read, do:</div><div class="line">    this.emit(&apos;data&apos;, chunkRead);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>(文章部分引用了网上内容)</p>
]]></content>
    
    <summary type="html">
    
      Nodejs的事件驱动,异步IO模型另异步编程变得异常风行,它借助了异步IO模型及V8高性能引擎,突破了单线程的性能瓶颈. 让Jacascript在后端达到了其应有的使用价值.  另外一方面,它也统一了前后端的javascript编程模型.
    
    </summary>
    
      <category term="Nodejs学习笔记" scheme="https://github.com/ChangerHe/categories/Nodejs%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="Nodejs" scheme="https://github.com/ChangerHe/tags/Nodejs/"/>
    
      <category term="process.nextTick()" scheme="https://github.com/ChangerHe/tags/process-nextTick/"/>
    
  </entry>
  
  <entry>
    <title>《ES6标准入门》阅读笔记———解构赋值</title>
    <link href="https://github.com/ChangerHe/2017/06/18/%E3%80%8AES6%E6%A0%87%E5%87%86%E5%85%A5%E9%97%A8%E3%80%8B%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0%E2%80%94%E2%80%94%E2%80%94%E8%A7%A3%E6%9E%84%E8%B5%8B%E5%80%BC/"/>
    <id>https://github.com/ChangerHe/2017/06/18/《ES6标准入门》阅读笔记———解构赋值/</id>
    <published>2017-06-18T13:21:39.000Z</published>
    <updated>2017-09-18T00:40:26.230Z</updated>
    
    <content type="html"><![CDATA[<h1 id="写在前面"><a href="#写在前面" class="headerlink" title="写在前面"></a>写在前面</h1><p>本系列为在我读完阮一峰老师的《ES6标准入门》第二版之后，所做的阅读笔记的整理。</p>
<p>许多初学ES6, 同时和我一样初次阅读阮老师的这本书的时候, 读第一遍会越发的困惑, 因为阮老师上面说的很多的定义,方法,之前都是没有见过的, 读到后面才发现, 哦~原来是这样.</p>
<p>有一句话叫做”大神的世界我们不懂”, 所以我在初读第一遍《ES6标准入门》这本书的时候,也是踩了不少坑,读书的时候查阅了不少的资料.</p>
<p>所以,在这一系列的笔记教程中,我会从一个初学者的角度,向您讲述ES6的相关知识,在后面介绍的知识我会尽量不提前用,即使提前使用,也会同时做好标注,避免了阅读时各种查阅资料的烦恼.</p>
<p>系列博客将采用一个一个的样例，来说明书中的精华部分（当然，这只是我认为的），同时引导新手，快速入门ES6，并逐步将其投入到生产实践中。</p>
<p>同时,在阅读前也提醒您, 为了系统连贯性的学习ES6的基础知识,建议您从我的博客第一章开始阅读,当然,如果您对对应的知识已经有所了解,那么可以跳转到任意章节阅读,每一篇博客名中均有介绍该博客中涉及到的ES6的内容.</p>
<p>阮一峰老师的这本书是开源的，在其官方博客就可以下载到，但是我强烈建议大家去购买一本书, 一是方便自己查阅ES6中新增的众多API, 二也是表达一下对大神的敬仰.</p>
<h1 id="什么是解构赋值"><a href="#什么是解构赋值" class="headerlink" title="什么是解构赋值?"></a>什么是解构赋值?</h1><p>ES6允许我们按照一定模式,从数组和对象中提取值,对变量进行赋值,这被称为解构</p>
<p>解构赋值可将数组的元素或对象的属性赋予给另一个变量，该变量的定义语法与数组字面量或对象字面量很相似。此语法非常简洁，相比于传统的属性访问方式，更加直观清晰。</p>
<p>在不使用解构赋值的情况下，通常我们这样访问数组中的元素：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">var first = arr[0];  </div><div class="line">var second = arr[1];  </div><div class="line">var third = arr[2];</div></pre></td></tr></table></figure>
<p>使用解构赋值后，代码得到了极大的简化，同时可读性也更强：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">var [first, second, third] = arr;</div></pre></td></tr></table></figure>
<p>以上代码的作用和上面的实例代码是一样的,声明三个变量,存储数组arr中的前三位的内容.</p>
<h1 id="数组的解构赋值"><a href="#数组的解构赋值" class="headerlink" title="数组的解构赋值"></a>数组的解构赋值</h1><p>我们将数组的对应位置定义好变量,同时在相同位置定义好对应值,就可以完成赋值操作</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">let [foo, [[bar], baz]] = [1,[[2],3]]</div><div class="line">console.log(foo, bar, baz)   // 1 2</div></pre></td></tr></table></figure>
<p>当我们对变量解构赋值的时候,不想赋值的地方可以使用空数组的键值代替.当需要使用一个变量匹配后面的所有未匹配数组的时候,使用三个点号代替</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">let [head, ...tail] = [1,2,3,4,5,6]</div><div class="line">console.log(head, tail)  // 1  [2,3,4,5,6]</div><div class="line">let [x, y, ...z] = [&apos;a&apos;];</div><div class="line">console.log(x,y,z)  // a undefined []</div></pre></td></tr></table></figure>
<p>三个点号也是ES6中的新语法, 在阮一峰老师的书中有两种叫法,一个叫做扩展运算符,一个叫做rest参数, 但是我觉得三点运算符好像更加的形象贴切啊哈哈. 当然,这个三点运算符会在数组这一章进行具体讲解.</p>
<p>解构不成功,表示右边的值不足以匹配左边的值,不完全解构,表示右边的值超出要赋予的左边的值<br>当出现如下情况的时候,f是只能匹配第一个数组元素的</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">let [e,[f],g] = [1,[2,3],4]</div><div class="line">console.log(e,f,g)   //1 2 4</div></pre></td></tr></table></figure>
<p>需要注意的是,当等号的右边不是数组,或者严格的说,不是可以遍历的结构的时候,是会报错的.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">let [a] = 1  // 报错</div></pre></td></tr></table></figure>
<p>对于解构赋值,我们可以使用Set结构,也可以使用数组的解构赋值</p>
<p>那么这里再解释一下啥叫set结构,ES6提供了一种新的数据结构Set,类似于数组,但成员值是唯一的,没有重复值. set本身是一个构造函数,用来生成set数据结构.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">let [h,i,j] = new Set([&apos;a&apos;,&apos;b&apos;,&apos;c&apos;])</div><div class="line">console.log(h,i,j)  // a b c</div></pre></td></tr></table></figure>
<p>解构赋值也允许使用默认值,所以,当我们为其不传值,或者传值为undefined的时候,是会使用默认值的</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">let [foo = true] = [undefined]</div><div class="line">console.log(foo)  // true</div></pre></td></tr></table></figure>
<p>但是因为ES6修复了很多之前因为 null == Object 而导致的许多问题,所以,在ES6中,因为其内部的判定机制,如果所属的值不严格等于undefined,那么其值为null的时候,是可以进行赋值的</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">let [foo = true] = [null]</div><div class="line">console.log(foo)</div></pre></td></tr></table></figure>
<h1 id="对象的解构赋值"><a href="#对象的解构赋值" class="headerlink" title="对象的解构赋值"></a>对象的解构赋值</h1><p>同样的,解构赋值也支持对对象的解构赋值</p>
<p>对象不同于数组,数组是按次序排列的,但是对象的属性时没有次序的,只能通过查找对象的键值来找到相应的值</p>
<p>在这里可能很多童鞋就有点懵逼了,为啥对象你写个名字,不赋值都行啊?</p>
<p>那么这里还是要再补充一下,ES6新增了一种对象的表示方法,  允许在对象之中，直接写变量。这时，属性名为变量名, 属性值为变量的值。也就是说:</p>
<blockquote>
<p><code>{bar, foo} === {bar: bar, foo: foo}</code></p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">var &#123;bar, foo&#125; = &#123;foo: &apos;aaa&apos;, bar: &apos;bbb&apos;&#125;</div><div class="line">console.log(foo)  // bbb</div><div class="line">console.log(bar)  // aaa</div></pre></td></tr></table></figure>
<p>需要注意的是,我们给对象进行解构赋值的时候,其实是赋值给了对象的键值,对象的键名是不会改变的.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">let obj = &#123;first: &apos;hello&apos;, last: &apos;world&apos;&#125;;</div><div class="line">let &#123;first: i, last: j&#125; = obj</div><div class="line">console.log(i, j) // hello  world</div></pre></td></tr></table></figure>
<p>那么还有一个问题就是,进行解构赋值的时候,我们必须将声明和赋值写在一起,不写在一起的话就会报错</p>
<p>在书写的时候有一个小坑也需要注意一下</p>
<p>当我们不加圆括号而是直接使用花括号的话,javascript引擎会把{foo}人为是一个语法块,从而不会正常进行语句的解构</p>
<p>那么解决办法就是将整条语句使用圆括号括起来,从而让引擎正确理解这条语句</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">let foo</div><div class="line">(&#123;foo&#125; = &#123;foo: 1&#125;)</div><div class="line">console.log(foo) // 1</div></pre></td></tr></table></figure>
<h1 id="使用解构赋值的小技巧"><a href="#使用解构赋值的小技巧" class="headerlink" title="使用解构赋值的小技巧"></a>使用解构赋值的小技巧</h1><p>当我们频繁使用某一个函数或是语句的时候,我们可以使用解构赋值,获得相应的更简便的书写方法</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">let &#123;logl, sin, cos&#125; = Math;</div><div class="line">console.log(cos(60))</div><div class="line">let &#123;log, dir, debug&#125; = console</div><div class="line">log(log)</div></pre></td></tr></table></figure>
<p>对应此方法,字符串也可以进行解构赋值,此时字符串被转换成了一个类似数组的对象</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">const str = &apos;abcd&apos;</div><div class="line">const [a, b, c, d] = str;</div><div class="line">const &#123;length: len&#125; = str</div><div class="line">console.log(a,b,c,d) // a b c d</div><div class="line">console.log(len)  // 4</div></pre></td></tr></table></figure>
<p>当等号右边是数值或布尔值的时候,会转换为对象,因此也拥有了此类的对象相应的方法和属性</p>
<p>需要注意的是,每个内部类型对象的构造函数中都是拥有toString的方法的</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">const &#123;toString: s&#125; = 123;</div><div class="line">console.log(s === Number.prototype.toString) // true</div><div class="line">console.log(s === Object.prototype.toString) // false</div></pre></td></tr></table></figure>
<h2 id="变量解构赋值在函数参数中的应用"><a href="#变量解构赋值在函数参数中的应用" class="headerlink" title="变量解构赋值在函数参数中的应用"></a>变量解构赋值在函数参数中的应用</h2><p>函数的参数也是可以参与到解构赋值中的</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">function add([x, y]) &#123;</div><div class="line">	return x + y;</div><div class="line">&#125;</div><div class="line">console.log(add([1,2]))</div></pre></td></tr></table></figure>
<p>我们可以将函数的返回值作为解构赋值的值来进行使用</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">function example() &#123;</div><div class="line">	return [1,2,3]</div><div class="line">&#125;</div><div class="line">var [a,b,c] = example()</div><div class="line">console.log(a,b,c)</div></pre></td></tr></table></figure>
<p>同样的,不仅能使用函数的返回值,还可以使用解构赋值给函数赋值</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">function f([x,y,z])&#123;&#125;</div><div class="line">f([1,2,3])</div><div class="line">function j(&#123;x,y,z&#125;)&#123;&#125;</div><div class="line">j(&#123;x: 1,y: 2, z: 3&#125;)</div></pre></td></tr></table></figure>
<p>因为解构赋值的特性,因此其对提取json数据有奇效</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">var jsonData = &#123;</div><div class="line">	id: 42,</div><div class="line">	status: &apos;OK&apos;,</div><div class="line">	data: [123,432]</div><div class="line">&#125;</div><div class="line">let &#123;id, status, data&#125; = jsonData</div><div class="line">console.log(id, status, data) // 42 OK [123, 432]</div></pre></td></tr></table></figure>
<p>遍历Map结构</p>
<p>Map结构也是ES6中定义的新的数据结构,它类似于对象,也是键值对的集合,但是键的范围不限于字符串,各种类型的值都可以当做键</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">var map = new Map();</div><div class="line">map.set(&apos;first&apos;, &apos;hello&apos;);</div><div class="line">map.set(&apos;second&apos;, &apos;world&apos;)</div><div class="line">for(let [key, value] of map) &#123;</div><div class="line">	console.log(key + &apos; is &apos; + value)</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>(完)</p>
]]></content>
    
    <summary type="html">
    
      本系列为在我读完阮一峰老师的《ES6标准入门》第二版之后，所做的阅读笔记的整理。 系列博客将采用一个一个的样例，来说明书中的精华部分（当然，这只是我认为的），同时引导新手，快速入门ES6，并逐步将其投入到生产实践中。
    
    </summary>
    
      <category term="ES6标准入门" scheme="https://github.com/ChangerHe/categories/ES6%E6%A0%87%E5%87%86%E5%85%A5%E9%97%A8/"/>
    
    
      <category term="ES6" scheme="https://github.com/ChangerHe/tags/ES6/"/>
    
      <category term="解构赋值" scheme="https://github.com/ChangerHe/tags/%E8%A7%A3%E6%9E%84%E8%B5%8B%E5%80%BC/"/>
    
  </entry>
  
  <entry>
    <title>《ES6标准入门》阅读笔记——let和const</title>
    <link href="https://github.com/ChangerHe/2017/06/17/%E3%80%8AES6%E6%A0%87%E5%87%86%E5%85%A5%E9%97%A8%E3%80%8B%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0%E2%80%94%E2%80%94let%E5%92%8Cconst/"/>
    <id>https://github.com/ChangerHe/2017/06/17/《ES6标准入门》阅读笔记——let和const/</id>
    <published>2017-06-17T13:33:39.000Z</published>
    <updated>2017-09-18T00:40:15.428Z</updated>
    
    <content type="html"><![CDATA[<h1 id="写在前面"><a href="#写在前面" class="headerlink" title="写在前面"></a>写在前面</h1><p>本系列为在我读完阮一峰老师的《ES6标准入门》第二版之后，所做的阅读笔记的整理。</p>
<p>许多初学ES6, 同时和我一样初次阅读阮老师的这本书的时候, 读第一遍会越发的困惑, 因为阮老师上面说的很多的定义,方法,之前都是没有见过的, 读到后面才发现, 哦~原来是这样.</p>
<p>有一句话叫做”大神的世界我们不懂”, 所以我在初读第一遍《ES6标准入门》这本书的时候,也是踩了不少坑,读书的时候查阅了不少的资料.</p>
<p>所以,在这一系列的笔记教程中,我会从一个初学者的角度,向您讲述ES6的相关知识,在后面介绍的知识我会尽量不提前用,即使提前使用,也会同时做好标注,避免了阅读时各种查阅资料的烦恼.</p>
<p>系列博客将采用一个一个的样例，来说明书中的精华部分（当然，这只是我认为的），同时引导新手，快速入门ES6，并逐步将其投入到生产实践中。</p>
<p>同时,在阅读前也提醒您, 为了系统连贯性的学习ES6的基础知识,建议您从我的博客第一章开始阅读,当然,如果您对对应的知识已经有所了解,那么可以跳转到任意章节阅读,每一篇博客名中均有介绍该博客中涉及到的ES6的内容.</p>
<p>阮一峰老师的这本书是开源的，在其官方博客就可以下载到，但是我强烈建议大家去购买一本书, 一是方便自己查阅ES6中新增的众多API, 二也是表达一下对大神的敬仰.</p>
<h1 id="函数的作用域"><a href="#函数的作用域" class="headerlink" title="函数的作用域"></a>函数的作用域</h1><p>要知道，在ES6以前，JS一直都是只有函数作用域，而没有块级作用域的。在这样的情况下，我们大多会使用IIFE（自执行函数表达式）来模拟块级作用域，达到避免全局作用域污染等目的。</p>
<p>那么ES6有新定义了两种变量的定义方式，let和const，两种变量的定义方式均会产生块级作用域，也就是我们使用大括号包起来的区域，都是块级作用域。</p>
<p>let和const两者之间的区别就是，const定义的变量，之后是无法更改的。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">&#123;</div><div class="line">	let a = 10;</div><div class="line">	var b = 1;</div><div class="line">&#125;</div><div class="line">console.log(b)</div><div class="line">console.log(a)   // 报错</div></pre></td></tr></table></figure>
<p>我们在大括号外面去打印a会报错,说明let其实是有块级作用域的,当我们使用循环语句的时候,let来声明变量是一个不错的选择.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">var a = [];</div><div class="line">for (let i = 0; i &lt; 10; i++) &#123;</div><div class="line">	a[i] = function() &#123;</div><div class="line">		console.log(i)</div><div class="line">	&#125;</div><div class="line">&#125;</div><div class="line">a[6]()    // 6</div></pre></td></tr></table></figure>
<p>当我们使用let来进行声明的时候,才能得到想要的值 也就是6</p>
<p>原因是因为,变量i是let声明的,当前的i只在本轮循环有效,所以相当于每一次循环的i都是一个新的变量</p>
<p>let 不和var一样,存在变量的提升,所以我们在没有声明之前调用let声明的变量,会报错</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">console.log(b)   // 报错</div><div class="line">let b = 2;</div></pre></td></tr></table></figure>
<p>还有一点要注意的是,我们在第一行使用var声明了b,在这里再声明,就会报错,因为let和const是不允许变量被重复声明的.</p>
<h1 id="暂时性死区"><a href="#暂时性死区" class="headerlink" title="暂时性死区"></a>暂时性死区</h1><p>只要块级作用域内存在let命令,那么它所声明的变量就绑定了这个区域,不会受外部的影响<br>es6明确规定,只要区块中存在let和const命令,则这个区块对这些命令声明的变量从一开始就形成封闭作用域.只要在声明之前就使用这些变量,就会报错</p>
<p>其实上面那个例子,已经很好地说明了暂时性死区这个概念了.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">var c = 3;</div><div class="line">if(true) &#123;</div><div class="line">	tmp = &apos;abc&apos;  //报错,tmp没有定义</div><div class="line">	let tmp</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>不仅如此,坑爹的是有些死区,你不仔细看真的很难发现</p>
<p>另外补充一点,在函数中进行形式参数的预定义,也就是设置函数的参数默认值,也是ES6中新定义的函数写法,关于此的内容,会在之后在函数篇中详细介绍.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">function bar(x = y, y = 2) &#123;</div><div class="line">	return [x, y]</div><div class="line">&#125;</div><div class="line">bar()  //报错, y is not defined</div></pre></td></tr></table></figure>
<p>当然,我们把上面的代码稍微改一下就不会报错了</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">function bac(y = 2, x = y) &#123;</div><div class="line">	return [x, y]</div><div class="line">&#125;</div><div class="line">console.log(bac()) // [2,2]</div></pre></td></tr></table></figure>
<p>结合上面的介绍,还有一点,当我们在块级作用域的内部再定义块级作用域的时候,就不会报错了.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">function f1() &#123;</div><div class="line">	let n = 5;</div><div class="line">	if (true) &#123;</div><div class="line">		let n = 10;</div><div class="line">	&#125;</div><div class="line">	console.log(n) // 5</div><div class="line">&#125;</div><div class="line">f1()</div></pre></td></tr></table></figure>
<p>讲到这里,我再分享一个坑,关于函数的声明提升问题,当然, 下面这一题我没有直接在题上写答案,大家可以把解析先遮住,思考一下这题的结果是什么.既然是坑, 我觉得新手还是老老实实往上踩几脚比较好.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">let f = function() &#123;</div><div class="line">	console.log(&apos;outside&apos;)</div><div class="line">&#125;</div><div class="line"></div><div class="line">function aaa() &#123;</div><div class="line">	if (false) &#123;</div><div class="line">		function f() &#123;</div><div class="line">			console.log(&apos;inside&apos;)</div><div class="line">		&#125;</div><div class="line"></div><div class="line">	&#125;</div><div class="line">	f()</div><div class="line">&#125;</div><div class="line">aaa()</div></pre></td></tr></table></figure>
<p>万万没想到啊没想到, aaa函数中f()函数的执行居然会报错,而且打印f的值居然是undefined!</p>
<p>这其实是一个函数的作用域提升问题,预编译阶段内部函数f会跨过if判断而提升至函数aaa的作用域顶端</p>
<p>那么可能大家会问,我在aaa函数内部打印f函数,是undefined啊.</p>
<p>因为函数的声明赋值时在if判断语句之内的,所以在此之前仅有一个var f,也就是定义了一个f,但并未对其赋值,所以f打印出来就是undefined.</p>
<h1 id="const和let的具体区别"><a href="#const和let的具体区别" class="headerlink" title="const和let的具体区别"></a>const和let的具体区别</h1><p>我们来看下面这几行代码</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">let f;</div><div class="line">console.log(f);  // undefined</div><div class="line">&#123;</div><div class="line">	let a = &apos;secret&apos;</div><div class="line">	console.log(f)  // undefined</div><div class="line">	f = function() &#123;</div><div class="line">		return a;</div><div class="line">	&#125;</div><div class="line">	console.log(f)  // f() &#123; return a &#125;</div><div class="line">&#125;</div><div class="line">console.log(f());   //secret</div></pre></td></tr></table></figure>
<p>其实上面的代码很好地说明了let的作用域的问题,而且需要注意的是,let的变量值,是可以随时更改的.</p>
<p>而const,就没有这么自由了</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">const PI = 3.14;</div><div class="line">PI = 3;   // 报错</div><div class="line">const foo;  // 定义变量时位对其赋值,报错</div></pre></td></tr></table></figure>
<p>需要注意的是const定义复合类型值的时候,因为复合类型的变量不直接指向数据,而是指向数据所存储的相应内存空间</p>
<p>所以这个时候当我们对相应的内存空间中的值进行更改,只要内存空间不变,则都可以对值进行更改</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">const foo = &#123;&#125;;</div><div class="line">foo.prop = 1;</div><div class="line">console.log(foo.prop)   // 1</div></pre></td></tr></table></figure>
<p>但是呢,,如果我们更改相应的foo指向的内存空间,则就会报错</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">foo = &#123;&#125;  // 报错(接上面的代码实例)</div></pre></td></tr></table></figure>
<p>如果在声明引用类型变量后,我们不想让里面的值改变怎么办呢?</p>
<p>这个时候可以使用Object.freeze()方法,冻结这个对象,包括其内存空间的值</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">const foo1 = Object.freeze(&#123;&#125;);</div><div class="line">foo1.prop = 1;</div><div class="line">console.log(foo1.prop)  // undefined</div></pre></td></tr></table></figure>
<p>这个时候为该对象定义属性和方法,都无效了,但是不会抛出异常</p>
<p>最后需要注意的一点是,即使我们在全局使用let或是const定义变量,变量都不会挂载到全局的window对象上.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">var a = 1</div><div class="line">let b = 2</div><div class="line">const c = 3</div><div class="line"></div><div class="line">console.log(window.a) // 1</div><div class="line">console.log(window.b) // undefined</div><div class="line">console.log(window.c) // undefined</div></pre></td></tr></table></figure>
<p>(完)</p>
]]></content>
    
    <summary type="html">
    
      本系列为在我读完阮一峰老师的《ES6标准入门》第二版之后，所做的阅读笔记的整理。 系列博客将采用一个一个的样例，来说明书中的精华部分（当然，这只是我认为的），同时引导新手，快速入门ES6，并逐步将其投入到生产实践中。
    
    </summary>
    
      <category term="ES6标准入门" scheme="https://github.com/ChangerHe/categories/ES6%E6%A0%87%E5%87%86%E5%85%A5%E9%97%A8/"/>
    
    
      <category term="ES6" scheme="https://github.com/ChangerHe/tags/ES6/"/>
    
      <category term="let" scheme="https://github.com/ChangerHe/tags/let/"/>
    
      <category term="const" scheme="https://github.com/ChangerHe/tags/const/"/>
    
  </entry>
  
  <entry>
    <title>Nodejs的require()模块源码解读</title>
    <link href="https://github.com/ChangerHe/2017/06/16/Nodejs%E7%9A%84require-%E6%A8%A1%E5%9D%97%E6%BA%90%E7%A0%81%E8%A7%A3%E8%AF%BB/"/>
    <id>https://github.com/ChangerHe/2017/06/16/Nodejs的require-模块源码解读/</id>
    <published>2017-06-16T11:44:27.000Z</published>
    <updated>2017-09-16T03:39:33.855Z</updated>
    
    <content type="html"><![CDATA[<p>2009年, nodejs项目诞生,所有模块一律为commonjs格式.</p>
<p>时至今日,Nodejs的包管理npm仓库,已经存放了十万百万级的模块,其中绝大部分都是使用的commonjs格式.</p>
<p>这种格式的核心就是require语句, 模块通过它进行加载.</p>
<h1 id="基本用法"><a href="#基本用法" class="headerlink" title="基本用法"></a>基本用法</h1><p>以下内容翻译自《Node使用手册》</p>
<p>当 Node 遇到 require(X) 时，按下面的顺序处理。</p>
<blockquote>
<p>（1）如果 X 是内置模块（比如 require(‘http’）)<br>　　a. 返回该模块。<br>　　b. 不再继续执行。<br>（2）如果 X 以 “./“ 或者 “/“ 或者 “../“ 开头<br>　　a. 根据 X 所在的父模块，确定 X 的绝对路径。<br>　　b. 将 X 当成文件，依次查找<code>X</code>,找不到之后会查找<code>X .js</code>,再找不到则找<code>X .json</code>,还找不到则找<code>X .node</code>，只要其中有一个存在，就返回该文件，不再继续执行。<br>　　c. 将 X 当成目录，依次查找<code>X /package.json</code>,找不到之后会查找<code>X /index.js</code>,再找不到则找<code>X /index.json</code>,还找不到则找<code>X /index.node</code>，只要其中有一个存在，就返回该文件，不再继续执行。<br>（3）如果 X 不带路径<br>　　a. 根据 X 所在的父模块，确定 X 可能的安装目录。<br>　　b. 依次在每个目录中，将 X 当成文件名或目录名加载。<br>（4） 抛出 “not found”</p>
</blockquote>
<h1 id="Module构造函数"><a href="#Module构造函数" class="headerlink" title="Module构造函数"></a>Module构造函数</h1><p>Module构造函数的部分源码是这样的</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">function Module(id, parent) &#123;</div><div class="line">  this.id = id;</div><div class="line">  this.exports = &#123;&#125;;</div><div class="line">  this.parent = parent;</div><div class="line">  this.filename = null;</div><div class="line">  this.loaded = false;</div><div class="line">  this.children = [];</div><div class="line">&#125;</div><div class="line"></div><div class="line">module.exports = Module;</div><div class="line"></div><div class="line">var module = new Module(filename, parent);</div></pre></td></tr></table></figure>
<p>上面代码中，Node 定义了一个构造函数 Module，所有的模块都是 Module 的实例。可以看到，当前模块（module.js）也是 Module 的一个实例。<br>每个实例都有自己的属性。下面通过一个例子，看看这些属性的值是什么。新建一个脚本文件 a.js 。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">// a.js</div><div class="line"></div><div class="line">console.log(&apos;module.id: &apos;, module.id);  //.</div><div class="line">console.log(&apos;module.exports: &apos;, module.exports); // &#123;&#125;</div><div class="line">console.log(&apos;module.parent: &apos;, module.parent); // null</div><div class="line">console.log(&apos;module.filename: &apos;, module.filename); // 当前文件路径</div><div class="line">console.log(&apos;module.loaded: &apos;, module.loaded); // false</div><div class="line">console.log(&apos;module.children: &apos;, module.children); //</div><div class="line">console.log(&apos;module.paths: &apos;, module.paths);</div></pre></td></tr></table></figure>
<p>可以看到，如果没有父模块，直接调用当前模块，parent 属性就是 null，id 属性就是一个点。filename 属性是模块的绝对路径，path 属性是一个数组，包含了模块可能的位置。另外，输出这些内容时，模块还没有全部加载，所以 loaded 属性为 false 。<br>新建另一个脚本文件 b.js，让其调用 a.js 。</p>
<p>上面代码中，由于 a.js 被 b.js 调用，所以 parent 属性指向 b.js 模块，id 属性和 filename 属性一致，都是模块的绝对路径。</p>
<h1 id="模块实例的-require-方法"><a href="#模块实例的-require-方法" class="headerlink" title="模块实例的 require 方法"></a>模块实例的 require 方法</h1><p>每个模块实例都有一个 require 方法。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">Module.prototype.require = function(path) &#123;</div><div class="line">return Module._load(path, this);</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<p>由此可知，require 并不是全局性命令，而是每个模块提供的一个内部方法，也就是说，只有在模块内部才能使用 require 命令（唯一的例外是 REPL 环境）。另外，require 其实内部调用 Module._load 方法。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div></pre></td><td class="code"><pre><div class="line">Module._load = function(request, parent, isMain) &#123;</div><div class="line"></div><div class="line">//  计算绝对路径</div><div class="line">var filename = Module._resolveFilename(request, parent);</div><div class="line"></div><div class="line">//  第一步：如果有缓存，取出缓存</div><div class="line">var cachedModule = Module._cache[filename];</div><div class="line">if (cachedModule) &#123;</div><div class="line">return cachedModule.exports;</div><div class="line"></div><div class="line">// 第二步：是否为内置模块</div><div class="line">if (NativeModule.exists(filename)) &#123;</div><div class="line">return NativeModule.require(filename);</div><div class="line">&#125;</div><div class="line"></div><div class="line">// 第三步：生成模块实例，存入缓存</div><div class="line">var module = new Module(filename, parent);</div><div class="line">Module._cache[filename] = module;</div><div class="line"></div><div class="line">// 第四步：加载模块</div><div class="line">try &#123;</div><div class="line">module.load(filename);</div><div class="line">hadException = false;</div><div class="line">&#125; finally &#123;</div><div class="line">if (hadException) &#123;</div><div class="line">delete Module._cache[filename];</div><div class="line">&#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">// 第五步：输出模块的exports属性</div><div class="line">return module.exports;</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<p>上面代码中，首先解析出模块的绝对路径（filename），以它作为模块的识别符。然后，如果模块已经在缓存中，就从缓存取出；如果不在缓存中，就加载模块。</p>
<p>因此，Module._load 的关键步骤是两个。</p>
<p>Module._resolveFilename() ：确定模块的绝对路径<br>module.load()：加载模块</p>
<h1 id="模块的绝对路径"><a href="#模块的绝对路径" class="headerlink" title="模块的绝对路径"></a>模块的绝对路径</h1><p>下面是 Module._resolveFilename 方法的源码。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line">Module._resolveFilename = function(request, parent) &#123;</div><div class="line"></div><div class="line">// 第一步：如果是内置模块，不含路径返回</div><div class="line">if (NativeModule.exists(request)) &#123;</div><div class="line">return request;</div><div class="line">&#125;</div><div class="line"></div><div class="line">// 第二步：确定所有可能的路径</div><div class="line">var resolvedModule = Module._resolveLookupPaths(request, parent);</div><div class="line">var id = resolvedModule[0];</div><div class="line">var paths = resolvedModule[1];</div><div class="line"></div><div class="line">// 第三步：确定哪一个路径为真</div><div class="line">var filename = Module._findPath(request, paths);</div><div class="line">if (!filename) &#123;</div><div class="line">var err = new Error(&quot;Cannot find module &apos;&quot; + request + &quot;&apos;&quot;);</div><div class="line">err.code = &apos;MODULE_NOT_FOUND&apos;;</div><div class="line">throw err;</div><div class="line">&#125;</div><div class="line">return filename;</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<p>上面代码中，在 Module.resolveFilename 方法内部，又调用了两个方法 Module.resolveLookupPaths() 和 Module._findPath() ，前者用来列出可能的路径，后者用来确认哪一个路径为真。<br>为了简洁起见，这里只给出 Module._resolveLookupPaths() 的运行结果。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">[   &apos;/home/ruanyf/tmp/node_modules&apos;,</div><div class="line">&apos;/home/ruanyf/node_modules&apos;,</div><div class="line">&apos;/home/node_modules&apos;,</div><div class="line">&apos;/node_modules&apos;</div><div class="line">&apos;/home/ruanyf/.node_modules&apos;,</div><div class="line">&apos;/home/ruanyf/.node_libraries&apos;，</div><div class="line">&apos;$Prefix/lib/node&apos; ]</div></pre></td></tr></table></figure>
<p>上面的数组，就是模块所有可能的路径。基本上是，从当前路径开始一级级向上寻找 node_modules 子目录。最后那三个路径，主要是为了历史原因保持兼容，实际上已经很少用了。<br>有了可能的路径以后，下面就是 Module._findPath() 的源码，用来确定到底哪一个是正确路径。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div></pre></td><td class="code"><pre><div class="line">Module._findPath = function(request, paths) &#123;</div><div class="line"></div><div class="line">// 列出所有可能的后缀名：.js，.json, .node</div><div class="line">var exts = Object.keys(Module._extensions);</div><div class="line"></div><div class="line">// 如果是绝对路径，就不再搜索</div><div class="line">if (request.charAt(0) === &apos;/&apos;) &#123;</div><div class="line">paths = [&apos;&apos;];</div><div class="line">&#125;</div><div class="line"></div><div class="line">// 是否有后缀的目录斜杠</div><div class="line">var trailingSlash = (request.slice(-1) === &apos;/&apos;);</div><div class="line"></div><div class="line">// 第一步：如果当前路径已在缓存中，就直接返回缓存</div><div class="line">var cacheKey = JSON.stringify(&#123;request: request, paths: paths&#125;);</div><div class="line">if (Module._pathCache[cacheKey]) &#123;</div><div class="line">return Module._pathCache[cacheKey];</div><div class="line">&#125;</div><div class="line"></div><div class="line">// 第二步：依次遍历所有路径</div><div class="line">for (var i = 0, PL = paths.length; i &lt; PL; i++) &#123;</div><div class="line">var basePath = path.resolve(paths[i], request);</div><div class="line">var filename;</div><div class="line"></div><div class="line">if (!trailingSlash) &#123;</div><div class="line">// 第三步：是否存在该模块文件</div><div class="line">filename = tryFile(basePath);</div><div class="line"></div><div class="line">if (!filename &amp;&amp; !trailingSlash) &#123;</div><div class="line">// 第四步：该模块文件加上后缀名，是否存在</div><div class="line">filename = tryExtensions(basePath, exts);</div><div class="line">&#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">// 第五步：目录中是否存在 package.json</div><div class="line">if (!filename) &#123;</div><div class="line">filename = tryPackage(basePath, exts);</div><div class="line">&#125;</div><div class="line"></div><div class="line">if (!filename) &#123;</div><div class="line">// 第六步：是否存在目录名 + index + 后缀名</div><div class="line">filename = tryExtensions(path.resolve(basePath, &apos;index&apos;), exts);</div><div class="line">&#125;</div><div class="line"></div><div class="line">// 第七步：将找到的文件路径存入返回缓存，然后返回</div><div class="line">if (filename) &#123;</div><div class="line">Module._pathCache[cacheKey] = filename;</div><div class="line">return filename;</div><div class="line">&#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">// 第八步：没有找到文件，返回false</div><div class="line">return false;</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<p>经过上面代码，就可以找到模块的绝对路径了。<br>有时在项目代码中，需要调用模块的绝对路径，那么除了 module.filename ，Node 还提供一个 require.resolve 方法，供外部调用，用于从模块名取到绝对路径。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">require.resolve = function(request) &#123;</div><div class="line">return Module._resolveFilename(request, self);</div><div class="line">&#125;;</div><div class="line"></div><div class="line">// 用法</div><div class="line">require.resolve(&apos;a.js&apos;)</div><div class="line">// 返回 /home/ruanyf/tmp/a.js</div></pre></td></tr></table></figure>
<h1 id="加载模块"><a href="#加载模块" class="headerlink" title="加载模块"></a>加载模块</h1><p>有了模块的绝对路径，就可以加载该模块了。下面是 module.load 方法的源码。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">Module.prototype.load = function(filename) &#123;</div><div class="line">var extension = path.extname(filename) || &apos;.js&apos;;</div><div class="line">if (!Module._extensions[extension]) extension = &apos;.js&apos;;</div><div class="line">Module._extensions[extension](this, filename);</div><div class="line">this.loaded = true;</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<p>上面代码中，首先确定模块的后缀名，不同的后缀名对应不同的加载方法。下面是 .js 和 .json 后缀名对应的处理方法。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">Module._extensions[&apos;.js&apos;] = function(module, filename) &#123;</div><div class="line">var content = fs.readFileSync(filename, &apos;utf8&apos;);</div><div class="line">module._compile(stripBOM(content), filename);</div><div class="line">&#125;;</div><div class="line"></div><div class="line">Module._extensions[&apos;.json&apos;] = function(module, filename) &#123;</div><div class="line">var content = fs.readFileSync(filename, &apos;utf8&apos;);</div><div class="line">try &#123;</div><div class="line">module.exports = JSON.parse(stripBOM(content));</div><div class="line">&#125; catch (err) &#123;</div><div class="line">err.message = filename + &apos;: &apos; + err.message;</div><div class="line">throw err;</div><div class="line">&#125;</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<p>这里只讨论 js 文件的加载。首先，将模块文件读取成字符串，然后剥离 utf8 编码特有的BOM文件头，最后编译该模块。<br>module._compile 方法用于模块的编译。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">Module.prototype._compile = function(content, filename) &#123;</div><div class="line">var self = this;</div><div class="line">var args = [self.exports, require, self, filename, dirname];</div><div class="line">return compiledWrapper.apply(self.exports, args);</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<p>上面的代码基本等同于下面的形式。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">(function (exports, require, module, __filename, __dirname) &#123;</div><div class="line">// 模块源码</div><div class="line">&#125;);</div></pre></td></tr></table></figure>
<p>也就是说，模块的加载实质上就是，注入exports、require、module三个全局变量，然后执行模块的源码，然后将模块的 exports 变量的值输出。</p>
<p>(以上文章转载自阮一峰博客)</p>
]]></content>
    
    <summary type="html">
    
      Nodejs的require()模块源码解读
    
    </summary>
    
      <category term="Nodejs学习笔记" scheme="https://github.com/ChangerHe/categories/Nodejs%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="Nodejs" scheme="https://github.com/ChangerHe/tags/Nodejs/"/>
    
      <category term="require" scheme="https://github.com/ChangerHe/tags/require/"/>
    
  </entry>
  
  <entry>
    <title>使用Nodejs实现简单的自动化构建</title>
    <link href="https://github.com/ChangerHe/2017/06/15/%E4%BD%BF%E7%94%A8Nodejs%E5%AE%9E%E7%8E%B0%E7%AE%80%E5%8D%95%E7%9A%84%E8%87%AA%E5%8A%A8%E5%8C%96%E6%9E%84%E5%BB%BA/"/>
    <id>https://github.com/ChangerHe/2017/06/15/使用Nodejs实现简单的自动化构建/</id>
    <published>2017-06-15T15:56:30.000Z</published>
    <updated>2017-09-14T14:35:01.695Z</updated>
    
    <content type="html"><![CDATA[<p>自动化构建是现代前端基本都需要的东西,说起这个,大家自然会想到 Glup/Grount这些自动化的构建工具.</p>
<p>当然,本文只是从最最基础的角度,使用Node的fs模块进行了简单的文档的写入操作.</p>
<p>首先,我们先定义一个JSON,用于存放我们想要预先定义的文件夹的内容,比如说,我想要我的文件夹名称为<code>ProjectModule</code> ,里面的文件夹有 <code>css</code> / <code>js</code> / <code>img</code> 还有一个 <code>index.html</code>,同时定义好index文件中的内容</p>
<p>那么我的JSON结构可以这样写</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line">var projectData = &#123;</div><div class="line">    &apos;name&apos; : &apos;ProjectModule&apos;,</div><div class="line">    &apos;fileData&apos;: [</div><div class="line">        &#123;</div><div class="line">            &apos;name&apos;: &apos;css&apos;,</div><div class="line">            &apos;type&apos;: &apos;dir&apos;</div><div class="line">        &#125;,</div><div class="line">        &#123;</div><div class="line">            &apos;name&apos;: &apos;js&apos;,</div><div class="line">            &apos;type&apos;: &apos;dir&apos;</div><div class="line">        &#125;,</div><div class="line">        &#123;</div><div class="line">            &apos;name&apos;: &apos;img&apos;,</div><div class="line">            &apos;type&apos;: &apos;dir&apos;</div><div class="line">        &#125;,</div><div class="line">        &#123;</div><div class="line">            &apos;name&apos;: &apos;index.html&apos;,</div><div class="line">            &apos;type&apos;: &apos;file&apos;,</div><div class="line">            &apos;content&apos;: &apos;&lt;html&gt;\n\t&lt;head&gt;\n\t&lt;title&gt;MyProject&lt;/title&gt;\n\t&lt;/head&gt;\n\t&lt;body&gt;\n\t&lt;/body&gt;\n&lt;/html&gt;&apos;</div><div class="line">        &#125;</div><div class="line">    ]</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>接下来,就是引入fs模块</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">var fs = require(&apos;fs&apos;)</div></pre></td></tr></table></figure>
<p>因为这里是要实时创建的,我们可以直接使用同步的操作,就省去了异步需要使用回调函数的麻烦</p>
<p>当然,开始之前,要先确定一下,JSON是否有正常的给出文件夹的名称</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line">if(projectData.name) &#123;</div><div class="line"></div><div class="line">    fs.mkdirSync(projectData.name)</div><div class="line"></div><div class="line">    var fileData = projectData.fileData</div><div class="line"></div><div class="line">    fileData.forEach(function(f) &#123;</div><div class="line"></div><div class="line">        f.content = f.content? f.content : &apos;&apos;</div><div class="line"></div><div class="line">        f.path = projectData.name + &apos;/&apos; + f.name</div><div class="line"></div><div class="line">        switch (f.type) &#123;</div><div class="line">            </div><div class="line">            case &apos;dir&apos;:</div><div class="line">                fs.mkdirSync(f.path)</div><div class="line">                break;</div><div class="line">            case &apos;file&apos;:</div><div class="line">                fs.writeFileSync(f.path, f.content)</div><div class="line">                break;</div><div class="line">            default:</div><div class="line">                break;</div><div class="line">        &#125;</div><div class="line">    &#125;)</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>如果使用的是webstorm, 那么直接使用ctrl+f9, 让你的node程序跑起来吧~</p>
]]></content>
    
    <summary type="html">
    
      自动化构建是现代前端基本都需要的东西,说起这个,大家自然会想到 Glup/Grount这些自动化的构建工具.
当然,本文只是从最最基础的角度,使用Node的fs模块进行了简单的文档的写入操作.
    
    </summary>
    
      <category term="Nodejs学习笔记" scheme="https://github.com/ChangerHe/categories/Nodejs%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="Nodejs学习笔记" scheme="https://github.com/ChangerHe/tags/Nodejs%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
</feed>
