<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>何庆畅的个人博客|ChangerHe&#39;s Blog</title>
  
  <subtitle>Keep Hungry, Keep Foolish.</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://blog.changerhe.cn/"/>
  <updated>2018-03-07T15:41:11.104Z</updated>
  <id>http://blog.changerhe.cn/</id>
  
  <author>
    <name>ChangerHe</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Objective-c基础学习</title>
    <link href="http://blog.changerhe.cn/2018/03/07/Objective-c%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0/"/>
    <id>http://blog.changerhe.cn/2018/03/07/Objective-c基础学习/</id>
    <published>2018-03-07T13:13:58.000Z</published>
    <updated>2018-03-07T15:41:11.104Z</updated>
    
    <content type="html"><![CDATA[<p>objective-c是乔帮主所开发出来的一种类似于c的面向对象编程语言, 拥有诸多c的优点且支持面相对象的编程方式, 是ios开发的一大利器</p><h2 id="环境准备"><a href="#环境准备" class="headerlink" title="环境准备"></a>环境准备</h2><p>要开发ios是有门槛的, 前提是你必须拥有一台mac电脑, 准确的说, 你的设备必须能够跑得了macos</p><p>在上面的基础上, 还必须要安装好开发所需软件xcode</p><h2 id="hello-world"><a href="#hello-world" class="headerlink" title="hello world"></a>hello world</h2><p>依照惯例, 我们在电脑上面输出一下oc的hello world程序</p><p>首先, 打开xcode, 新建项目, 存储到本机的一个位置上</p><p>然后, 打开这个项目, 点击项目的主文件(main.m)并按住command + r进行编辑, 就可以看到控制台输出了一个hello world啦</p><p>我们可以看到, 代码的整体的骨架是这样子的</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">// 导入mac所提供的库</span><br><span class="line">#import &lt;Foundation/Foundation.h&gt;</span><br><span class="line"></span><br><span class="line">// 程序的主函数, 所有函数都要从这里开始执行</span><br><span class="line">int main(int argc, const char * argv[]) &#123;</span><br><span class="line">@autoreleasepool &#123;</span><br><span class="line">// 所有的代码写在这里</span><br><span class="line">&#125;</span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="oc的变量和表达式"><a href="#oc的变量和表达式" class="headerlink" title="oc的变量和表达式"></a>oc的变量和表达式</h2><p>声明变量的方法和js不同, 变量类型必须要声明对应的类型, 声明类型之后如果没有赋值, 则为默认值</p><p>如, 当我们声明了int类型的a, 并不对其赋值, 最后打印出a的值就是0</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">int a;</span><br><span class="line">int b = 0;</span><br><span class="line">a = 5;</span><br><span class="line">b = 3;</span><br><span class="line">int c = (a + b) * 2</span><br><span class="line">NSLog(@&quot;变量a + 变量b的值是: %d&quot;, c)</span><br></pre></td></tr></table></figure><h2 id="oc的基本数据类型"><a href="#oc的基本数据类型" class="headerlink" title="oc的基本数据类型"></a>oc的基本数据类型</h2><p>int  整型, 数值不超过32位, 也就是大概从-21亿到21亿<br>float 浮点型, 声明的时候建议即使为整数, 也应写上小数点后面的值<br>double 64位浮点型<br>char 8位字符串, 只能包含一个字符<br>NSString: @”Hello world” nsstring类型</p><h2 id="限定词"><a href="#限定词" class="headerlink" title="限定词"></a>限定词</h2><p>long int a 长整型a 32位(在c中原来int是16位, 只能存储数值为五位数左右的数)<br>long long int a 长长整型 64位整形<br>short 等于或小于16位整数<br>unsigned 无符号整形<br>signed 有符号整形<br>指针类型<br>自定义类型<br>万能类型</p><h2 id="逻辑运算符"><a href="#逻辑运算符" class="headerlink" title="逻辑运算符"></a>逻辑运算符</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">if () &#123;&#125; else &#123;&#125;</span><br></pre></td></tr></table></figure><p>if中的条件可以为布尔值, 可以为数字</p><p>goto语句, 当条件成立的时候, 跳转到某个地方</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">int i = 0;</span><br><span class="line">a: &#123;</span><br><span class="line">    i++;</span><br><span class="line">    NSLog(@&quot;i的值为%d&quot;, i);</span><br><span class="line">&#125;</span><br><span class="line">if(i &lt; 5) &#123;</span><br><span class="line">goto a;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上例可导出四次五次打印值</p><h2 id="循环"><a href="#循环" class="headerlink" title="循环"></a>循环</h2><p>当需要多次执行某段代码的时候, 可以使用循环语句</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">int i - 0;</span><br><span class="line">while(i &lt; 5) &#123;</span><br><span class="line">    i++;</span><br><span class="line">    NSLog(@&quot;hello world&quot;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">for(int i; i &lt; 10; i++) &#123;</span><br><span class="line">    NSLog(@&quot;i = %d&quot;, i);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">do &#123;</span><br><span class="line">    NSLog(@&quot;我至少打印一次&quot;);</span><br><span class="line">&#125; while(0) &#123;&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;objective-c是乔帮主所开发出来的一种类似于c的面向对象编程语言, 拥有诸多c的优点且支持面相对象的编程方式, 是ios开发的一大利器&lt;/p&gt;
&lt;h2 id=&quot;环境准备&quot;&gt;&lt;a href=&quot;#环境准备&quot; class=&quot;headerlink&quot; title=&quot;环境准备&quot;
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>ReactNative的mac初始环境配置</title>
    <link href="http://blog.changerhe.cn/2018/03/05/ReactNative%E7%9A%84mac%E5%88%9D%E5%A7%8B%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE/"/>
    <id>http://blog.changerhe.cn/2018/03/05/ReactNative的mac初始环境配置/</id>
    <published>2018-03-05T15:43:27.000Z</published>
    <updated>2018-03-06T15:19:46.897Z</updated>
    
    <content type="html"><![CDATA[<h1 id="基本的环境安装"><a href="#基本的环境安装" class="headerlink" title="基本的环境安装"></a>基本的环境安装</h1><p>首先， 我们使用mac， 当然少不了安装它的开发工具xcode啦， xcode是mac下的ios客户端app开发利器， 我们如果不知道电脑中是否安装了xcode， 可以通过在vim中输入以下的内容进行检查</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">xcode-select --install</span><br></pre></td></tr></table></figure><p>当我们正常安装了Xcode的时候会报错， 提示我们xcode已经正常安装， 但是当我们没有安装的时候， 这行命令就会帮我们进行安装xcode了</p><p>其次， 使用苹果开发， homebrew也是一必备利器， 我们需要使用它来安装watchman和flow</p><p>watchman是facebook的一个开源项目， 用它来监视文件并且记录文件的改动情况</p><p>flow是一个JavaScript静态类型检查器，用于找出JavaScript代码中的类型错误</p><p>最后, 我们需要安装一个<code>yarn</code>作为替代<code>npm</code>的工具, 来进行安装应用, 并设置yarn的默认安装路径为淘宝镜像, 设置好之后我们就可以直接通过使用yarn命令从淘宝国内站点请求到我们需要的数据了</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">yarn config set registry https://registry.npm.taobao.org --global</span><br><span class="line">yarn config set disturl https://npm.taobao.org/dist --global</span><br></pre></td></tr></table></figure><p>安装完这些之后, 就可以先安装一个react-native脚手架出来玩一下啦</p><p>我们使用之前全局安装的react-native命令对脚手进行自动安装</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">react-native init MyAwesomeProject</span><br></pre></td></tr></table></figure><p>当我们需要指定版本的时候, 可以在后面加上一个<code>--version</code>参数, 后面加上版本号就可以安装对应版本的react-native工程了</p><p>安装好之后, 万事俱备只欠东风了, 现在我们进入到项目工程中, 把项目跑起来<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cd MyAwesomeProject</span><br><span class="line">react-native run-ios</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;基本的环境安装&quot;&gt;&lt;a href=&quot;#基本的环境安装&quot; class=&quot;headerlink&quot; title=&quot;基本的环境安装&quot;&gt;&lt;/a&gt;基本的环境安装&lt;/h1&gt;&lt;p&gt;首先， 我们使用mac， 当然少不了安装它的开发工具xcode啦， xcode是mac下的ios客户
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>SASS学习进阶</title>
    <link href="http://blog.changerhe.cn/2018/03/04/testForMac/"/>
    <id>http://blog.changerhe.cn/2018/03/04/testForMac/</id>
    <published>2018-03-04T11:37:41.000Z</published>
    <updated>2018-03-04T11:40:10.039Z</updated>
    
    <content type="html"><![CDATA[<h1 id="sass学习进阶"><a href="#sass学习进阶" class="headerlink" title="sass学习进阶"></a>sass学习进阶</h1><h2 id="if语句"><a href="#if语句" class="headerlink" title="@if语句"></a>@if语句</h2><p>@if是一个SassScript，它可以根据条件来处理样式快，如果条件为true则返回一个样式块，反之false返回另一个样式块。在sass中除了@if单独使用以外，还可以配合@else if 和@else 一起使用。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">@mixin blockOrHidden($boolean: true)&#123;</span><br><span class="line">@if $boolean&#123;</span><br><span class="line">@debug &quot;$boolean is #&#123;$boolean&#125;&quot;;  //@debug指令用于调试</span><br><span class="line">display: block;</span><br><span class="line">&#125;</span><br><span class="line">@else &#123;</span><br><span class="line">@debug &quot;$boolean is #&#123;$boolean&#125;&quot;;  //@debug指令用于调试</span><br><span class="line">display: none;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">.block &#123;</span><br><span class="line">@include blockOrHidden;</span><br><span class="line">&#125;</span><br><span class="line">.hidden &#123;</span><br><span class="line">@include blockOrHidden(false);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>编译出的css为<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">.block &#123;</span><br><span class="line">display: block;</span><br><span class="line">&#125;</span><br><span class="line">.hidden &#123;</span><br><span class="line">display: none;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="for循环"><a href="#for循环" class="headerlink" title="for循环"></a>for循环</h2><p>在制作网格系统的时候，我们都需要使用到.col1~.col12这样的类名，在css中需要一个个去写，但是在sass 中可以很容易地使用@for循环来完成。<br>for循环有两种实现方式<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">@for $i from &lt;start&gt; through &lt;end&gt;</span><br><span class="line">//$i表示变量 start表示起始值 end表示结束值</span><br><span class="line">@for $i form &lt;start&gt; to &lt;end&gt;</span><br><span class="line">//二者区别是，关键字through表示包括end这个数，而to表示不包括end这个数</span><br></pre></td></tr></table></figure></p><p>@for循环在网格系统生成每个格子的class代码<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">$grid-prefix: span;</span><br><span class="line">$grid-width: 60px;</span><br><span class="line">$grid-gutter: 20px;</span><br><span class="line">%grid &#123;</span><br><span class="line">float: left;</span><br><span class="line">margin-left: $grid-gutter /2;</span><br><span class="line">margin-right: $grid-gutter /2;</span><br><span class="line">&#125;</span><br><span class="line">@for $i form 1 through 12 &#123;</span><br><span class="line">.#&#123;$grid-prefix&#125;#&#123;$i&#125;&#123;</span><br><span class="line">width: $grid-width * $i + $grid-gutter * ($i - 1);</span><br><span class="line">@extend %grid;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>编译出的css为<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line">.span1, .span2, .span3, .span4, .span5, .span6, .span7, .span8, .span9, .span10, .span11, .span12 &#123;</span><br><span class="line">float: left;</span><br><span class="line">margin-left: 10px;</span><br><span class="line">margin-right: 10px;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">.span1 &#123;</span><br><span class="line">width: 60px;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">.span2 &#123;</span><br><span class="line">width: 140px;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">.span3 &#123;</span><br><span class="line">width: 220px;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">.span4 &#123;</span><br><span class="line">width: 300px;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">.span5 &#123;</span><br><span class="line">width: 380px;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">.span6 &#123;</span><br><span class="line">width: 460px;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">.span7 &#123;</span><br><span class="line">width: 540px;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">.span8 &#123;</span><br><span class="line">width: 620px;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">.span9 &#123;</span><br><span class="line">width: 700px;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">.span10 &#123;</span><br><span class="line">width: 780px;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">.span11 &#123;</span><br><span class="line">width: 860px;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">.span12 &#123;</span><br><span class="line">width: 940px;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>将上面的实例做一些修改，将@for through方式换成@for to：：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">@for $i from 1 to 13 &#123;</span><br><span class="line">.#&#123;$grid-prefix&#125;#&#123;$i&#125;&#123;</span><br><span class="line">width: $grid-width * $i + $grid-gutter * ($i - 1);</span><br><span class="line">@extend %grid;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="while循环"><a href="#while循环" class="headerlink" title="@while循环"></a>@while循环</h2><p>@while指令也需要SassScript表达式，并且会生成不同的代码块，直到表达式值为false时停止循环。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">$types: 4;</span><br><span class="line">$type-width: 20px;</span><br><span class="line">@while $types &gt; 0&#123;      //等价于while( types = 4 , types &gt; 0);</span><br><span class="line">.while-#&#123;$types&#125;&#123;   //等价于.while-types&#123;</span><br><span class="line">width: $types-width + $types; //等价于width： 20px - types；</span><br><span class="line">&#125;</span><br><span class="line">$types: $types - 1;  //等价于  4--；</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="each循环"><a href="#each循环" class="headerlink" title="@each循环"></a>@each循环</h2><p>@each循环就是去遍历一个列表，然后从列表中取出对应的值。<br>@each命令的形式：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">@each $var in &lt;list&gt;</span><br></pre></td></tr></table></figure></p><p>$var 是一个变量名，list是一个列表，用于进行引用。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">$list: adam john wynn mason kuroir; //列出列表，供下面进行引用</span><br><span class="line">@mixin author-images &#123;</span><br><span class="line">@each $author in $list &#123;</span><br><span class="line">.photo-#&#123;$author&#125;&#123;</span><br><span class="line">background: url(&quot;images/avatars/#&#123;$author&#125;.png&quot;) no-repeat;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">.author-bio &#123;</span><br><span class="line">@include author-images;</span><br><span class="line">&#125;</span><br><span class="line">//编译出的css为</span><br><span class="line">.author-bio .photo-adam &#123;</span><br><span class="line">background: url(&quot;/images/avatars/adam.png&quot;) no-repeat; &#125;</span><br><span class="line">.author-bio .photo-john &#123;</span><br><span class="line">background: url(&quot;/images/avatars/john.png&quot;) no-repeat; &#125;</span><br><span class="line">.author-bio .photo-wynn &#123;</span><br><span class="line">background: url(&quot;/images/avatars/wynn.png&quot;) no-repeat; &#125;</span><br><span class="line">.author-bio .photo-mason &#123;</span><br><span class="line">background: url(&quot;/images/avatars/mason.png&quot;) no-repeat; &#125;</span><br><span class="line">.author-bio .photo-kuroir &#123;</span><br><span class="line">background: url(&quot;/images/avatars/kuroir.png&quot;) no-repeat; &#125;</span><br></pre></td></tr></table></figure></p><h1 id="sass函数"><a href="#sass函数" class="headerlink" title="sass函数"></a>sass函数</h1><h2 id="字符串函数"><a href="#字符串函数" class="headerlink" title="字符串函数"></a>字符串函数</h2><p>sass的字符串函数主要包括两个<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">unquote($string);</span><br><span class="line">//删除字符串中的引号，如果字符串中没有引号，将返回原始字符串。注：unquote()函数只能删除字符串最前和最后的引号，无法删除字符串中间的引号。</span><br><span class="line">quote($string);</span><br><span class="line">//给字符串添加引号，如果字符串中间有引号或空格时，需要用单引号或者双引号括起，否则编译时会报错。</span><br></pre></td></tr></table></figure></p><h2 id="字符串函数To-upper-case-和To-lower-case"><a href="#字符串函数To-upper-case-和To-lower-case" class="headerlink" title="字符串函数To-upper-case()和To-lower-case()"></a>字符串函数To-upper-case()和To-lower-case()</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">To-upper-case():将字符串的小写字母转换成大写字母</span><br><span class="line">To-lower-case():将字符串的啊写字母转换成小写字母</span><br></pre></td></tr></table></figure><h2 id="数字函数"><a href="#数字函数" class="headerlink" title="数字函数"></a>数字函数</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">percentage($value)：将一个不带单位的数转换成百分比值；</span><br><span class="line">round($value)：将数值四舍五入，转换成一个最接近的整数； 0.4999视为0</span><br><span class="line">ceil($value)：将大于自己的小数转换成下一位整数；  0.0001视为1</span><br><span class="line">floor($value)：将一个数去除他的小数部分；   0.0001视为0</span><br><span class="line">abs($value)：返回一个数的绝对值；</span><br><span class="line">min($numbers…)：找出几个数值之间的最小值；</span><br><span class="line">max($numbers…)：找出几个数值之间的最大值；</span><br><span class="line">random(): 获取随机数</span><br></pre></td></tr></table></figure><h2 id="列表函数"><a href="#列表函数" class="headerlink" title="列表函数"></a>列表函数</h2><p>列表函数主要包括一些对列表参数的函数使用，主要包括以下几种：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">length($list)：返回一个列表的长度值； //括号内的值算一个</span><br><span class="line">nth($list, $n)：返回一个列表中指定的某个标签值，$n表示第几个</span><br><span class="line">join($list1, $list2, [$separator])：将两个列给连接在一起，变成一个列表；</span><br><span class="line">append($list1, $val, [$separator])：将某个值放在列表的最后；</span><br><span class="line">zip($lists…)：将几个列表结合成一个多维的列表；</span><br><span class="line">index($list, $value)：返回一个值在列表中的位置值。以1开始</span><br></pre></td></tr></table></figure></p><h2 id="Introspection函数"><a href="#Introspection函数" class="headerlink" title="Introspection函数"></a>Introspection函数</h2><p>Introspection函数包括了几个判断型函数：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">type-of($value)：返回一个值的类型</span><br><span class="line">unit($number)：返回一个值的单位</span><br><span class="line">unitless($number)：判断一个值是否带有单位</span><br><span class="line">comparable($number-1, $number-2)：判断两个值是否可以做加、减和合并</span><br></pre></td></tr></table></figure></p><h2 id="sass-Maps函数"><a href="#sass-Maps函数" class="headerlink" title="sass Maps函数"></a>sass Maps函数</h2><p>借助于map功能，为同一量下，多个有名字的变量进行处理。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">map-get($map,$key)：根据给定的 key 值，返回 map 中相关的值。</span><br><span class="line">map-merge($map1,$map2)：将两个 map 合并成一个新的 map。</span><br><span class="line">map-remove($map,$key)：从 map 中删除一个 key，返回一个新 map。</span><br><span class="line">map-keys($map)：返回 map 中所有的 key。</span><br><span class="line">map-values($map)：返回 map 中所有的 value。</span><br><span class="line">map-has-key($map,$key)：根据给定的 key 值判断 map 是否有对应的 value 值，如果有返回 true，否则返回 false。</span><br><span class="line">keywords($args)：返回一个函数的参数，这个参数可以动态的设置 key 和 value。</span><br></pre></td></tr></table></figure></p><h1 id="sass的-规则"><a href="#sass的-规则" class="headerlink" title="sass的@规则"></a>sass的@规则</h1><p>sass支持所有css3的@规则，以及一些sass专属的规则，也被成为指令。这些规则在sass 中具有不同的功效。</p><h2 id="import规则"><a href="#import规则" class="headerlink" title="@import规则"></a>@import规则</h2><p>sass扩展了css的@import规则，使其能够引入scss和sass文件。所有引入的scss文件和sass文件都会被合并输出一个单一的css文件。被导入的文件中所定义的变量或mixins都可以在主文件中使用。<br>sass会在当前目录下寻找其他sass文件，也可以通过:load_paths选项或在命令行中使用–load-path 选项来制定额外的搜索目录。<br>@import根据文件名引入。默认情况下，它会寻找sass文件并直接引入，但是在少数几种情况下，它会被编译成css的@import规则：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">如果文件的扩展名是 .css。</span><br><span class="line">如果文件名以 http:// 开头。</span><br><span class="line">如果文件名是 url()。</span><br><span class="line">如果 @import 包含了任何媒体查询（media queries）。</span><br></pre></td></tr></table></figure></p><p>如果上述情况都没有出现，且扩展名是.sass或者是.scss，则该名称的sass<br>或scss文件就会被引入。</p><h2 id="media规则"><a href="#media规则" class="headerlink" title="@media规则"></a>@media规则</h2><p>sass中的@media规则和css中的使用规则类似，但它有另外一个功能，可以嵌套在css规则中。有点类似于JS中的冒泡功能一样。如果使用@media指令，他将冒泡到外面。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">.sidebar &#123;</span><br><span class="line">width: 300px;</span><br><span class="line">@media screen and (orientation: landscape)&#123;</span><br><span class="line">width: 500px;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">//编译结果</span><br><span class="line">.sidebar &#123;</span><br><span class="line">width: 300px;</span><br><span class="line">@media screen and (orientation: landscape)&#123;</span><br><span class="line">.sidebar&#123;</span><br><span class="line">width: 500px;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="extend规则"><a href="#extend规则" class="headerlink" title="@extend规则"></a>@extend规则</h2><p>sass中的@extend是用来扩展选择器或占位符（类似于继承）</p><h2 id="at-root规则"><a href="#at-root规则" class="headerlink" title="@at-root规则"></a>@at-root规则</h2><p>@at-root规则从字面上解释就是跳出根元素。当你选择器嵌套多层之后，想让某个选择器跳出，此时就可以使用@at-root。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">.a &#123;</span><br><span class="line">color: red;</span><br><span class="line">.b &#123;</span><br><span class="line">color: orange;</span><br><span class="line">.c &#123;</span><br><span class="line">color:yellow;</span><br><span class="line">@at-root .d &#123;</span><br><span class="line">color: green;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">//编译之后</span><br><span class="line">.a &#123;</span><br><span class="line">color: red;</span><br><span class="line">&#125;</span><br><span class="line">.a .b&#123;</span><br><span class="line">color: orange;</span><br><span class="line">&#125;</span><br><span class="line">.a .b .c &#123;</span><br><span class="line">color:yellow;</span><br><span class="line">&#125;</span><br><span class="line">.d &#123;</span><br><span class="line">color: green;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="debug规则"><a href="#debug规则" class="headerlink" title="@debug规则"></a>@debug规则</h2><p>@debug在sass中是用来调试的，当你在sass的源码中使用了@debug规则之后，sass代码在编译出错时，在命令终端会输出你设置的提示bug：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">@debug 10em + 12em;</span><br><span class="line">//输出内容</span><br><span class="line">Line 1 DEBUG: 22em;</span><br></pre></td></tr></table></figure></p><h2 id="warn规则"><a href="#warn规则" class="headerlink" title="@warn规则"></a>@warn规则</h2><p>@warn 和@debug 类似，用来帮助我们很好的调试sass。</p><h2 id="error"><a href="#error" class="headerlink" title="@error"></a>@error</h2><p>@error 和@debug、@warn 类似，用来帮助我们很好的调试sass。</p>]]></content>
    
    <summary type="html">
    
       sass学习进阶 @if语句 @if是一个SassScript，它可以根据条件来处理样式快，如果条件为true则返回一个样式块，反之false返回另一个样式块。在sass中除了@if单独使用以外，还可以配合@else if 和@else 一起使用。
    
    </summary>
    
      <category term="SASS 学习笔记" scheme="http://blog.changerhe.cn/categories/SASS-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="SASS" scheme="http://blog.changerhe.cn/tags/SASS/"/>
    
  </entry>
  
  <entry>
    <title>Chrome61发布,这新功能怕是没谁了</title>
    <link href="http://blog.changerhe.cn/2017/09/25/Chrome61%E5%8F%91%E5%B8%83,%E8%BF%99%E6%96%B0%E5%8A%9F%E8%83%BD%E6%80%95%E6%98%AF%E6%B2%A1%E8%B0%81%E4%BA%86/"/>
    <id>http://blog.changerhe.cn/2017/09/25/Chrome61发布,这新功能怕是没谁了/</id>
    <published>2017-09-25T15:11:42.000Z</published>
    <updated>2017-11-22T05:36:10.836Z</updated>
    
    <content type="html"><![CDATA[<p>Chrome 61 正式版已于2017年9月6日正式发布，并增加了很多开发者相关的功能。在 Mac、Windows 和 Linux 系统中，Chrome 61 开始支持 WebUSB API，以及 PaymentRequest API。</p><p>高级网络平台 API 支持大多数硬件外设，如键盘、鼠标、打印机和游戏手柄。为了使用教育、科学或工业等专用 USB 外设，用户必须使用系统级权限查找和安装可能不安全的驱动程序和软件。</p><p>当然, 最让人激动的是, chrome已经开始支持ES6的module功能, 原生开始支持模块化开发!</p><h1 id="chrome中使用模块化功能"><a href="#chrome中使用模块化功能" class="headerlink" title="chrome中使用模块化功能"></a>chrome中使用模块化功能</h1><p>Chrome 61 加入了对 JavaScript Module <code>&lt;script type=&quot;module&quot;&gt;</code>的原生支持。Chrome 现在可以并行地获取颗粒化的依赖模块，利用浏览器缓存的优势，在多个页面之间共享模块，并且可以保证脚本按照正确地顺序执行。</p><p>下面是我直接在html文件中写入, 的代码</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;script type=&quot;module&quot;&gt;</span><br><span class="line">import utils from &quot;./test.js&quot;</span><br><span class="line">utils()</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure><p>再看一下我所引入的依赖</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">// 相同目录下的test.js</span><br><span class="line">function utils() &#123;</span><br><span class="line">  console.log(1)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">export default utils</span><br></pre></td></tr></table></figure><p>最后, 我们使用编辑器自带的服务器开启运行, 我使用的是VSCode, 当然, 像webstorm, Hbuilder之类的都自带了服务器</p><p>需要注意的是, 不使用服务器而是直接使用双击打开文件的方式是没有办法体验这种功能的</p><p>最后我们可以看到在chrome61+控制台上打印出了1</p><h1 id="web-share-api"><a href="#web-share-api" class="headerlink" title="web share api"></a>web share api</h1><p>为了让用户把他们喜欢的内容分享到网络上，不得把所有的社交按钮在自己的网站上添加一遍。这让页面变得很臃肿，很可能这些分享按钮和网站的视觉不匹配，并且还要添加来自第三方的代码。</p><p>现在，Android 版的 Chrome 新增了 Web Share API，该 API 可以直接调用原生的分享功能，用户可以很方便的将自己喜欢的文本和链接分享到其他原生 App 上了！</p><p>在之后的版本中，这个 API 还能分享到已安装的 web app 中。直接调用 navigator.share 方法，传递相关的参数，就可以发起分享。其他事情系统会帮你搞定。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">navigator.share(&#123;</span><br><span class="line">  title: document.title, text: &apos;Hello&apos;,</span><br><span class="line">  url: window.location.href</span><br><span class="line">&#125;).then(() =&gt; &#123;</span><br><span class="line">  console.log(&apos;Successful share&apos;);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h1 id="WebUSB"><a href="#WebUSB" class="headerlink" title="WebUSB"></a>WebUSB</h1><p>很多电脑的周边硬件在 Web 平台上都有对应的 API，比如键盘、鼠标、打印机和手柄等等。但是，想要在浏览器中使用某些特殊的用于教育、科研、工业等等 USB 设备很困难，通常需要特殊的驱动才行。</p><p>现在 Chrome 提供了 WebUSB API，在用户授权后，Web 应用可以直接可 USB 设备通信。</p><p>要了解更多, 可登陆google开发者平台了解详情…</p>]]></content>
    
    <summary type="html">
    
      Chrome 61 正式版已于2017年9月6日正式发布，并增加了很多开发者相关的功能。在 Mac、Windows 和 Linux 系统中，Chrome 61 开始支持 WebUSB API，以及 PaymentRequest API。
    
    </summary>
    
      <category term="Chrome" scheme="http://blog.changerhe.cn/categories/Chrome/"/>
    
    
      <category term="Chrome" scheme="http://blog.changerhe.cn/tags/Chrome/"/>
    
  </entry>
  
  <entry>
    <title>微信小程序懒加载的实现</title>
    <link href="http://blog.changerhe.cn/2017/09/21/%E5%BE%AE%E4%BF%A1%E5%B0%8F%E7%A8%8B%E5%BA%8F%E6%87%92%E5%8A%A0%E8%BD%BD%E7%9A%84%E5%AE%9E%E7%8E%B0/"/>
    <id>http://blog.changerhe.cn/2017/09/21/微信小程序懒加载的实现/</id>
    <published>2017-09-21T14:12:23.000Z</published>
    <updated>2017-11-22T05:36:57.777Z</updated>
    
    <content type="html"><![CDATA[<p>近期做了一个微信小程序的项目, 其中涉及到微信小程序的懒加载功能, 第一次做这个功能的感觉真的是让人欲(tou)罢(teng)不(bu)能(yi)啊, 所以在这里做一个小小的总结来分享一下.</p><p>不同于原始的dom操作项目, 现在的现代框架已经将dom操作高度集成到了api中, 采用数据驱动的方式, 来实现对dom的各种处理.</p><p>现在我们回忆一下当初那个青涩的原始时代, 当有懒加载的需求的时候, 我们可以开心地创建一个ajax请求, 将请求参数发送到后台, 后台反馈给我们参数后, 然后我们再开心地操作dom将数据处理后插到页面上.</p><p>“哎呀, 屁股好疼”           —页面上的某个dom节点如是说</p><p>但是在数据驱动, 高度组件化处理ajax的返回参数的时候, 我们该怎么处理这个需求呢?</p><h1 id="微信小程序的scroll-view组件"><a href="#微信小程序的scroll-view组件" class="headerlink" title="微信小程序的scroll-view组件"></a>微信小程序的scroll-view组件</h1><p>说到懒加载, 那么就必须得提到微信的scroll-view组件, 这玩意儿干啥的呢?</p><p>主要的作用还是作为一个载体, 用于设置载体内的内容滚动, 当然, 如果需要在y轴滚动的话, 页面都是有这个功能的, 但是如果直接使用y轴滚动的功能的话, 就无法成功触发相应的事件了.</p><h1 id="wxml的写入方式"><a href="#wxml的写入方式" class="headerlink" title="wxml的写入方式"></a>wxml的写入方式</h1><p>我们将wxml中需要滚动的view外需要再套一层scroll-view方便让器其滚动触发事件</p><p>有一点需要特别特别注意的是, 微信原生提供了bindscrolltolower和bindscrolltoupper这两个api来专门处理对应的滚动触底(最右边或最下边)及滚动触顶(最左边或最上边)事件.</p><p>但是!!!</p><p>这两个事件的触发, 前提是必须要在对应的scroll-view上设置高度才可以的, 不然事件无法触发生效.</p><p>比如说, 针对不同的设备, 我设置了对应的触发高度</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">@media (min-width: 375px) &#123;</span><br><span class="line">  .all-movie&#123;</span><br><span class="line">    height: 1300rpx;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">@media (max-width: 374px) &#123;</span><br><span class="line">  .all-movie&#123;</span><br><span class="line">    height: 1000rpx;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="ajax的请求分析"><a href="#ajax的请求分析" class="headerlink" title="ajax的请求分析"></a>ajax的请求分析</h1><p>在这里要特别说明一下, 因为微信不存在dom操作, 所以我们进行懒加载操作的时候, 其实是将整个页面的所有元素都重新加载了一遍的, 因为插不进去啊(#→⌒→).</p><p>那么这个时候ajax的请求就很成问题了, 我们每次加载, 需要传递不同的参数进去</p><p>那么我的思路就是, 通过在data上挂载变量, 每次请求将变量增加, 然后通过这个变量的值的增加, 每次发起的ajax请求就不一样了, 获取到的值会逐次增加</p><p>微信小程序的ajax创建方式这里就不再赘述了, 官网说的很清楚, 使用wx.request对象很容易搞定</p><p>下面是我写在ajax请求success里面的代码</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">// 获取请求到的数据</span><br><span class="line">var data = res.data</span><br><span class="line">// 将本身setdata的对象直接拿出来, 然后再放进去</span><br><span class="line">var dataCon = &#123;&#125;</span><br><span class="line">// 每产生一次ajax请求, 就要使总和加10, 也就是再请求十条数据</span><br><span class="line">that.data.totalCount += 10</span><br><span class="line">dataCon.dataObj = data</span><br><span class="line">that.setData(dataCon)</span><br></pre></td></tr></table></figure><p>注意上面我是设置了一个data的数据名为totalCount, 初始值我设置其为0, 那么每次产生一次ajax 请求, 则其自加10, 通过totalCount, 在拼接上对应的请求url, 就可以成功取到相应的ajax返回值了.</p><p>到这里可能会有同学要问了, 你这里每次都要重新渲染一下页面, 难道不会增大微信小程序的压力吗? 每次请求的数据都会增加, 页面压力会很大啊</p><p>当然, 既然使用数据驱动的方式来进行开发, 对于这样的场景, 产生较大的数据压力是必然的, 但是微信小程序和浏览器一样, 本身是存在缓存的, 之前请求过的数据, 后面服务器会直接返回403, 就不会产生较大的数据流, 最后产生流量的也就是后面那一小部分的文件数据而已.</p><h1 id="对ajax请求的优化"><a href="#对ajax请求的优化" class="headerlink" title="对ajax请求的优化"></a>对ajax请求的优化</h1><p>以上方法可行肯定是可行的, 但是我们每次做ajax请求, 每次的请求数据都会增多, 那么会不会有一种更加的请求方案呢?</p><p>当然, 我们可以考虑和之前操作dom那样, 每次只请求自己需要的那一部分数据, 之前重复的数据是没有必要再到服务器请求一次的</p><p>我们的url可以这样构建</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">var nextUrl = this.data.requestUrl + &quot;?start=&quot; + this.data.totalCount + &quot;&amp;count=10&quot;</span><br></pre></td></tr></table></figure><p>totalCount表示已经请求的数量, 而count表示每次请求的数量</p><p>很好, 一下减少了不少的ajax请求压力</p><h1 id="优化后的bug处理"><a href="#优化后的bug处理" class="headerlink" title="优化后的bug处理"></a>优化后的bug处理</h1><p>ajax请求的压力确实减少了, 但是现在还有一个问题啊, 你每次都反馈给我十条数据, 我用你给的数据渲染, 岂不是把页面懒加载变成了页面刷新了, 每次请求的数据是不一样了, 但是之前的数据已经不存在了呀</p><p>所以, 我们需要使用一个data上面的变量来存储我们之前请求到的值</p><p>我们将之前的成功回调改写一下</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">// 获取请求到的数据</span><br><span class="line">var data = res.data</span><br><span class="line">// 将本身setdata的对象直接拿出来, 然后再放进去</span><br><span class="line">var dataCon = &#123;&#125;</span><br><span class="line">// 每产生一次ajax请求, 就要使总和加10, 也就是再请求十条数据</span><br><span class="line">that.data.totalCount += 10</span><br><span class="line">var total = &#123;&#125;</span><br><span class="line">// 如果不是第一次请求数据的话,则将两次的数据相加</span><br><span class="line">if (!that.data.isEmpty) &#123;</span><br><span class="line">  total = that.data.dataObj.concat(data)</span><br><span class="line">&#125; else &#123;</span><br><span class="line">  total = data</span><br><span class="line">  // 如果isEmpty为true则将其改为false</span><br><span class="line">  that.data.isEmpty = false </span><br><span class="line">&#125;</span><br><span class="line">dataCon.dataObj = total</span><br><span class="line">that.setData(dataCon)</span><br></pre></td></tr></table></figure><p>这里我们设置了一个全局变量isEmpty, 默认为true, 表示默认为空, 当第一次请求的时候, 将数值存入total中,并将isEmpty改写为false, 之后的每一次请求都是在total中加数据, 我们渲染的话就都是用全局的dataObj这个变量来进行渲染, 即可解决之前的问题.</p><p>更新:<br>    后面有看到因为scroll-view在页面中是无法触发下拉刷新事件的,但后面微信方给出了解决办法: 不用scroll-view , 玛德坑爹</p><pre><code>现在可以直接使用onReachBottom事件,也就是触底事件来处理和进行懒加载, 相比于之前的方法简单了不少, 页面也更加流畅了期待小程序能带了更多更好的东西吧</code></pre>]]></content>
    
    <summary type="html">
    
      近期做了一个微信小程序的项目, 其中涉及到微信小程序的懒加载功能, 第一次做这个功能的感觉真的是让人欲(tou)罢(teng)不(bu)能(yi)啊, 所以在这里做一个小小的总结来分享一下.
    
    </summary>
    
      <category term="微信小程序" scheme="http://blog.changerhe.cn/categories/%E5%BE%AE%E4%BF%A1%E5%B0%8F%E7%A8%8B%E5%BA%8F/"/>
    
    
      <category term="微信小程序" scheme="http://blog.changerhe.cn/tags/%E5%BE%AE%E4%BF%A1%E5%B0%8F%E7%A8%8B%E5%BA%8F/"/>
    
      <category term="WXapplet" scheme="http://blog.changerhe.cn/tags/WXapplet/"/>
    
  </entry>
  
  <entry>
    <title>网站的https证书配置小结</title>
    <link href="http://blog.changerhe.cn/2017/09/05/%E7%BD%91%E7%AB%99%E7%9A%84https%E8%AF%81%E4%B9%A6%E9%85%8D%E7%BD%AE%E6%96%B9%E6%B3%95/"/>
    <id>http://blog.changerhe.cn/2017/09/05/网站的https证书配置方法/</id>
    <published>2017-09-05T05:12:13.000Z</published>
    <updated>2017-11-22T04:45:57.235Z</updated>
    
    <content type="html"><![CDATA[<p>HTTPS（全称：Hyper Text Transfer Protocol over Secure Socket Layer），是以安全为目标的HTTP通道，简单讲是HTTP的安全版。即HTTP下加入SSL层，HTTPS的安全基础是SSL，因此加密的详细内容就需要SSL。 它是一个URI scheme（抽象标识符体系），句法类同http:体系。用于安全的HTTP数据传输。https:URL表明它使用了HTTP，但HTTPS存在不同于HTTP的默认端口及一个加密/身份验证层（在HTTP与TCP之间）。这个系统的最初研发由网景公司(Netscape)进行，并内置于其浏览器Netscape Navigator中，提供了身份验证与加密通讯方法。现在它被广泛用于万维网上安全敏感的通讯，例如交易支付方面。</p><pre><code>----引自百度百科</code></pre><p>那么, https对于提升网站的安全性方面是卓有成效的, 但是这对于我们来说有啥作用呢?</p><p>自2014年以来, 百度就开始宣布, 优先支持对https站点的支持与收录了, 也就是说, 我们使用https的网站会被百度的蜘蛛引擎优先收录, 从而实现百度的搜索排行了.</p><p>还有更重要的一点是, 开发微信小程序和微信公众号的时候, 腾讯的马爸爸不允许我们使用http作为协议传输数据啊, 而且还只能使用默认端口传输数据啊.</p><p>所以, 这样说来, 整一个https证书还是挺有必要的</p><h1 id="话不多说开始干"><a href="#话不多说开始干" class="headerlink" title="话不多说开始干"></a>话不多说开始干</h1><p>首先我们需要到对应的https证书上那边获取到https的证书, 像我这么穷的人自然是买不起大几千的企业版https证书的了, 那么得想办法啊</p><h2 id="踩坑第一步"><a href="#踩坑第一步" class="headerlink" title="踩坑第一步"></a>踩坑第一步</h2><p>雀氏纸尿裤?</p><p>咳咳……</p><p>首先我百度了一下https的证书, 大家都在极力推荐又拍云啊, 然后我去看了看, 我擦还真有</p><p>但是整个流程走下来, 我最想吐槽的就是又拍云的页面混乱的链接了, 控制台不知道在整些什么玩意, 重要的东西完全没有分类好, 申请的话需要各种认证</p><p>先是直接手机验证之后申请, 告诉我申请失败, 也不告知原因, 几次下来我就窝火了, 遂写了个工单上去, 处理工单的工程师告诉我是没有实名认证</p><p>好, 去实名认证呗, 来来回回花了7-8天时间, 总算是申请下来了</p><p>但是!</p><p>我发现淘宝的马爸爸的阿里云也可以申请证书啊</p><p>链接在<img src="https://common-buy.aliyun.com/?spm=5176.2020520163.cas.55.cf9c783W4XZMe&amp;commodityCode=cas#/buy" alt="这里"></p><p>因为是我直接复制的url, 路径可能会失效, 可以依照:</p><p>阿里云控制台 &gt; CA证书服务 &gt; 右上角购买证书</p><p>这这个流程进行证书的申购</p><p>关键是, 在又拍云每次申请要一天时间, 驳回之后又是要一天, 但是阿里云上面申请只需要一分钟左右就下来了, 部署的时候还有贴心的程序猿小哥哥录的视频告诉你配置和部署的姿势</p><h1 id="申请好了-准备部署"><a href="#申请好了-准备部署" class="headerlink" title="申请好了, 准备部署"></a>申请好了, 准备部署</h1><p>部署的话我是直接使用的nginx进行部署的, 部署也很简单, 到nginx官网下载自己对应版本的包, 解压到自己的服务器任意文件夹</p><p>还是在CA证书服务中, 将证书下载下来, 复制到nginx的conf文件夹中, 在文件夹中新建一个文件cert, 然后将两个证书复制进去</p><p>回到nginx.exe文件目录下, 双击重启一下nginx服务, 一切ok</p><p>然后, 我们就可以直接使用https访问我们的网站了, 美滋滋啊美滋滋</p>]]></content>
    
    <summary type="html">
    
      HTTPS（全称：Hyper Text Transfer Protocol over Secure Socket Layer），是以安全为目标的HTTP通道，简单讲是HTTP的安全版。
    
    </summary>
    
      <category term="HTTPS" scheme="http://blog.changerhe.cn/categories/HTTPS/"/>
    
    
      <category term="HTTPS" scheme="http://blog.changerhe.cn/tags/HTTPS/"/>
    
  </entry>
  
  <entry>
    <title>利用dpl实现对移动设备的像素实现精准控制</title>
    <link href="http://blog.changerhe.cn/2017/08/05/%E5%88%A9%E7%94%A8dpl%E5%AE%9E%E7%8E%B0%E5%AF%B9%E7%A7%BB%E5%8A%A8%E8%AE%BE%E5%A4%87%E7%9A%84%E5%83%8F%E7%B4%A0%E5%AE%9E%E7%8E%B0%E7%B2%BE%E5%87%86%E6%8E%A7%E5%88%B6/"/>
    <id>http://blog.changerhe.cn/2017/08/05/利用dpl实现对移动设备的像素实现精准控制/</id>
    <published>2017-08-05T14:14:14.000Z</published>
    <updated>2017-11-22T05:36:30.999Z</updated>
    
    <content type="html"><![CDATA[<p>dpl, 全称是device pixel ratio ,表示设备的像素比</p><p>设备在移动端因为物理像素和理论像素的不同而产生了显示的差异, 随着科技的发展, 设备的物理像素与理论像素之比由之前的一比一变成了多比一, 其中比较典型的就是, iphone6的设备像素比是2:1, iphone6 plus是3:1</p><p>因为其显示的差异, 也造成了我们在电脑上做的页面, 在移动端出现了显示异常的情况</p><p>而在js的window对象中有一个属性专门用于表示设备我的像素比例, 名叫devicePixelRatio, 也就是说, 我们可以使用window.devicePixelRatio来显示出当前设备的物理像素和实际像素的比例.</p><p>也同样是因为这个问题, 催生了移动设备一像素的问题, 因为我们在电脑上设置1px, 导致在手机端显示为2px甚至更多, 在需要精细化控制设计图的情况下会使页面非常不美观</p><p>解决这个问题，主要思想是：使用伪元素设置1px的边框，然后使用媒体查询，根据dpr的大小，对边框进行缩放（scaleY）。详细代码如下所示： </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;div id=&quot;app&quot;&gt;</span><br><span class="line">    &lt;div class=&quot;tab border-1px&quot;&gt; &lt;!-- !!!!!!! --&gt;</span><br><span class="line">      &lt;div class=&quot;tab-items&quot;&gt;</span><br><span class="line">        &lt;router-link  to=&quot;/goods&quot;&gt;商品&lt;/router-link&gt;</span><br><span class="line">      &lt;/div&gt;</span><br><span class="line">      &lt;div class=&quot;tab-items&quot;&gt;</span><br><span class="line">         &lt;router-link  to=&quot;/ratings&quot;&gt;评价&lt;/router-link&gt;</span><br><span class="line">      &lt;/div&gt;</span><br><span class="line">      &lt;div class=&quot;tab-items&quot;&gt;</span><br><span class="line">        &lt;router-link  to=&quot;/seller&quot;&gt;商店&lt;/router-link&gt;</span><br><span class="line">      &lt;/div&gt;</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line">    &lt;div class=&quot;content&quot;&gt;</span><br><span class="line">      &lt;router-view&gt;&lt;/router-view&gt;</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line">  &lt;/div&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line"></span><br><span class="line">&lt;script&gt;</span><br><span class="line">&lt;/script&gt;</span><br><span class="line"></span><br><span class="line">&lt;style lang=&quot;stylus&quot; rel=&quot;stylesheet/stylus&quot;&gt;</span><br><span class="line">@import &quot;./common/stylus/mixin.styl&quot;</span><br><span class="line">@import &quot;./common/stylus/base.styl&quot;</span><br><span class="line">#app</span><br><span class="line">  .tab</span><br><span class="line">    display: flex</span><br><span class="line">    width: 100%</span><br><span class="line">    height: 40px</span><br><span class="line">    line-height: 40px</span><br><span class="line">    border-1px(blue)  /*!!!!!!*/</span><br><span class="line">    .tab-items</span><br><span class="line">      flex: 1</span><br><span class="line">      text-align: center</span><br><span class="line">      font-size: 14px</span><br><span class="line">      &amp; &gt; a</span><br><span class="line">        display: block</span><br><span class="line">        width: 100%</span><br><span class="line">        color: rgb(77, 85, 93)</span><br><span class="line">        &amp;.router-link-active</span><br><span class="line">          color: rgb(240, 20, 20)</span><br><span class="line">  .seller</span><br><span class="line">    border-bottom: 1px solid blue  /*用于对比，在移动端实际显示2px*/</span><br><span class="line">&lt;/style&gt;</span><br></pre></td></tr></table></figure><p>看过滴滴打车的黄奕老师的vue开发饿了么教程的童鞋可以知道这就是初期构建的商家详情的spa单页骨架雏形哈哈</p><p>可以看到我们使用到了stylus中的mixin对移动端设备一像素问题的解决办法</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">border-1px($color)</span><br><span class="line">    position: relative</span><br><span class="line">    &amp;::after</span><br><span class="line">        position: absolute</span><br><span class="line">        left: 0</span><br><span class="line">        bottom: 0</span><br><span class="line">        width: 100%</span><br><span class="line">        content: &apos; &apos;</span><br><span class="line">        border-top: 1px solid $color</span><br><span class="line"></span><br><span class="line">//图片的mixin，根据图片的不同dpr进行适配下显示高清问题</span><br><span class="line">bg-image($url) </span><br><span class="line">  background-image: url($url + &quot;@2x.png&quot;)</span><br><span class="line">  @media (-webkit-min-device-pixel-ratio: 3),(min-device-pixel-ratio: 3)</span><br><span class="line">    background-image: url($url + &quot;@3x.png&quot;)</span><br></pre></td></tr></table></figure><p>针对边框一像素问题, 我们使用的是伪类结合子绝父相, 然后将伪类的边框使用css3的transition: scale来进行缩放从而达到效果的</p><p>这里的bg-image($url) 是负责处理图片在不同dpr下显示的问题，原来跟1像素边框问题差不多，不过这里不需要重做，只是根据不同的media query来调用不同的图片显示，而这些图片是需要放在相对应的文件夹的。</p><p>再来看一下base中的内容</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&lt;!--根据媒体查询@media设置不同的缩放比例(transform 的 scale)来修复1像素边框的问题--&gt;</span><br><span class="line">@media (-webkit-min-device-pixel-ratio: 1.5),(min-device-pixel-ratio: 1.5)</span><br><span class="line">    .border-1px</span><br><span class="line">        &amp;::after</span><br><span class="line">            -webkit-transform: scaleY(0.7)</span><br><span class="line">            transform: scaleY(0.7)</span><br><span class="line"></span><br><span class="line">@media (-webkit-min-device-pixel-ratio: 2),(min-device-pixel-ratio: 2)</span><br><span class="line">    .border-1px</span><br><span class="line">        &amp;::after</span><br><span class="line">            -webkit-transform: scaleY(0.5)</span><br><span class="line">            transform: scaleY(0.5)</span><br></pre></td></tr></table></figure><p>这里的修复1像素边框问题会拆分为2个部分，一个部分是这里的base.styl里面处理缩放，另外一部分是在mixin.styl里面处理重做border。<br>这里是一个base模块文件，只保留了基本的共用的css，需要结合其他的css文件(stylus)来合并理解<br>dpr一般是1或者2，1.5只是为了更精细的去适配1和2之间的手机型号</p>]]></content>
    
    <summary type="html">
    
      一般在移动端，由于dpr（设备像素比）不为1，在PC端显示1像素的边框，在移动端其实显示为2px。解决这个问题，主要思想是：使用伪元素设置1px的边框，然后使用媒体查询，根据dpr的大小，对边框进行缩放（scaleY）。详细代码如下所示：  App.vue:
    
    </summary>
    
      <category term="移动端" scheme="http://blog.changerhe.cn/categories/%E7%A7%BB%E5%8A%A8%E7%AB%AF/"/>
    
    
      <category term="移动端" scheme="http://blog.changerhe.cn/tags/%E7%A7%BB%E5%8A%A8%E7%AB%AF/"/>
    
  </entry>
  
  <entry>
    <title>Angularjs的数据绑定和脏检查</title>
    <link href="http://blog.changerhe.cn/2017/07/20/Angularjs%E7%9A%84%E6%95%B0%E6%8D%AE%E7%BB%91%E5%AE%9A%E5%92%8C%E8%84%8F%E6%A3%80%E6%9F%A5/"/>
    <id>http://blog.changerhe.cn/2017/07/20/Angularjs的数据绑定和脏检查/</id>
    <published>2017-07-20T04:53:41.000Z</published>
    <updated>2017-11-22T05:36:01.486Z</updated>
    
    <content type="html"><![CDATA[<p>接触Angular也有一段时间了，时常问自己一些问题, 如果是我实现它，会在哪些方面选择跟它相同的道路, 哪些方面不同。为此，记录了一些思考，给自己回顾，也供他人参考。</p><p>本篇博客将分下面几个方面进行讲解</p><p>-数据双向绑定<br>-视图模型的继承关系<br>-模块和依赖注入的设计</p><h1 id="数据的双向绑定"><a href="#数据的双向绑定" class="headerlink" title="数据的双向绑定"></a>数据的双向绑定</h1><p>Angular实现了双向绑定机制。所谓的双向绑定，无非是从界面的操作能实时反映到数据，数据的变更能实时展现到界面。</p><p>一个最简单的示例就是这样：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;div ng-controller=&quot;CounterCtrl&quot;&gt;</span><br><span class="line">    &lt;span ng-bind=&quot;counter&quot;&gt;&lt;/span&gt;</span><br><span class="line">    &lt;button ng-click=&quot;counter=counter+1&quot;&gt;increase&lt;/button&gt;</span><br><span class="line">&lt;/div&gt;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">function CounterCtrl($scope) &#123;</span><br><span class="line">    $scope.counter = 1;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个例子很简单，毫无特别之处，每当点击一次按钮，界面上的数字就增加一。</p><h1 id="绑定数据是怎样生效的"><a href="#绑定数据是怎样生效的" class="headerlink" title="绑定数据是怎样生效的"></a>绑定数据是怎样生效的</h1><p>初学AngularJS的人可能会踩到这样的坑，假设有一个指令：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">var app = angular.module(&quot;test&quot;, []);</span><br><span class="line"></span><br><span class="line">app.directive(&quot;myclick&quot;, function() &#123;</span><br><span class="line">    return function (scope, element, attr) &#123;</span><br><span class="line">        element.on(&quot;click&quot;, function() &#123;</span><br><span class="line">            scope.counter++;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">app.controller(&quot;CounterCtrl&quot;, function($scope) &#123;</span><br><span class="line">    $scope.counter = 0;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&lt;body ng-app=&quot;test&quot;&gt;</span><br><span class="line">    &lt;div ng-controller=&quot;CounterCtrl&quot;&gt;</span><br><span class="line">        &lt;button myclick&gt;increase&lt;/button&gt;</span><br><span class="line">        &lt;span ng-bind=&quot;counter&quot;&gt;&lt;/span&gt;</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line">&lt;/body&gt;</span><br></pre></td></tr></table></figure><p>这个时候，点击按钮，界面上的数字并不会增加。很多人会感到迷惑，因为他查看调试器，发现数据确实已经增加了，Angular不是双向绑定吗，为什么数据变化了，界面没有跟着刷新？</p><p>试试在scope.counter++;这句之后加一句scope.digest();再看看是不是好了？</p><p>为什么要这么做呢，什么情况下要这么做呢？我们发现第一个例子中并没有digest，而且，如果你写了digest，它还会抛出异常，说正在做其他的digest，这是怎么回事？</p><p>我们先想想，假如没有AngularJS，我们想要自己实现这么个功能，应该怎样？</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line">&lt;html&gt;</span><br><span class="line">    &lt;head&gt;</span><br><span class="line">        &lt;meta charset=&quot;utf-8&quot; /&gt;</span><br><span class="line">        &lt;title&gt;two-way binding&lt;/title&gt;</span><br><span class="line">    &lt;/head&gt;</span><br><span class="line">    &lt;body onload=&quot;init()&quot;&gt;</span><br><span class="line">        &lt;button ng-click=&quot;inc&quot;&gt;</span><br><span class="line">            increase 1</span><br><span class="line">        &lt;/button&gt;</span><br><span class="line">        &lt;button ng-click=&quot;inc2&quot;&gt;</span><br><span class="line">            increase 2</span><br><span class="line">        &lt;/button&gt;</span><br><span class="line">        &lt;span style=&quot;color:red&quot; ng-bind=&quot;counter&quot;&gt;&lt;/span&gt;</span><br><span class="line">        &lt;span style=&quot;color:blue&quot; ng-bind=&quot;counter&quot;&gt;&lt;/span&gt;</span><br><span class="line">        &lt;span style=&quot;color:green&quot; ng-bind=&quot;counter&quot;&gt;&lt;/span&gt;</span><br><span class="line"></span><br><span class="line">        &lt;script type=&quot;text/javascript&quot;&gt;</span><br><span class="line">            /* 数据模型区开始 */</span><br><span class="line">            var counter = 0;</span><br><span class="line"></span><br><span class="line">            function inc() &#123;</span><br><span class="line">                counter++;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            function inc2() &#123;</span><br><span class="line">                counter+=2;</span><br><span class="line">            &#125;</span><br><span class="line">            /* 数据模型区结束 */</span><br><span class="line"></span><br><span class="line">            /* 绑定关系区开始 */</span><br><span class="line">            function init() &#123;</span><br><span class="line">                bind();</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            function bind() &#123;</span><br><span class="line">                var list = document.querySelectorAll(&quot;[ng-click]&quot;);</span><br><span class="line">                for (var i=0; i&lt;list.length; i++) &#123;</span><br><span class="line">                    list[i].onclick = (function(index) &#123;</span><br><span class="line">                        return function() &#123;</span><br><span class="line">                            window[list[index].getAttribute(&quot;ng-click&quot;)]();</span><br><span class="line">                            apply();</span><br><span class="line">                        &#125;;</span><br><span class="line">                    &#125;)(i);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            function apply() &#123;</span><br><span class="line">                var list = document.querySelectorAll(&quot;[ng-bind=&apos;counter&apos;]&quot;);</span><br><span class="line">                for (var i=0; i&lt;list.length; i++) &#123;</span><br><span class="line">                    list[i].innerHTML = counter;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            /* 绑定关系区结束 */</span><br><span class="line">        &lt;/script&gt;</span><br><span class="line">    &lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure><p>可以看到，在这么一个简单的例子中，我们做了一些双向绑定的事情。从两个按钮的点击到数据的变更，这个很好理解，但我们没有直接使用DOM的onclick方法，而是搞了一个ng-click，然后在bind里面把这个ng-click对应的函数拿出来，绑定到onclick的事件处理函数中。为什么要这样呢？因为数据虽然变更了，但是还没有往界面上填充，我们需要在此做一些附加操作。</p><p>从另外一个方面看，当数据变更的时候，需要把这个变更应用到界面上，也就是那三个span里。但由于Angular使用的是脏检测，意味着当改变数据之后，你自己要做一些事情来触发脏检测，然后再应用到这个数据对应的DOM元素上。问题就在于，怎样触发脏检测？什么时候触发？</p><p>我们知道，一些基于setter的框架，它可以在给数据设值的时候，对DOM元素上的绑定变量作重新赋值。脏检测的机制没有这个阶段，它没有任何途径在数据变更之后立即得到通知，所以只能在每个事件入口中手动调用apply()，把数据的变更应用到界面上。在真正的Angular实现中，这里先进行脏检测，确定数据有变化了，然后才对界面设值。</p><p>所以，我们在ng-click里面封装真正的click，最重要的作用是为了在之后追加一次apply()，把数据的变更应用到界面上去。</p><p>那么，为什么在ng-click里面调用$digest的话，会报错呢？因为Angular的设计，同一时间只允许一个$digest运行，而ng-click这种内置指令已经触发了$digest，当前的还没有走完，所以就出错了。</p><h1 id="digest和-apply"><a href="#digest和-apply" class="headerlink" title="$digest和$apply"></a>$digest和$apply</h1><p>在Angular中，有$apply和$digest两个函数，我们刚才是通过$digest来让这个数据应用到界面上。但这个时候，也可以不用$digest，而是使用$apply，效果是一样的，那么，它们的差异是什么呢？</p><p>最直接的差异是，$apply可以带参数，它可以接受一个函数，然后在应用数据之后，调用这个函数。所以，一般在集成非Angular框架的代码时，可以把代码写在这个里面调用。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">var app = angular.module(&quot;test&quot;, []);</span><br><span class="line"></span><br><span class="line">app.directive(&quot;myclick&quot;, function() &#123;</span><br><span class="line">    return function (scope, element, attr) &#123;</span><br><span class="line">        element.on(&quot;click&quot;, function() &#123;</span><br><span class="line">            scope.counter++;</span><br><span class="line">            scope.$apply(function() &#123;</span><br><span class="line">                scope.counter++;</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">app.controller(&quot;CounterCtrl&quot;, function($scope) &#123;</span><br><span class="line">    $scope.counter = 0;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>除此之外，还有别的区别吗？</p><p>在简单的数据模型中，这两者没有本质差别，但是当有层次结构的时候，就不一样了。考虑到有两层作用域，我们可以在父作用域上调用这两个函数，也可以在子作用域上调用，这个时候就能看到差别了。</p><p>对于$digest来说，在父作用域和子作用域上调用是有差别的，但是，对于$apply来说，这两者一样。我们来构造一个特殊的示例：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">var app = angular.module(&quot;test&quot;, []);</span><br><span class="line"></span><br><span class="line">app.directive(&quot;increasea&quot;, function() &#123;</span><br><span class="line">    return function (scope, element, attr) &#123;</span><br><span class="line">        element.on(&quot;click&quot;, function() &#123;</span><br><span class="line">            scope.a++;</span><br><span class="line">            scope.$digest();</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">app.directive(&quot;increaseb&quot;, function() &#123;</span><br><span class="line">    return function (scope, element, attr) &#123;</span><br><span class="line">        element.on(&quot;click&quot;, function() &#123;</span><br><span class="line">            scope.b++;</span><br><span class="line">            scope.$digest();    //这个换成$apply即可</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">app.controller(&quot;OuterCtrl&quot;, [&quot;$scope&quot;, function($scope) &#123;</span><br><span class="line">    $scope.a = 1;</span><br><span class="line"></span><br><span class="line">    $scope.$watch(&quot;a&quot;, function(newVal) &#123;</span><br><span class="line">        console.log(&quot;a:&quot; + newVal);</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    $scope.$on(&quot;test&quot;, function(evt) &#123;</span><br><span class="line">        $scope.a++;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;]);</span><br><span class="line"></span><br><span class="line">app.controller(&quot;InnerCtrl&quot;, [&quot;$scope&quot;, function($scope) &#123;</span><br><span class="line">    $scope.b = 2;</span><br><span class="line"></span><br><span class="line">    $scope.$watch(&quot;b&quot;, function(newVal) &#123;</span><br><span class="line">        console.log(&quot;b:&quot; + newVal);</span><br><span class="line">        $scope.$emit(&quot;test&quot;, newVal);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;]);</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&lt;div ng-app=&quot;test&quot;&gt;</span><br><span class="line">    &lt;div ng-controller=&quot;OuterCtrl&quot;&gt;</span><br><span class="line">        &lt;div ng-controller=&quot;InnerCtrl&quot;&gt;</span><br><span class="line">            &lt;button increaseb&gt;increase b&lt;/button&gt;</span><br><span class="line">            &lt;span ng-bind=&quot;b&quot;&gt;&lt;/span&gt;</span><br><span class="line">        &lt;/div&gt;</span><br><span class="line">        &lt;button increasea&gt;increase a&lt;/button&gt;</span><br><span class="line">        &lt;span ng-bind=&quot;a&quot;&gt;&lt;/span&gt;</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line">&lt;/div&gt;</span><br></pre></td></tr></table></figure><p>这时候，我们就能看出差别了，在increase b按钮上点击，这时候，a跟b的值其实都已经变化了，但是界面上的a没有更新，直到点击一次increase a，这时候刚才对a的累加才会一次更新上来。怎么解决这个问题呢？只需在increaseb这个指令的实现中，把$digest换成$apply即可。</p><p>当调用$digest的时候，只触发当前作用域和它的子作用域上的监控，但是当调用$apply的时候，会触发作用域树上的所有监控。</p><p>因此，从性能上讲，如果能确定自己作的这个数据变更所造成的影响范围，应当尽量调用$digest，只有当无法精确知道数据变更造成的影响范围时，才去用$apply，很暴力地遍历整个作用域树，调用其中所有的监控。</p><p>从另外一个角度，我们也可以看到，为什么调用外部框架的时候，是推荐放在$apply中，因为只有这个地方才是对所有数据变更都应用的地方，如果用$digest，有可能临时丢失数据变更。</p><h1 id="脏检测的利弊"><a href="#脏检测的利弊" class="headerlink" title="脏检测的利弊"></a>脏检测的利弊</h1><p>很多人对Angular的脏检测机制感到不屑，推崇基于setter，getter的观测机制，在我看来，这只是同一个事情的不同实现方式，并没有谁完全胜过谁，两者是各有优劣的。</p><p>大家都知道，在循环中批量添加DOM元素的时候，会推荐使用DocumentFragment，为什么呢，因为如果每次都对DOM产生变更，它都要修改DOM树的结构，性能影响大，如果我们能先在文档碎片中把DOM结构创建好，然后整体添加到主文档中，这个DOM树的变更就会一次完成，性能会提高很多。</p><p>同理，在Angular框架里，考虑到这样的场景：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">function TestCtrl($scope) &#123;</span><br><span class="line">    $scope.numOfCheckedItems = 0;</span><br><span class="line"></span><br><span class="line">    var list = [];</span><br><span class="line"></span><br><span class="line">    for (var i=0; i&lt;10000; i++) &#123;</span><br><span class="line">        list.push(&#123;</span><br><span class="line">            index: i,</span><br><span class="line">            checked: false</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    $scope.list = list;</span><br><span class="line"></span><br><span class="line">    $scope.toggleChecked = function(flag) &#123;</span><br><span class="line">        for (var i=0; i&lt;list.length; i++) &#123;</span><br><span class="line">            list[i].checked = flag;</span><br><span class="line">            $scope.numOfCheckedItems++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果界面上某个文本绑定这个numOfCheckedItems，会怎样？在脏检测的机制下，这个过程毫无压力，一次做完所有数据变更，然后整体应用到界面上。这时候，基于setter的机制就惨了，除非它也是像Angular这样把批量操作延时到一次更新，否则性能会更低。</p><p>所以说，两种不同的监控方式，各有其优缺点，最好的办法是了解各自使用方式的差异，考虑出它们性能的差异所在，在不同的业务场景中，避开最容易造成性能瓶颈的用法。</p>]]></content>
    
    <summary type="html">
    
      接触Angular也有一段时间了，时常问自己一些问题, 如果是我实现它，会在哪些方面选择跟它相同的道路, 哪些方面不同。为此，记录了一些思考，给自己回顾，也供他人参考。
    
    </summary>
    
      <category term="Angularjs" scheme="http://blog.changerhe.cn/categories/Angularjs/"/>
    
    
      <category term="Angularjs" scheme="http://blog.changerhe.cn/tags/Angularjs/"/>
    
      <category term="数据绑定" scheme="http://blog.changerhe.cn/tags/%E6%95%B0%E6%8D%AE%E7%BB%91%E5%AE%9A/"/>
    
  </entry>
  
  <entry>
    <title>基于MongoDB 2dSphere索引查找最近的点</title>
    <link href="http://blog.changerhe.cn/2017/07/05/%E5%9F%BA%E4%BA%8EMongoDB-2dSphere%E7%B4%A2%E5%BC%95%E6%9F%A5%E6%89%BE%E6%9C%80%E8%BF%91%E7%9A%84%E7%82%B9/"/>
    <id>http://blog.changerhe.cn/2017/07/05/基于MongoDB-2dSphere索引查找最近的点/</id>
    <published>2017-07-05T15:27:22.000Z</published>
    <updated>2017-11-22T05:35:48.912Z</updated>
    
    <content type="html"><![CDATA[<p>在移动端普及的今天，LBS应用需求也越来越大。比如查找附近的人，最近的餐厅等。面对这些需求，MongoDB提供了功能完备的解决方案。下面通过一个案例来解释一下MongoDB的2dSphere</p><p><img src="http://img.blog.csdn.net/20160923111644414" alt=""></p><p>在这个图片中，有A B C D E F G,假如我是搜索点A。我想查找离自己最近的点。下面是具体的操作步骤： </p><h1 id="建立集合和索引。sp为建立索引的字段名，我们建立的索引类型是2dsphere"><a href="#建立集合和索引。sp为建立索引的字段名，我们建立的索引类型是2dsphere" class="headerlink" title="建立集合和索引。sp为建立索引的字段名，我们建立的索引类型是2dsphere"></a>建立集合和索引。sp为建立索引的字段名，我们建立的索引类型是2dsphere</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># 创建2dsphere索引</span><br><span class="line"> db.sphere.ensureIndex(&#123;&quot;sp&quot;:&quot;2dsphere&quot;&#125;)</span><br></pre></td></tr></table></figure><h1 id="向集合中插入测试数据，我们插入的是实际的经纬度。"><a href="#向集合中插入测试数据，我们插入的是实际的经纬度。" class="headerlink" title="向集合中插入测试数据，我们插入的是实际的经纬度。"></a>向集合中插入测试数据，我们插入的是实际的经纬度。</h1><p>这里需要注意的是，如果我们如果用的是2dsphere索引，那么插入的应该是GeoJson数据。GeoJson的格式是 </p><p><code>{ type: ‘GeoJSON type’ , coordinates: ‘coordinates’ }</code></p><p>其中type指的是类型，可以是Point(本例中用的)，LineString，Polygon等，coordinates是一个坐标数组。英语好的同学可以去官网看看<a href="https://docs.mongodb.com/manual/reference/geojson/" target="_blank" rel="noopener">https://docs.mongodb.com/manual/reference/geojson/</a></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"># 插入Point数据</span><br><span class="line">db.sphere.insert(&#123;name:&quot;A&quot;,sp:&#123;type:&quot;Point&quot;,coordinates:[105.754484701156,41.689607057699]&#125;&#125;)</span><br><span class="line">db.sphere.insert(&#123;name:&quot;B&quot;,sp:&#123;type:&quot;Point&quot;,coordinates:[105.304045248031,41.783456183240]&#125;&#125;)</span><br><span class="line">db.sphere.insert(&#123;name:&quot;C&quot;,sp:&#123;type:&quot;Point&quot;,coordinates:[105.084318685531,41.389027478812]&#125;&#125;)</span><br><span class="line">db.sphere.insert(&#123;name:&quot;D&quot;,sp:&#123;type:&quot;Point&quot;,coordinates:[105.831388998031,41.285916385493]&#125;&#125;)</span><br><span class="line">db.sphere.insert(&#123;name:&quot;E&quot;,sp:&#123;type:&quot;Point&quot;,coordinates:[106.128706502914,42.086868474465]&#125;&#125;)</span><br><span class="line">db.sphere.insert(&#123;name:&quot;F&quot;,sp:&#123;type:&quot;Point&quot;,coordinates:[105.431074666976,42.009365053841]&#125;&#125;)</span><br><span class="line">db.sphere.insert(&#123;name:&quot;G&quot;,sp:&#123;type:&quot;Point&quot;,coordinates:[104.705977010726,41.921549795110]&#125;&#125;)</span><br></pre></td></tr></table></figure><h1 id="进行查询。介绍一下其中的参数"><a href="#进行查询。介绍一下其中的参数" class="headerlink" title="进行查询。介绍一下其中的参数"></a>进行查询。介绍一下其中的参数</h1><blockquote><p>（1）geoNear:我们要查询的集合名称 </p></blockquote><blockquote><p>（2）near:就是基于那个点进行搜索，这里是我们的搜索点A </p></blockquote><blockquote><p>（3）spherical:是个布尔值，如果为true，表示将计算实际的物理距离比如两点之间有多少km,若为false,则会基于点的单位进行计算 </p></blockquote><blockquote><p>（4）minDistance:搜索的最小距离，这里的单位是米 </p></blockquote><blockquote><p>（5）maxDistance:搜索的最大距离</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">db.runCommand(&#123;</span><br><span class="line">    geoNear:&quot;sphere&quot;,</span><br><span class="line">    near:&#123;type:&quot;Point&quot;,coordinates:[105.794621276855,41.869574065014]&#125;,</span><br><span class="line">    spherical:true,</span><br><span class="line">    minDistance:25000,</span><br><span class="line">    maxDistance:40000,</span><br><span class="line">    &#125;)</span><br></pre></td></tr></table></figure><h1 id="结果分析"><a href="#结果分析" class="headerlink" title="结果分析"></a>结果分析</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    &quot;waitedMS&quot; : NumberLong(0),</span><br><span class="line">    &quot;results&quot; : [ </span><br><span class="line">        &#123;</span><br><span class="line">            &quot;dis&quot; : 33887.5416611258,</span><br><span class="line">            &quot;obj&quot; : &#123;</span><br><span class="line">                &quot;_id&quot; : ObjectId(&quot;57e3857e6a4a326367ae0d05&quot;),</span><br><span class="line">                &quot;name&quot; : &quot;F&quot;,</span><br><span class="line">                &quot;sp&quot; : &#123;</span><br><span class="line">                    &quot;type&quot; : &quot;Point&quot;,</span><br><span class="line">                    &quot;coordinates&quot; : [ </span><br><span class="line">                        105.431074666976, </span><br><span class="line">                        42.009365053841</span><br><span class="line">                    ]</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, </span><br><span class="line">        &#123;</span><br><span class="line">            &quot;dis&quot; : 36734.9748784127,</span><br><span class="line">            &quot;obj&quot; : &#123;</span><br><span class="line">                &quot;_id&quot; : ObjectId(&quot;57e3857e6a4a326367ae0d04&quot;),</span><br><span class="line">                &quot;name&quot; : &quot;E&quot;,</span><br><span class="line">                &quot;sp&quot; : &#123;</span><br><span class="line">                    &quot;type&quot; : &quot;Point&quot;,</span><br><span class="line">                    &quot;coordinates&quot; : [ </span><br><span class="line">                        106.128706502914, </span><br><span class="line">                        42.086868474465</span><br><span class="line">                    ]</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    ],</span><br><span class="line">    &quot;stats&quot; : &#123;</span><br><span class="line">        &quot;nscanned&quot; : 24,</span><br><span class="line">        &quot;objectsLoaded&quot; : 20,</span><br><span class="line">        &quot;avgDistance&quot; : 35311.2582697693,</span><br><span class="line">        &quot;maxDistance&quot; : 36734.9748784127,</span><br><span class="line">        &quot;time&quot; : 87</span><br><span class="line">    &#125;,</span><br><span class="line">    &quot;ok&quot; : 1.0</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在results中，我们搜索到了点F和E。每个文档都加上了一个dis字段，他表示这个点离你搜索点的距离。</p><p>比如说，在结果中name为F的点的dis为33887.5416611258。表示F点距离搜索点的距离是33887米。这个结果对于LBS应用是非常有用的。 </p>]]></content>
    
    <summary type="html">
    
      在移动端普及的今天，LBS应用需求也越来越大。比如查找附近的人，最近的餐厅等。面对这些需求，MongoDB提供了功能完备的解决方案。下面通过一个案例来解释一下MongoDB的2dSphere
    
    </summary>
    
      <category term="MongoDB学习笔记" scheme="http://blog.changerhe.cn/categories/MongoDB%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="MongoDB" scheme="http://blog.changerhe.cn/tags/MongoDB/"/>
    
      <category term="2dSphere" scheme="http://blog.changerhe.cn/tags/2dSphere/"/>
    
  </entry>
  
  <entry>
    <title>使用Nodejs实现简单的自动化构建</title>
    <link href="http://blog.changerhe.cn/2017/06/27/%E4%BD%BF%E7%94%A8Nodejs%E5%AE%9E%E7%8E%B0%E7%AE%80%E5%8D%95%E7%9A%84%E8%87%AA%E5%8A%A8%E5%8C%96%E6%9E%84%E5%BB%BA/"/>
    <id>http://blog.changerhe.cn/2017/06/27/使用Nodejs实现简单的自动化构建/</id>
    <published>2017-06-27T15:56:30.000Z</published>
    <updated>2017-11-22T05:35:28.351Z</updated>
    
    <content type="html"><![CDATA[<p>自动化构建是现代前端基本都需要的东西,说起这个,大家自然会想到 Glup/Grount这些自动化的构建工具.</p><p>当然,本文只是从最最基础的角度,使用Node的fs模块进行了简单的文档的写入操作.</p><p>首先,我们先定义一个JSON,用于存放我们想要预先定义的文件夹的内容,比如说,我想要我的文件夹名称为<code>ProjectModule</code> ,里面的文件夹有 <code>css</code> / <code>js</code> / <code>img</code> 还有一个 <code>index.html</code>,同时定义好index文件中的内容</p><p>那么我的JSON结构可以这样写</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">var projectData = &#123;</span><br><span class="line">    &apos;name&apos; : &apos;ProjectModule&apos;,</span><br><span class="line">    &apos;fileData&apos;: [</span><br><span class="line">        &#123;</span><br><span class="line">            &apos;name&apos;: &apos;css&apos;,</span><br><span class="line">            &apos;type&apos;: &apos;dir&apos;</span><br><span class="line">        &#125;,</span><br><span class="line">        &#123;</span><br><span class="line">            &apos;name&apos;: &apos;js&apos;,</span><br><span class="line">            &apos;type&apos;: &apos;dir&apos;</span><br><span class="line">        &#125;,</span><br><span class="line">        &#123;</span><br><span class="line">            &apos;name&apos;: &apos;img&apos;,</span><br><span class="line">            &apos;type&apos;: &apos;dir&apos;</span><br><span class="line">        &#125;,</span><br><span class="line">        &#123;</span><br><span class="line">            &apos;name&apos;: &apos;index.html&apos;,</span><br><span class="line">            &apos;type&apos;: &apos;file&apos;,</span><br><span class="line">            &apos;content&apos;: &apos;&lt;html&gt;\n\t&lt;head&gt;\n\t&lt;title&gt;MyProject&lt;/title&gt;\n\t&lt;/head&gt;\n\t&lt;body&gt;\n\t&lt;/body&gt;\n&lt;/html&gt;&apos;</span><br><span class="line">        &#125;</span><br><span class="line">    ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>接下来,就是引入fs模块</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">var fs = require(&apos;fs&apos;)</span><br></pre></td></tr></table></figure><p>因为这里是要实时创建的,我们可以直接使用同步的操作,就省去了异步需要使用回调函数的麻烦</p><p>当然,开始之前,要先确定一下,JSON是否有正常的给出文件夹的名称</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">if(projectData.name) &#123;</span><br><span class="line"></span><br><span class="line">    fs.mkdirSync(projectData.name)</span><br><span class="line"></span><br><span class="line">    var fileData = projectData.fileData</span><br><span class="line"></span><br><span class="line">    fileData.forEach(function(f) &#123;</span><br><span class="line"></span><br><span class="line">        f.content = f.content? f.content : &apos;&apos;</span><br><span class="line"></span><br><span class="line">        f.path = projectData.name + &apos;/&apos; + f.name</span><br><span class="line"></span><br><span class="line">        switch (f.type) &#123;</span><br><span class="line">            </span><br><span class="line">            case &apos;dir&apos;:</span><br><span class="line">                fs.mkdirSync(f.path)</span><br><span class="line">                break;</span><br><span class="line">            case &apos;file&apos;:</span><br><span class="line">                fs.writeFileSync(f.path, f.content)</span><br><span class="line">                break;</span><br><span class="line">            default:</span><br><span class="line">                break;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果使用的是webstorm, 那么直接使用ctrl+f9, 让你的node程序跑起来吧~</p>]]></content>
    
    <summary type="html">
    
      自动化构建是现代前端基本都需要的东西,说起这个,大家自然会想到 Glup/Grount这些自动化的构建工具.
当然,本文只是从最最基础的角度,使用Node的fs模块进行了简单的文档的写入操作.
    
    </summary>
    
      <category term="Nodejs学习笔记" scheme="http://blog.changerhe.cn/categories/Nodejs%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="Nodejs学习笔记" scheme="http://blog.changerhe.cn/tags/Nodejs%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>ES6中的遍历器接口Iterator</title>
    <link href="http://blog.changerhe.cn/2017/06/25/ES6%E4%B8%AD%E7%9A%84%E9%81%8D%E5%8E%86%E5%99%A8%E6%8E%A5%E5%8F%A3Iterator/"/>
    <id>http://blog.changerhe.cn/2017/06/25/ES6中的遍历器接口Iterator/</id>
    <published>2017-06-25T15:34:18.000Z</published>
    <updated>2017-11-22T05:35:19.586Z</updated>
    
    <content type="html"><![CDATA[<p>初读阮一峰老师的这本书,简直如发现了新世界一般.原来ES6的语法是如此的清奇.</p><p>随着ES6, ES7, 到今年七月份的ES8. 我们会发现,javascript这门最初被定义在客户端的’玩具语言’已经变得越发的强壮和标准,这也是我们作为前端ers 所希望看到的,毕竟,这涉及到以后的饭碗呢哈哈.</p><p>阮一峰老师的文笔还是不错的,但是随着后面的阅读,会发现有一些后面的知识,被直接不明就里的拿到前面来用了,这就导致我这个新手小白就有点懵逼了.</p><p>比如说: 箭头函数,当然,这个比较好理解,有固定的语法</p><p>但是,阮老师一直有提到的iterator接口,到底是个啥? 估计初学ES6的新手小白自然会有着和我一样的困惑.</p><p>那么,下面就综合我的搜索和总结,对iterator接口的相关知识,做一个分享,也算是对自己所学的一个总结</p><h1 id="iterator接口是什么"><a href="#iterator接口是什么" class="headerlink" title="iterator接口是什么"></a>iterator接口是什么</h1><p>不知大家碰到此问题的时候是不是和我一样马上选择了百度(毕竟英语不够好,不能随随便便Google一下啊),泪奔~</p><p>百度上面会告诉你, Java的iterator很好用巴拉巴拉</p><p>那么,在javascript中,iterator接口到底是个神马东西呢?</p><p>iterator, 其实就是一个迭代器,或者说,是一个迭代器</p><p>在es6中，能表示“集合”概念的数据类型大致有四种:Array,Object,Map,Set</p><p>既然是集合，那遍历便是一种基本需求。而Iterator就是为了提供一种统一的接口机制。任何的数据结构，只要部署了Iterator接口，便可以使用类似的方式完成遍历操作。</p><p>当然，Iterator还有2个作用，它使数据结构的成员按某种次序排列，其次，es6有一种新的遍历方式，前面也说过，for…of，而Iterator的主要作用，就是支持此操作。</p><h2 id="Iteartor的遍历过程是这样的"><a href="#Iteartor的遍历过程是这样的" class="headerlink" title="Iteartor的遍历过程是这样的"></a>Iteartor的遍历过程是这样的</h2><blockquote><p>创建一个指向数据结构起始位置的指针。(起始位置不是第一个成员的位置，起始位置使一个单独的标志位。)</p></blockquote><blockquote><p>当调用next()方法，指针就向后移动一个位置，并返回当前位置上的成员，直到指针指向数据结构的结束位置为止。</p></blockquote><p>第二步中，js语言返回的的成员信息是两个，value和done，value不用介绍，done是一个表示遍历是否结束的布尔值。</p><h1 id="部署接口"><a href="#部署接口" class="headerlink" title="部署接口"></a>部署接口</h1><p>上面我们说到的部署接口，那js怎么部署接口呢。其实我们之前已经说到过，在Symbol一节中，介绍了很多es6内置的Symbol值，这些就是接口。</p><p>es6中有三类结构生来就具有Iterator接口：数组、类数组对象、Map和Set结构。</p><p>当然,如果你和我一样,现在看到第八章的话,暂时是没有学到Map和Set结构的,这个看下就好</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">var arr = [1,2,3,4];</span><br><span class="line">let iterator = arr[Symbol.iterator]();</span><br><span class="line"></span><br><span class="line">console.log(iterator.next());  //&#123; value: 1, done: false &#125;</span><br><span class="line">console.log(iterator.next());  //&#123; value: 2, done: false &#125;</span><br><span class="line">console.log(iterator.next());  //&#123; value: 3, done: false &#125;</span><br><span class="line">console.log(iterator.next());  //&#123; value: 4, done: false &#125;</span><br><span class="line">console.log(iterator.next());  //&#123; value: undefined, done: true &#125;</span><br></pre></td></tr></table></figure><p>数组，Map等结构中的成员都是有顺序的，即都是线性的结构，而对象，各成员并没有一个确定的顺序，所以遍历时先遍历谁后遍历谁并不确定。所以，给一个对象部署iterator接口，其实就是对该对象做一种线性转换。</p><p>如果有需要，可以手动给对象部署iterator接口</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">let obj = &#123;</span><br><span class="line">    data: [ &apos;hello&apos;, &apos;world&apos; ],</span><br><span class="line">    [Symbol.iterator]() &#123;</span><br><span class="line">        const self = this;</span><br><span class="line">        let index = 0;</span><br><span class="line">        return &#123;</span><br><span class="line">            next() &#123;</span><br><span class="line">                if (index &lt; self.data.length) &#123;</span><br><span class="line">                    return &#123;</span><br><span class="line">                        value: self.data[index++],</span><br><span class="line">                        done: false</span><br><span class="line">                    &#125;;</span><br><span class="line">                &#125; else &#123;</span><br><span class="line">                    return &#123; value: undefined, done: true &#125;;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>可以看到，Symbol.iterator会返回一个对象，这就是一个遍历器对象，而作为遍历器对象，其必须具备的特征就是必须具备next()方法。</p><p>至于可以使用Array.from转换成数组的类数组对象，部署iterator有一种很简单的方法，即直接使用数组的[Symbol.iterator]接口。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">fakeArray.prototype[Symbol.iterator] = Array.prototype[Symbol.iterator];</span><br></pre></td></tr></table></figure><p>用Generator函数来实现Symbol.iterator接口，事半功倍。</p><p>这也是看到第八章我要出来百度的原因,因为影响到了我正常的往下阅读了</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">var yieldIterator = &#123;&#125;;</span><br><span class="line">yieldIterator[Symbol.iterator] = function* () &#123;</span><br><span class="line">    yield 1;</span><br><span class="line">    yield 2;</span><br><span class="line">    yield 3;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">[...yieldIterator] // [1, 2, 3]</span><br></pre></td></tr></table></figure><p>注意，yield* 后面跟的是一个可遍历的结构，它会调用该结构的遍历器接口。</p><p>　　其次，其它调用到遍历器的操作还有解构赋值、扩展操作符、其它任何接受数组作为参数的场合，如：</p><blockquote><p>for…of<br>Array.from()<br>Map(), Set(), WeakMap(), WeakSet()（比如）<br>Promise.all()<br>Promise.race()</p></blockquote><p>一旦当你给你的结构部署了iterator接口，那么恭喜你，你可以使用for…of来遍历你的结构了！</p><p>遍历器对象除了必须布置next方法以外，还有2个可选方法。return()和throw()。当一个解构在遍历的时候异常提前退出(比如break,continue或者出错)的时候，就会调用return方法，其次，return方法必须返回一个对象。</p><p>至于throw方法，则是用于抛出错误，Generator.prototype.throw</p><p>for of循环有很多优点，比如不像for…in一样只遍历键名（甚至包括原型链上的键），而且不像foreach不能跳出循环。并且for…of为各种数据结构提供了一个统一的遍历方法。所以，尽量使用它吧~</p>]]></content>
    
    <summary type="html">
    
      初读阮一峰老师的这本书,简直如发现了新世界一般.原来ES6的语法是如此的清奇.
随着ES6, ES7, 到今年七月份的ES8. 我们会发现,javascript这门最初被定义在客户端的&#39;玩具语言&#39;已经变得越发的强壮和标准,这也是我们作为前端ers 所希望看到的,毕竟,这涉及到以后的饭碗呢哈哈.
    
    </summary>
    
      <category term="ES6标准入门阅读笔记" scheme="http://blog.changerhe.cn/categories/ES6%E6%A0%87%E5%87%86%E5%85%A5%E9%97%A8%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="ES6标准入门阅读笔记" scheme="http://blog.changerhe.cn/tags/ES6%E6%A0%87%E5%87%86%E5%85%A5%E9%97%A8%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>理解Node.js里的process.nextTick()</title>
    <link href="http://blog.changerhe.cn/2017/06/18/%E7%90%86%E8%A7%A3Nodejs%E9%87%8C%E7%9A%84process-nextTick/"/>
    <id>http://blog.changerhe.cn/2017/06/18/理解Nodejs里的process-nextTick/</id>
    <published>2017-06-18T12:00:32.000Z</published>
    <updated>2017-11-22T05:35:00.881Z</updated>
    
    <content type="html"><![CDATA[<p>Nodejs的事件驱动,异步IO模型另异步编程变得异常风行,它借助了异步IO模型及V8高性能引擎,突破了单线程的性能瓶颈. 让Jacascript在后端达到了其应有的使用价值. </p><p>另外一方面,它也统一了前后端的javascript编程模型.</p><p>异步编程也给前端程序猿带来了诸多的痛苦和不适应. 这也是我今天着重想提<code>process.nextTick()</code>这个API的原因之一.</p><h1 id="异常处理"><a href="#异常处理" class="headerlink" title="异常处理"></a>异常处理</h1><p>在过去,我们处理异常一般使用try catch fanily这个语句块进行异常捕获和处理</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">try &#123;</span><br><span class="line">JSON.parse(jsonObj)</span><br><span class="line">&#125; catch(e) &#123;</span><br><span class="line">// do something...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>但是这个方法对异步编程而言是并不适用的, 举个很简单的例子,也是我们在日常开发中常常使用的一个小技巧: 当我们想要某个在文档中间的语句块在整个脚本的最后执行的时候,可以使用setTimeout将这个语句块包起来,将延时时间设为0, 那么这个时候它就会等待所有同步的进程全部执行完毕之后再执行.</p><p>在try中,我们进行异步的方式处理JSON.parse的时候,那么它也会被放到文档流的最后执行而try catch先执行了,这就是导致出现这个问题的原因</p><p>那么这个时候,就需要们的主角登场了</p><p>同样的,我们再来一个例子</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">function foo() &#123;</span><br><span class="line">console.error(&apos;foo&apos;);</span><br><span class="line">&#125;</span><br><span class="line">process.nextTick(foo);</span><br><span class="line">console.error(&apos;bar&apos;);</span><br></pre></td></tr></table></figure><p>运行上面的代码，你从下面终端打印的信息会看到，”bar”的输出在“foo”的前面。这就验证了上面的说法，foo()是在下一个时间点运行的。</p><p>但在内部的处理机制上，process.nextTick()和setTimeout(fn, 0)是不同的，process.nextTick()不是一个单纯的延时，他有更多的 特性。</p><p>更精确的说，process.nextTick()定义的调用会创建一个新的子堆栈。在当前的栈里，你可以执行任意多的操作。但一旦调用netxTick，函数就必须返回到父堆栈。然后事件轮询机制又重新等待处理新的事件，如果发现nextTick的调用，就会创建一个新的栈。</p><p>下面我们来看看，什么情况下使用process.nextTick()：</p><h1 id="在多个事件里交叉执行CPU运算密集型的任务："><a href="#在多个事件里交叉执行CPU运算密集型的任务：" class="headerlink" title="在多个事件里交叉执行CPU运算密集型的任务："></a>在多个事件里交叉执行CPU运算密集型的任务：</h1><p>在下面的例子里有一个compute()，我们希望这个函数尽可能持续的执行，来进行一些运算密集的任务。</p><p>但与此同时，我们还希望系统不要被这个函数堵塞住，还需要能响应处理别的事件。这个应用模式就像一个单线程的web服务server。在这里我们就可以使用process.nextTick()来交叉执行compute()和正常的事件响应。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">var http = require(&apos;http&apos;);</span><br><span class="line"></span><br><span class="line">function compute() &#123;</span><br><span class="line">    // performs complicated calculations continuously</span><br><span class="line">    // ...</span><br><span class="line">    process.nextTick(compute);</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">http.createServer(function(req, res) &#123;</span><br><span class="line">     res.writeHead(200, &#123;&apos;Content-Type&apos;: &apos;text/plain&apos;&#125;);</span><br><span class="line">     res.end(&apos;Hello World&apos;);</span><br><span class="line">&#125;).listen(5000, &apos;127.0.0.1&apos;);</span><br><span class="line"> </span><br><span class="line">compute();</span><br></pre></td></tr></table></figure><p>在这种模式下，我们不需要递归的调用compute()，我们只需要在事件循环中使用process.nextTick()定义compute()在下一个时间点执行即可。在这个过程中，如果有新的http请求进来，事件循环机制会先处理新的请求，然后再调用compute()。反之，如果你把compute()放在一个递归调用里，那系统就会一直阻塞在compute()里，无法处理新的http请求了。你可以自己试试。</p><p>当然，我们无法通过process.nextTick()来获得多CPU下并行执行的真正好处，这只是模拟同一个应用在CPU上分段执行而已。</p><h1 id="保持回调函数异步执行的原则"><a href="#保持回调函数异步执行的原则" class="headerlink" title="保持回调函数异步执行的原则"></a>保持回调函数异步执行的原则</h1><p>当你给一个函数定义一个回调函数时，你要确保这个回调是被异步执行的。下面我们看一个例子，例子中的回调违反了这一原则：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">function asyncFake(data, callback) &#123;  </span><br><span class="line">    if(data === &apos;foo&apos;) callback(true);</span><br><span class="line">    else callback(false);</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">asyncFake(&apos;bar&apos;, function(result) &#123;</span><br><span class="line">    // this callback is actually called synchronously!</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>为什么这样不好呢？我们来看Node.js 文档里一段代码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">var client = net.connect(8124, function() &#123; </span><br><span class="line">    console.log(&apos;client connected&apos;);</span><br><span class="line">    client.write(&apos;world!\r\n&apos;);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>在上面的代码里，如果因为某种原因，net.connect()变成同步执行的了，回调函数就会被立刻执行，因此回调函数写到客户端的变量就永远不会被初始化了。</p><p>这种情况下我们就可以使用process.nextTick()把上面asyncFake()改成异步执行的：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">function asyncReal(data, callback) &#123;</span><br><span class="line">    process.nextTick(function() &#123;</span><br><span class="line">        callback(data === &apos;foo&apos;);   </span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="用在事件触发过程中"><a href="#用在事件触发过程中" class="headerlink" title="用在事件触发过程中"></a>用在事件触发过程中</h1><p>来看一个例子，你想写一个库实现这样的功能：从源文件里读取数据，当读取完毕后，触发一个事件同时传递读取的数据。可能你会这样写：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">var EventEmitter = require(&apos;events&apos;).EventEmitter;</span><br><span class="line"> </span><br><span class="line">function StreamLibrary(resourceName) &#123; </span><br><span class="line">    this.emit(&apos;start&apos;);</span><br><span class="line"> </span><br><span class="line">    // read from the file, and for every chunk read, do: </span><br><span class="line">    this.emit(&apos;data&apos;, chunkRead);      </span><br><span class="line">&#125;</span><br><span class="line">StreamLibrary.prototype.__proto__ = EventEmitter.prototype;   </span><br><span class="line">// inherit from EventEmitter</span><br></pre></td></tr></table></figure><p>下面是一段调用这个库的客户端程序，我们想在程序中监听这些事件：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">var stream = new StreamLibrary(&apos;fooResource&apos;);</span><br><span class="line"> </span><br><span class="line">stream.on(&apos;start&apos;, function() &#123;</span><br><span class="line">    console.log(&apos;Reading has started&apos;);</span><br><span class="line">&#125;);</span><br><span class="line"> </span><br><span class="line">stream.on(&apos;data&apos;, function(chunk) &#123;</span><br><span class="line">    console.log(&apos;Received: &apos; + chunk);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>但是上面的代码中，将永远接收不到“start”事件，因为在这个库实例化的时候，“start”事件会被立刻触发执行，但此时事件的回调函数还没有准备好，所以在客户端根本无法接收到这个事件。同样，我们可以用process.nextTick()来改写事件触发的过程，下面是一个正确的版本：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">function StreamLibrary(resourceName) &#123;      </span><br><span class="line">    var self = this;</span><br><span class="line"> </span><br><span class="line">    process.nextTick(function() &#123;</span><br><span class="line">        self.emit(&apos;start&apos;);</span><br><span class="line">    &#125;);</span><br><span class="line"> </span><br><span class="line">    // read from the file, and for every chunk read, do:</span><br><span class="line">    this.emit(&apos;data&apos;, chunkRead);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>(文章部分引用了网上内容)</p>]]></content>
    
    <summary type="html">
    
      Nodejs的事件驱动,异步IO模型另异步编程变得异常风行,它借助了异步IO模型及V8高性能引擎,突破了单线程的性能瓶颈. 让Jacascript在后端达到了其应有的使用价值.  另外一方面,它也统一了前后端的javascript编程模型.
    
    </summary>
    
      <category term="Nodejs学习笔记" scheme="http://blog.changerhe.cn/categories/Nodejs%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="Nodejs" scheme="http://blog.changerhe.cn/tags/Nodejs/"/>
    
      <category term="process.nextTick()" scheme="http://blog.changerhe.cn/tags/process-nextTick/"/>
    
  </entry>
  
  <entry>
    <title>Nodejs的require()模块源码解读</title>
    <link href="http://blog.changerhe.cn/2017/06/06/Nodejs%E7%9A%84require-%E6%A8%A1%E5%9D%97%E6%BA%90%E7%A0%81%E8%A7%A3%E8%AF%BB/"/>
    <id>http://blog.changerhe.cn/2017/06/06/Nodejs的require-模块源码解读/</id>
    <published>2017-06-06T11:44:27.000Z</published>
    <updated>2017-11-22T05:34:50.925Z</updated>
    
    <content type="html"><![CDATA[<p>2009年, nodejs项目诞生,所有模块一律为commonjs格式.</p><p>时至今日,Nodejs的包管理npm仓库,已经存放了十万百万级的模块,其中绝大部分都是使用的commonjs格式.</p><p>这种格式的核心就是require语句, 模块通过它进行加载.</p><h1 id="基本用法"><a href="#基本用法" class="headerlink" title="基本用法"></a>基本用法</h1><p>以下内容翻译自《Node使用手册》</p><p>当 Node 遇到 require(X) 时，按下面的顺序处理。</p><blockquote><p>（1）如果 X 是内置模块（比如 require(‘http’）)<br>　　a. 返回该模块。<br>　　b. 不再继续执行。<br>（2）如果 X 以 “./“ 或者 “/“ 或者 “../“ 开头<br>　　a. 根据 X 所在的父模块，确定 X 的绝对路径。<br>　　b. 将 X 当成文件，依次查找<code>X</code>,找不到之后会查找<code>X .js</code>,再找不到则找<code>X .json</code>,还找不到则找<code>X .node</code>，只要其中有一个存在，就返回该文件，不再继续执行。<br>　　c. 将 X 当成目录，依次查找<code>X /package.json</code>,找不到之后会查找<code>X /index.js</code>,再找不到则找<code>X /index.json</code>,还找不到则找<code>X /index.node</code>，只要其中有一个存在，就返回该文件，不再继续执行。<br>（3）如果 X 不带路径<br>　　a. 根据 X 所在的父模块，确定 X 可能的安装目录。<br>　　b. 依次在每个目录中，将 X 当成文件名或目录名加载。<br>（4） 抛出 “not found”</p></blockquote><h1 id="Module构造函数"><a href="#Module构造函数" class="headerlink" title="Module构造函数"></a>Module构造函数</h1><p>Module构造函数的部分源码是这样的</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">function Module(id, parent) &#123;</span><br><span class="line">  this.id = id;</span><br><span class="line">  this.exports = &#123;&#125;;</span><br><span class="line">  this.parent = parent;</span><br><span class="line">  this.filename = null;</span><br><span class="line">  this.loaded = false;</span><br><span class="line">  this.children = [];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">module.exports = Module;</span><br><span class="line"></span><br><span class="line">var module = new Module(filename, parent);</span><br></pre></td></tr></table></figure><p>上面代码中，Node 定义了一个构造函数 Module，所有的模块都是 Module 的实例。可以看到，当前模块（module.js）也是 Module 的一个实例。<br>每个实例都有自己的属性。下面通过一个例子，看看这些属性的值是什么。新建一个脚本文件 a.js 。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">// a.js</span><br><span class="line"></span><br><span class="line">console.log(&apos;module.id: &apos;, module.id);  //.</span><br><span class="line">console.log(&apos;module.exports: &apos;, module.exports); // &#123;&#125;</span><br><span class="line">console.log(&apos;module.parent: &apos;, module.parent); // null</span><br><span class="line">console.log(&apos;module.filename: &apos;, module.filename); // 当前文件路径</span><br><span class="line">console.log(&apos;module.loaded: &apos;, module.loaded); // false</span><br><span class="line">console.log(&apos;module.children: &apos;, module.children); //</span><br><span class="line">console.log(&apos;module.paths: &apos;, module.paths);</span><br></pre></td></tr></table></figure><p>可以看到，如果没有父模块，直接调用当前模块，parent 属性就是 null，id 属性就是一个点。filename 属性是模块的绝对路径，path 属性是一个数组，包含了模块可能的位置。另外，输出这些内容时，模块还没有全部加载，所以 loaded 属性为 false 。<br>新建另一个脚本文件 b.js，让其调用 a.js 。</p><p>上面代码中，由于 a.js 被 b.js 调用，所以 parent 属性指向 b.js 模块，id 属性和 filename 属性一致，都是模块的绝对路径。</p><h1 id="模块实例的-require-方法"><a href="#模块实例的-require-方法" class="headerlink" title="模块实例的 require 方法"></a>模块实例的 require 方法</h1><p>每个模块实例都有一个 require 方法。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Module.prototype.require = function(path) &#123;</span><br><span class="line">return Module._load(path, this);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>由此可知，require 并不是全局性命令，而是每个模块提供的一个内部方法，也就是说，只有在模块内部才能使用 require 命令（唯一的例外是 REPL 环境）。另外，require 其实内部调用 Module._load 方法。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">Module._load = function(request, parent, isMain) &#123;</span><br><span class="line"></span><br><span class="line">//  计算绝对路径</span><br><span class="line">var filename = Module._resolveFilename(request, parent);</span><br><span class="line"></span><br><span class="line">//  第一步：如果有缓存，取出缓存</span><br><span class="line">var cachedModule = Module._cache[filename];</span><br><span class="line">if (cachedModule) &#123;</span><br><span class="line">return cachedModule.exports;</span><br><span class="line"></span><br><span class="line">// 第二步：是否为内置模块</span><br><span class="line">if (NativeModule.exists(filename)) &#123;</span><br><span class="line">return NativeModule.require(filename);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 第三步：生成模块实例，存入缓存</span><br><span class="line">var module = new Module(filename, parent);</span><br><span class="line">Module._cache[filename] = module;</span><br><span class="line"></span><br><span class="line">// 第四步：加载模块</span><br><span class="line">try &#123;</span><br><span class="line">module.load(filename);</span><br><span class="line">hadException = false;</span><br><span class="line">&#125; finally &#123;</span><br><span class="line">if (hadException) &#123;</span><br><span class="line">delete Module._cache[filename];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 第五步：输出模块的exports属性</span><br><span class="line">return module.exports;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>上面代码中，首先解析出模块的绝对路径（filename），以它作为模块的识别符。然后，如果模块已经在缓存中，就从缓存取出；如果不在缓存中，就加载模块。</p><p>因此，Module._load 的关键步骤是两个。</p><p>Module._resolveFilename() ：确定模块的绝对路径<br>module.load()：加载模块</p><h1 id="模块的绝对路径"><a href="#模块的绝对路径" class="headerlink" title="模块的绝对路径"></a>模块的绝对路径</h1><p>下面是 Module._resolveFilename 方法的源码。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">Module._resolveFilename = function(request, parent) &#123;</span><br><span class="line"></span><br><span class="line">// 第一步：如果是内置模块，不含路径返回</span><br><span class="line">if (NativeModule.exists(request)) &#123;</span><br><span class="line">return request;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 第二步：确定所有可能的路径</span><br><span class="line">var resolvedModule = Module._resolveLookupPaths(request, parent);</span><br><span class="line">var id = resolvedModule[0];</span><br><span class="line">var paths = resolvedModule[1];</span><br><span class="line"></span><br><span class="line">// 第三步：确定哪一个路径为真</span><br><span class="line">var filename = Module._findPath(request, paths);</span><br><span class="line">if (!filename) &#123;</span><br><span class="line">var err = new Error(&quot;Cannot find module &apos;&quot; + request + &quot;&apos;&quot;);</span><br><span class="line">err.code = &apos;MODULE_NOT_FOUND&apos;;</span><br><span class="line">throw err;</span><br><span class="line">&#125;</span><br><span class="line">return filename;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>上面代码中，在 Module.resolveFilename 方法内部，又调用了两个方法 Module.resolveLookupPaths() 和 Module._findPath() ，前者用来列出可能的路径，后者用来确认哪一个路径为真。<br>为了简洁起见，这里只给出 Module._resolveLookupPaths() 的运行结果。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">[   &apos;/home/ruanyf/tmp/node_modules&apos;,</span><br><span class="line">&apos;/home/ruanyf/node_modules&apos;,</span><br><span class="line">&apos;/home/node_modules&apos;,</span><br><span class="line">&apos;/node_modules&apos;</span><br><span class="line">&apos;/home/ruanyf/.node_modules&apos;,</span><br><span class="line">&apos;/home/ruanyf/.node_libraries&apos;，</span><br><span class="line">&apos;$Prefix/lib/node&apos; ]</span><br></pre></td></tr></table></figure><p>上面的数组，就是模块所有可能的路径。基本上是，从当前路径开始一级级向上寻找 node_modules 子目录。最后那三个路径，主要是为了历史原因保持兼容，实际上已经很少用了。<br>有了可能的路径以后，下面就是 Module._findPath() 的源码，用来确定到底哪一个是正确路径。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line">Module._findPath = function(request, paths) &#123;</span><br><span class="line"></span><br><span class="line">// 列出所有可能的后缀名：.js，.json, .node</span><br><span class="line">var exts = Object.keys(Module._extensions);</span><br><span class="line"></span><br><span class="line">// 如果是绝对路径，就不再搜索</span><br><span class="line">if (request.charAt(0) === &apos;/&apos;) &#123;</span><br><span class="line">paths = [&apos;&apos;];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 是否有后缀的目录斜杠</span><br><span class="line">var trailingSlash = (request.slice(-1) === &apos;/&apos;);</span><br><span class="line"></span><br><span class="line">// 第一步：如果当前路径已在缓存中，就直接返回缓存</span><br><span class="line">var cacheKey = JSON.stringify(&#123;request: request, paths: paths&#125;);</span><br><span class="line">if (Module._pathCache[cacheKey]) &#123;</span><br><span class="line">return Module._pathCache[cacheKey];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 第二步：依次遍历所有路径</span><br><span class="line">for (var i = 0, PL = paths.length; i &lt; PL; i++) &#123;</span><br><span class="line">var basePath = path.resolve(paths[i], request);</span><br><span class="line">var filename;</span><br><span class="line"></span><br><span class="line">if (!trailingSlash) &#123;</span><br><span class="line">// 第三步：是否存在该模块文件</span><br><span class="line">filename = tryFile(basePath);</span><br><span class="line"></span><br><span class="line">if (!filename &amp;&amp; !trailingSlash) &#123;</span><br><span class="line">// 第四步：该模块文件加上后缀名，是否存在</span><br><span class="line">filename = tryExtensions(basePath, exts);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 第五步：目录中是否存在 package.json</span><br><span class="line">if (!filename) &#123;</span><br><span class="line">filename = tryPackage(basePath, exts);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">if (!filename) &#123;</span><br><span class="line">// 第六步：是否存在目录名 + index + 后缀名</span><br><span class="line">filename = tryExtensions(path.resolve(basePath, &apos;index&apos;), exts);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 第七步：将找到的文件路径存入返回缓存，然后返回</span><br><span class="line">if (filename) &#123;</span><br><span class="line">Module._pathCache[cacheKey] = filename;</span><br><span class="line">return filename;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 第八步：没有找到文件，返回false</span><br><span class="line">return false;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>经过上面代码，就可以找到模块的绝对路径了。<br>有时在项目代码中，需要调用模块的绝对路径，那么除了 module.filename ，Node 还提供一个 require.resolve 方法，供外部调用，用于从模块名取到绝对路径。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">require.resolve = function(request) &#123;</span><br><span class="line">return Module._resolveFilename(request, self);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">// 用法</span><br><span class="line">require.resolve(&apos;a.js&apos;)</span><br><span class="line">// 返回 /home/ruanyf/tmp/a.js</span><br></pre></td></tr></table></figure><h1 id="加载模块"><a href="#加载模块" class="headerlink" title="加载模块"></a>加载模块</h1><p>有了模块的绝对路径，就可以加载该模块了。下面是 module.load 方法的源码。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Module.prototype.load = function(filename) &#123;</span><br><span class="line">var extension = path.extname(filename) || &apos;.js&apos;;</span><br><span class="line">if (!Module._extensions[extension]) extension = &apos;.js&apos;;</span><br><span class="line">Module._extensions[extension](this, filename);</span><br><span class="line">this.loaded = true;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>上面代码中，首先确定模块的后缀名，不同的后缀名对应不同的加载方法。下面是 .js 和 .json 后缀名对应的处理方法。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">Module._extensions[&apos;.js&apos;] = function(module, filename) &#123;</span><br><span class="line">var content = fs.readFileSync(filename, &apos;utf8&apos;);</span><br><span class="line">module._compile(stripBOM(content), filename);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">Module._extensions[&apos;.json&apos;] = function(module, filename) &#123;</span><br><span class="line">var content = fs.readFileSync(filename, &apos;utf8&apos;);</span><br><span class="line">try &#123;</span><br><span class="line">module.exports = JSON.parse(stripBOM(content));</span><br><span class="line">&#125; catch (err) &#123;</span><br><span class="line">err.message = filename + &apos;: &apos; + err.message;</span><br><span class="line">throw err;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>这里只讨论 js 文件的加载。首先，将模块文件读取成字符串，然后剥离 utf8 编码特有的BOM文件头，最后编译该模块。<br>module._compile 方法用于模块的编译。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Module.prototype._compile = function(content, filename) &#123;</span><br><span class="line">var self = this;</span><br><span class="line">var args = [self.exports, require, self, filename, dirname];</span><br><span class="line">return compiledWrapper.apply(self.exports, args);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>上面的代码基本等同于下面的形式。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">(function (exports, require, module, __filename, __dirname) &#123;</span><br><span class="line">// 模块源码</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>也就是说，模块的加载实质上就是，注入exports、require、module三个全局变量，然后执行模块的源码，然后将模块的 exports 变量的值输出。</p><p>(以上文章转载自阮一峰博客)</p>]]></content>
    
    <summary type="html">
    
      Nodejs的require()模块源码解读
    
    </summary>
    
      <category term="Nodejs学习笔记" scheme="http://blog.changerhe.cn/categories/Nodejs%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="Nodejs" scheme="http://blog.changerhe.cn/tags/Nodejs/"/>
    
      <category term="require" scheme="http://blog.changerhe.cn/tags/require/"/>
    
  </entry>
  
  <entry>
    <title>《ES6标准入门》阅读笔记——-Module</title>
    <link href="http://blog.changerhe.cn/2017/05/20/%E3%80%8AES6%E6%A0%87%E5%87%86%E5%85%A5%E9%97%A8%E3%80%8B%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0%E2%80%94%E2%80%94-Module/"/>
    <id>http://blog.changerhe.cn/2017/05/20/《ES6标准入门》阅读笔记——-Module/</id>
    <published>2017-05-19T16:23:13.000Z</published>
    <updated>2017-11-22T05:34:40.648Z</updated>
    
    <content type="html"><![CDATA[<h1 id="写在前面"><a href="#写在前面" class="headerlink" title="写在前面"></a>写在前面</h1><p>本系列为在我读完阮一峰老师的《ES6标准入门》第二版之后，所做的阅读笔记的整理。</p><p>许多初学ES6, 同时和我一样初次阅读阮老师的这本书的时候, 读第一遍会越发的困惑, 因为阮老师上面说的很多的定义,方法,之前都是没有见过的, 读到后面才发现, 哦~原来是这样.</p><p>有一句话叫做”大神的世界我们不懂”, 所以我在初读第一遍《ES6标准入门》这本书的时候,也是踩了不少坑,读书的时候查阅了不少的资料.</p><p>所以,在这一系列的笔记教程中,我会从一个初学者的角度,向您讲述ES6的相关知识,在后面介绍的知识我会尽量不提前用,即使提前使用,也会同时做好标注,避免了阅读时各种查阅资料的烦恼.</p><p>系列博客将采用一个一个的样例，来说明书中的精华部分（当然，这只是我认为的），同时引导新手，快速入门ES6，并逐步将其投入到生产实践中。</p><p>同时,在阅读前也提醒您, 为了系统连贯性的学习ES6的基础知识,建议您从我的博客第一章开始阅读,当然,如果您对对应的知识已经有所了解,那么可以跳转到任意章节阅读,每一篇博客名中均有介绍该博客中涉及到的ES6的内容.</p><p>阮一峰老师的这本书是开源的，在其官方博客就可以下载到，但是我强烈建议大家去购买一本书, 一是方便自己查阅ES6中新增的众多API, 二也是表达一下对大神的敬仰.</p>]]></content>
    
    <summary type="html">
    
      本系列为在我读完阮一峰老师的《ES6标准入门》第二版之后，所做的阅读笔记的整理。 系列博客将采用一个一个的样例，来说明书中的精华部分（当然，这只是我认为的），同时引导新手，快速入门ES6，并逐步将其投入到生产实践中。
    
    </summary>
    
      <category term="ES6标准入门" scheme="http://blog.changerhe.cn/categories/ES6%E6%A0%87%E5%87%86%E5%85%A5%E9%97%A8/"/>
    
    
      <category term="ES6" scheme="http://blog.changerhe.cn/tags/ES6/"/>
    
      <category term="Module" scheme="http://blog.changerhe.cn/tags/Module/"/>
    
  </entry>
  
  <entry>
    <title>《ES6标准入门》阅读笔记——-Class</title>
    <link href="http://blog.changerhe.cn/2017/05/06/%E3%80%8AES6%E6%A0%87%E5%87%86%E5%85%A5%E9%97%A8%E3%80%8B%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0%E2%80%94%E2%80%94-Class/"/>
    <id>http://blog.changerhe.cn/2017/05/06/《ES6标准入门》阅读笔记——-Class/</id>
    <published>2017-05-06T15:52:52.000Z</published>
    <updated>2017-11-22T05:34:35.294Z</updated>
    
    <content type="html"><![CDATA[<h1 id="写在前面"><a href="#写在前面" class="headerlink" title="写在前面"></a>写在前面</h1><p>本系列为在我读完阮一峰老师的《ES6标准入门》第二版之后，所做的阅读笔记的整理。</p><p>许多初学ES6, 同时和我一样初次阅读阮老师的这本书的时候, 读第一遍会越发的困惑, 因为阮老师上面说的很多的定义,方法,之前都是没有见过的, 读到后面才发现, 哦~原来是这样.</p><p>有一句话叫做”大神的世界我们不懂”, 所以我在初读第一遍《ES6标准入门》这本书的时候,也是踩了不少坑,读书的时候查阅了不少的资料.</p><p>所以,在这一系列的笔记教程中,我会从一个初学者的角度,向您讲述ES6的相关知识,在后面介绍的知识我会尽量不提前用,即使提前使用,也会同时做好标注,避免了阅读时各种查阅资料的烦恼.</p><p>系列博客将采用一个一个的样例，来说明书中的精华部分（当然，这只是我认为的），同时引导新手，快速入门ES6，并逐步将其投入到生产实践中。</p><p>同时,在阅读前也提醒您, 为了系统连贯性的学习ES6的基础知识,建议您从我的博客第一章开始阅读,当然,如果您对对应的知识已经有所了解,那么可以跳转到任意章节阅读,每一篇博客名中均有介绍该博客中涉及到的ES6的内容.</p><p>阮一峰老师的这本书是开源的，在其官方博客就可以下载到，但是我强烈建议大家去购买一本书, 一是方便自己查阅ES6中新增的众多API, 二也是表达一下对大神的敬仰.</p>]]></content>
    
    <summary type="html">
    
      本系列为在我读完阮一峰老师的《ES6标准入门》第二版之后，所做的阅读笔记的整理。 系列博客将采用一个一个的样例，来说明书中的精华部分（当然，这只是我认为的），同时引导新手，快速入门ES6，并逐步将其投入到生产实践中。
    
    </summary>
    
      <category term="ES6标准入门" scheme="http://blog.changerhe.cn/categories/ES6%E6%A0%87%E5%87%86%E5%85%A5%E9%97%A8/"/>
    
    
      <category term="ES6" scheme="http://blog.changerhe.cn/tags/ES6/"/>
    
      <category term="Class" scheme="http://blog.changerhe.cn/tags/Class/"/>
    
  </entry>
  
  <entry>
    <title>《ES6标准入门》阅读笔记——-Promise</title>
    <link href="http://blog.changerhe.cn/2017/04/30/%E3%80%8AES6%E6%A0%87%E5%87%86%E5%85%A5%E9%97%A8%E3%80%8B%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0%E2%80%94%E2%80%94-Promise/"/>
    <id>http://blog.changerhe.cn/2017/04/30/《ES6标准入门》阅读笔记——-Promise/</id>
    <published>2017-04-30T14:23:54.000Z</published>
    <updated>2017-11-22T05:34:26.336Z</updated>
    
    <content type="html"><![CDATA[<h1 id="写在前面"><a href="#写在前面" class="headerlink" title="写在前面"></a>写在前面</h1><p>本系列为在我读完阮一峰老师的《ES6标准入门》第二版之后，所做的阅读笔记的整理。</p><p>许多初学ES6, 同时和我一样初次阅读阮老师的这本书的时候, 读第一遍会越发的困惑, 因为阮老师上面说的很多的定义,方法,之前都是没有见过的, 读到后面才发现, 哦~原来是这样.</p><p>有一句话叫做”大神的世界我们不懂”, 所以我在初读第一遍《ES6标准入门》这本书的时候,也是踩了不少坑,读书的时候查阅了不少的资料.</p><p>所以,在这一系列的笔记教程中,我会从一个初学者的角度,向您讲述ES6的相关知识,在后面介绍的知识我会尽量不提前用,即使提前使用,也会同时做好标注,避免了阅读时各种查阅资料的烦恼.</p><p>系列博客将采用一个一个的样例，来说明书中的精华部分（当然，这只是我认为的），同时引导新手，快速入门ES6，并逐步将其投入到生产实践中。</p><p>同时,在阅读前也提醒您, 为了系统连贯性的学习ES6的基础知识,建议您从我的博客第一章开始阅读,当然,如果您对对应的知识已经有所了解,那么可以跳转到任意章节阅读,每一篇博客名中均有介绍该博客中涉及到的ES6的内容.</p><p>阮一峰老师的这本书是开源的，在其官方博客就可以下载到，但是我强烈建议大家去购买一本书, 一是方便自己查阅ES6中新增的众多API, 二也是表达一下对大神的敬仰.</p>]]></content>
    
    <summary type="html">
    
      本系列为在我读完阮一峰老师的《ES6标准入门》第二版之后，所做的阅读笔记的整理。 系列博客将采用一个一个的样例，来说明书中的精华部分（当然，这只是我认为的），同时引导新手，快速入门ES6，并逐步将其投入到生产实践中。
    
    </summary>
    
      <category term="ES6标准入门" scheme="http://blog.changerhe.cn/categories/ES6%E6%A0%87%E5%87%86%E5%85%A5%E9%97%A8/"/>
    
    
      <category term="ES6" scheme="http://blog.changerhe.cn/tags/ES6/"/>
    
      <category term="Promise" scheme="http://blog.changerhe.cn/tags/Promise/"/>
    
  </entry>
  
  <entry>
    <title>《ES6标准入门》阅读笔记——-Iterator和Generator</title>
    <link href="http://blog.changerhe.cn/2017/04/15/%E3%80%8AES6%E6%A0%87%E5%87%86%E5%85%A5%E9%97%A8%E3%80%8B%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0%E2%80%94%E2%80%94-Iterator%E5%92%8CGenerator/"/>
    <id>http://blog.changerhe.cn/2017/04/15/《ES6标准入门》阅读笔记——-Iterator和Generator/</id>
    <published>2017-04-15T15:11:34.000Z</published>
    <updated>2017-11-22T05:34:15.852Z</updated>
    
    <content type="html"><![CDATA[<h1 id="写在前面"><a href="#写在前面" class="headerlink" title="写在前面"></a>写在前面</h1><p>本系列为在我读完阮一峰老师的《ES6标准入门》第二版之后，所做的阅读笔记的整理。</p><p>许多初学ES6, 同时和我一样初次阅读阮老师的这本书的时候, 读第一遍会越发的困惑, 因为阮老师上面说的很多的定义,方法,之前都是没有见过的, 读到后面才发现, 哦~原来是这样.</p><p>有一句话叫做”大神的世界我们不懂”, 所以我在初读第一遍《ES6标准入门》这本书的时候,也是踩了不少坑,读书的时候查阅了不少的资料.</p><p>所以,在这一系列的笔记教程中,我会从一个初学者的角度,向您讲述ES6的相关知识,在后面介绍的知识我会尽量不提前用,即使提前使用,也会同时做好标注,避免了阅读时各种查阅资料的烦恼.</p><p>系列博客将采用一个一个的样例，来说明书中的精华部分（当然，这只是我认为的），同时引导新手，快速入门ES6，并逐步将其投入到生产实践中。</p><p>同时,在阅读前也提醒您, 为了系统连贯性的学习ES6的基础知识,建议您从我的博客第一章开始阅读,当然,如果您对对应的知识已经有所了解,那么可以跳转到任意章节阅读,每一篇博客名中均有介绍该博客中涉及到的ES6的内容.</p><p>阮一峰老师的这本书是开源的，在其官方博客就可以下载到，但是我强烈建议大家去购买一本书, 一是方便自己查阅ES6中新增的众多API, 二也是表达一下对大神的敬仰.</p>]]></content>
    
    <summary type="html">
    
      本系列为在我读完阮一峰老师的《ES6标准入门》第二版之后，所做的阅读笔记的整理。 系列博客将采用一个一个的样例，来说明书中的精华部分（当然，这只是我认为的），同时引导新手，快速入门ES6，并逐步将其投入到生产实践中。
    
    </summary>
    
      <category term="ES6标准入门" scheme="http://blog.changerhe.cn/categories/ES6%E6%A0%87%E5%87%86%E5%85%A5%E9%97%A8/"/>
    
    
      <category term="ES6" scheme="http://blog.changerhe.cn/tags/ES6/"/>
    
      <category term="Iterator" scheme="http://blog.changerhe.cn/tags/Iterator/"/>
    
      <category term="Generator" scheme="http://blog.changerhe.cn/tags/Generator/"/>
    
  </entry>
  
  <entry>
    <title>《ES6标准入门》阅读笔记——-set和map</title>
    <link href="http://blog.changerhe.cn/2017/04/03/%E3%80%8AES6%E6%A0%87%E5%87%86%E5%85%A5%E9%97%A8%E3%80%8B%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0%E2%80%94%E2%80%94-set%E5%92%8Cmap/"/>
    <id>http://blog.changerhe.cn/2017/04/03/《ES6标准入门》阅读笔记——-set和map/</id>
    <published>2017-04-03T03:37:44.000Z</published>
    <updated>2017-11-22T05:33:55.948Z</updated>
    
    <content type="html"><![CDATA[<h1 id="写在前面"><a href="#写在前面" class="headerlink" title="写在前面"></a>写在前面</h1><p>本系列为在我读完阮一峰老师的《ES6标准入门》第二版之后，所做的阅读笔记的整理。</p><p>许多初学ES6, 同时和我一样初次阅读阮老师的这本书的时候, 读第一遍会越发的困惑, 因为阮老师上面说的很多的定义,方法,之前都是没有见过的, 读到后面才发现, 哦~原来是这样.</p><p>有一句话叫做”大神的世界我们不懂”, 所以我在初读第一遍《ES6标准入门》这本书的时候,也是踩了不少坑,读书的时候查阅了不少的资料.</p><p>所以,在这一系列的笔记教程中,我会从一个初学者的角度,向您讲述ES6的相关知识,在后面介绍的知识我会尽量不提前用,即使提前使用,也会同时做好标注,避免了阅读时各种查阅资料的烦恼.</p><p>系列博客将采用一个一个的样例，来说明书中的精华部分（当然，这只是我认为的），同时引导新手，快速入门ES6，并逐步将其投入到生产实践中。</p><p>同时,在阅读前也提醒您, 为了系统连贯性的学习ES6的基础知识,建议您从我的博客第一章开始阅读,当然,如果您对对应的知识已经有所了解,那么可以跳转到任意章节阅读,每一篇博客名中均有介绍该博客中涉及到的ES6的内容.</p><p>阮一峰老师的这本书是开源的，在其官方博客就可以下载到，但是我强烈建议大家去购买一本书, 一是方便自己查阅ES6中新增的众多API, 二也是表达一下对大神的敬仰.</p><h1 id="Set"><a href="#Set" class="headerlink" title="Set"></a>Set</h1><p>ES6提供了一种新的数据结构Set,类似于数组,但成员值是唯一的,没有重复值. set本身是一个构造函数,用来生成set数据结构</p><p>因此, 利用set这个结构的特性, 就可以很容易地进行数组去重了</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">let s = new Set();</span><br><span class="line">let a = [1, 2, 3, 4, 5, 5, 6, 2, 12, 53, 34, 5, 1, 2, 5, 3, 1, 1].map(x =&gt; s.add(x))</span><br><span class="line">console.log(...s)  // 1 2 3 4 5 6 12 53 34</span><br></pre></td></tr></table></figure><p>向set加入值的时候不会发生类型转换,所以 5 和 ‘5’ 是两个不同的值</p><p>在set内部判断两数是否相等使用的是精确相等运算符, 也就是说,当我们比较对象是否相等的时候,两个不同引用空间的对象是永远不相等的</p><p>有一个例外是,当我们使用NaN的时候,会发现两个NaN其实是相等的,而在ES5的时候NaN会被认为是一个Object从而判定两者不相等</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">let set = new Set([1, 2, 3, NaN, NaN])</span><br><span class="line">console.log(set.size)  // 4</span><br><span class="line">set.add(&#123;&#125;)</span><br><span class="line">set.add(&#123;&#125;)</span><br><span class="line">console.log(set.size)  // 6</span><br></pre></td></tr></table></figure><p>由上面的打印结果很明显的能看到, 两个NaN是相等的, 但是两个对象是不等的</p><p>set结构的实例是默认可遍历的</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">let set = new Set([&apos;red&apos;, &apos;green&apos;, &apos;blue&apos;])</span><br><span class="line">for (let x of set) &#123;</span><br><span class="line">console.log(x) // red green blue</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>由于扩展运算符内部使用for…of循环,所以也可以用于set结构</p><h1 id="set的使用技巧"><a href="#set的使用技巧" class="headerlink" title="set的使用技巧"></a>set的使用技巧</h1><p>利用set可以很容易地实现并集 交集 差集的操作</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">let a = new Set([1, 2, 3])</span><br><span class="line">let b = new Set([2, 3, 4])</span><br><span class="line"></span><br><span class="line">// 求并集</span><br><span class="line">let union = new Set([...a, ...b])</span><br><span class="line">console.log(union)  // Set(4) &#123;1, 2, 3, 4&#125;</span><br><span class="line"></span><br><span class="line">// 求交集</span><br><span class="line">let intersect = new Set([...a].filter(x =&gt; b.has(x)))</span><br><span class="line">console.log(intersect) // Set(2) &#123;2, 3&#125;</span><br><span class="line"></span><br><span class="line">// 求差集</span><br><span class="line">let difference = new Set([...a].filter(x =&gt; !b.has(x)))</span><br><span class="line">console.log(difference) // Set(1) &#123;1&#125;</span><br></pre></td></tr></table></figure><h1 id="WeakSet"><a href="#WeakSet" class="headerlink" title="WeakSet"></a>WeakSet</h1><p>WeakSet的结构和Set类似,也是不重复的值的集合.但是,它与Set有两个区别</p><ul><li><ol><li>weakset成员只能是对象,不能是其他类型的值</li></ol></li><li><ol><li>weakset对象都是弱引用,即垃圾回收机制不考虑</li></ol></li></ul><p>weakset对该对象的引用,如果其他对象都不再引用该对象,那么该对象就会被GC回收.  </p><p>这一特点意味着无法引用weakset的成员,因此weakset是不可遍历的</p><h1 id="Map"><a href="#Map" class="headerlink" title="Map"></a>Map</h1><p>javascript的对象本质上是键值对的集合,但是只能用字符串作为键名</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">let data = &#123;&#125;</span><br><span class="line">let element = document.getElementById(&apos;myDiv&apos;)</span><br><span class="line"></span><br><span class="line">data[element] = metadata // 报错</span><br><span class="line"></span><br><span class="line">console.log(data[&apos;[Object HTMLElement]&apos;])</span><br></pre></td></tr></table></figure><p>ES6提供了Map数据结构,它类似于对象,也是键值对的集合,但是键的范围不限于字符串,各种类型的值都可以当做键名</p><p>因此,map是比object更加合适的键值对结构</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">let m = new Map()</span><br><span class="line">let o = &#123;</span><br><span class="line">p: &apos;Hello world&apos;</span><br><span class="line">&#125;</span><br><span class="line">m.set(o, &apos;content&apos;)</span><br><span class="line">console.log(m.get(o))  // content</span><br><span class="line"></span><br><span class="line">console.log(m.has(o))  // true</span><br><span class="line">console.log(m.delete(o))  // true</span><br><span class="line">console.log(m.has(o))  // false</span><br></pre></td></tr></table></figure><p>另外有一点需要注意的是,map的键是和内存地址绑定的,只要内存地址不一样,那么就会被视为两个键, 这样就解决了同名属性的碰撞问题</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">let map = new Map()</span><br><span class="line"></span><br><span class="line">let k1 = [&apos;a&apos;]</span><br><span class="line">let k2 = [&apos;a&apos;]</span><br><span class="line"></span><br><span class="line">map.set(k1, 111)</span><br><span class="line">map.set(k2, 222)</span><br><span class="line"></span><br><span class="line">console.log(map.get(k1))  // 111</span><br><span class="line">console.log(map.get(k2))  // 222</span><br></pre></td></tr></table></figure><p>那么同样的,当我们使用简单数据类型时,只要两值完全相等,map就将其视为一个键</p><p>包括+0 和 -0 , 以及NaN</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">let map = new Map()</span><br><span class="line"></span><br><span class="line">map.set(NaN, 123)</span><br><span class="line">console.log(map.get(NaN)) // 123</span><br><span class="line"></span><br><span class="line">map.set(-0, 321)</span><br><span class="line">console.log(map.get(+0))  // 321</span><br></pre></td></tr></table></figure><p>map结构转为数组结构比较方便的方法就是使用三点运算符,或者说是扩展运算符,或者说是rest参数</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">let map = new Map([</span><br><span class="line">[1, &apos;one&apos;],</span><br><span class="line">[2, &apos;two&apos;],</span><br><span class="line">[3, &apos;three&apos;]</span><br><span class="line">])</span><br><span class="line"></span><br><span class="line">console.log([...map.keys()])</span><br><span class="line">// 1  2  3</span><br><span class="line">console.log([...map.values()])</span><br><span class="line">// &quot;one&quot;  &quot;two&quot;  &quot;three&quot;</span><br><span class="line">console.log([...map.entries()])</span><br><span class="line">// [1, &quot;one&quot;]  [2, &quot;two&quot;]  [3, &quot;three&quot;]</span><br><span class="line">console.log([...map]) </span><br><span class="line">// [1, &quot;one&quot;]  [2, &quot;two&quot;]  [3, &quot;three&quot;]</span><br></pre></td></tr></table></figure><h1 id="WeakMap"><a href="#WeakMap" class="headerlink" title="WeakMap"></a>WeakMap</h1><p>Weakmap的结构和map结构基本类似,但是weakmap只接受对象作为键名,不接受其他类型的值作为键名</p><p>weakmap的应用典型场景就是在DOM节点作为键名的时候</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">let myElement = document.getElementById(&apos;logo&apos;)</span><br><span class="line">let myWeakmap = new WeakMap()</span><br><span class="line"></span><br><span class="line">myWeakmap.set(myElement, &#123;</span><br><span class="line">timesClicked: 0</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">myElement.addEventListener(&apos;click&apos;, () =&gt; &#123;</span><br><span class="line">let logoData = myWeakmap.get(myElement)</span><br><span class="line">logoData.timesClicked++</span><br><span class="line">myWeakmap.set(myElement, logoData)</span><br><span class="line">&#125;, false)</span><br></pre></td></tr></table></figure><p>(完)</p>]]></content>
    
    <summary type="html">
    
      本系列为在我读完阮一峰老师的《ES6标准入门》第二版之后，所做的阅读笔记的整理。 系列博客将采用一个一个的样例，来说明书中的精华部分（当然，这只是我认为的），同时引导新手，快速入门ES6，并逐步将其投入到生产实践中。
    
    </summary>
    
      <category term="ES6标准入门" scheme="http://blog.changerhe.cn/categories/ES6%E6%A0%87%E5%87%86%E5%85%A5%E9%97%A8/"/>
    
    
      <category term="ES6" scheme="http://blog.changerhe.cn/tags/ES6/"/>
    
      <category term="set" scheme="http://blog.changerhe.cn/tags/set/"/>
    
      <category term="map" scheme="http://blog.changerhe.cn/tags/map/"/>
    
  </entry>
  
  <entry>
    <title>《ES6标准入门》阅读笔记——-symbol及proxy/reflect</title>
    <link href="http://blog.changerhe.cn/2017/04/01/%E3%80%8AES6%E6%A0%87%E5%87%86%E5%85%A5%E9%97%A8%E3%80%8B%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0%E2%80%94%E2%80%94-symbol%E5%8F%8Aproxy-reflect/"/>
    <id>http://blog.changerhe.cn/2017/04/01/《ES6标准入门》阅读笔记——-symbol及proxy-reflect/</id>
    <published>2017-04-01T05:51:28.000Z</published>
    <updated>2017-11-22T05:33:49.057Z</updated>
    
    <content type="html"><![CDATA[<h1 id="写在前面"><a href="#写在前面" class="headerlink" title="写在前面"></a>写在前面</h1><p>本系列为在我读完阮一峰老师的《ES6标准入门》第二版之后，所做的阅读笔记的整理。</p><p>许多初学ES6, 同时和我一样初次阅读阮老师的这本书的时候, 读第一遍会越发的困惑, 因为阮老师上面说的很多的定义,方法,之前都是没有见过的, 读到后面才发现, 哦~原来是这样.</p><p>有一句话叫做”大神的世界我们不懂”, 所以我在初读第一遍《ES6标准入门》这本书的时候,也是踩了不少坑,读书的时候查阅了不少的资料.</p><p>所以,在这一系列的笔记教程中,我会从一个初学者的角度,向您讲述ES6的相关知识,在后面介绍的知识我会尽量不提前用,即使提前使用,也会同时做好标注,避免了阅读时各种查阅资料的烦恼.</p><p>系列博客将采用一个一个的样例，来说明书中的精华部分（当然，这只是我认为的），同时引导新手，快速入门ES6，并逐步将其投入到生产实践中。</p><p>同时,在阅读前也提醒您, 为了系统连贯性的学习ES6的基础知识,建议您从我的博客第一章开始阅读,当然,如果您对对应的知识已经有所了解,那么可以跳转到任意章节阅读,每一篇博客名中均有介绍该博客中涉及到的ES6的内容.</p><p>阮一峰老师的这本书是开源的，在其官方博客就可以下载到，但是我强烈建议大家去购买一本书, 一是方便自己查阅ES6中新增的众多API, 二也是表达一下对大神的敬仰.</p><h1 id="Symbol"><a href="#Symbol" class="headerlink" title="Symbol"></a>Symbol</h1><p>在ES6之前,当我们命名变量的时候,总是会担心,如果我把之前的变量改写了该怎么办呢</p><p>那么,现在ES6推出了继 null undefined string number boolean 这五中数据类型以外的第六种简单数据类型symbol</p><p>推出的主要目的在于,解决属性名冲突的问题</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">let s = Symbol()</span><br><span class="line">console.log(typeof s) // symbol</span><br></pre></td></tr></table></figure><p>symbol一般会传入一个字符串作为不同symbol实例的描述,方便进行区分</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">let a = Symbol(&apos;a&apos;)</span><br><span class="line">let b = Symbol(&apos;b&apos;)</span><br><span class="line">console.log(a, b)  // Symbol(a) Symbol(b)</span><br><span class="line">console.log(a.toString(), b.toString()) // Symbol(a) Symbol(b)</span><br></pre></td></tr></table></figure><p>我们查看控制台的打印结果,会发现symbol的值是以红色显示的,而普通字符串则以灰色显示</p><h2 id="symbol的几个特征"><a href="#symbol的几个特征" class="headerlink" title="symbol的几个特征"></a>symbol的几个特征</h2><blockquote><p>symbol函数的参数只表示对当前symbol值的表示,因此相同参数的symbol函数的返回值是不相等的</p></blockquote><blockquote><p>symbol无法与其他类型值进行运算,否则会报错</p></blockquote><blockquote><p>symbol可以转为布尔值,但是无法转为数值</p></blockquote><blockquote><p>symbol作为变量时,不能使用点运算符</p></blockquote><p>因为symbol是一个特殊的基本类型,因此使用点运算符是不行的,这样会被理解为是在使用字符串作为变量名称</p><p>那么这个时候,可以使用方括号加上symbol名称的方式,来调取这个symbol值</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">var mySymbol = Symbol(&apos;aaa&apos;)</span><br><span class="line">var a = &#123;&#125;</span><br><span class="line">a.mySymbol = &apos;hello&apos;</span><br><span class="line">console.log(a[mySymbol]) // undefined</span><br><span class="line">console.log(a.mySymbol) // hello</span><br><span class="line">console.log(a[&apos;mySymbol&apos;]) // hello</span><br><span class="line"></span><br><span class="line">let c = Symbol</span><br><span class="line">let d = c</span><br><span class="line">console.log(d, d === c) // ƒ Symbol() &#123; [native code] &#125; true</span><br></pre></td></tr></table></figure><h2 id="作为属性名的symbol"><a href="#作为属性名的symbol" class="headerlink" title="作为属性名的symbol"></a>作为属性名的symbol</h2><p>symbol作为属性名,该属性不会出现在for…in for…of 循环中,也不会被Object.keys()/Object.getOwnPropertyNames()返回</p><p>但它也不是私有属性,有一个Object.getOwnPropertSymbols方法可以获取指定对象的所有symbol属性名</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">var obj = &#123;&#125;</span><br><span class="line">var a = Symbol(&apos;a&apos;)</span><br><span class="line">var b = Symbol.for(&apos;b&apos;)</span><br><span class="line"></span><br><span class="line">obj[a] = &apos;hello&apos;</span><br><span class="line">obj[b] = &apos;world&apos;</span><br><span class="line"></span><br><span class="line">var objectSymbols = Object.getOwnPropertySymbols(obj)</span><br><span class="line">console.log(objectSymbols) // [Symbol(a), Symbol(b)]</span><br><span class="line"></span><br><span class="line">var symbolNames = Object.getOwnPropertyNames(obj)</span><br><span class="line">console.log(symbolNames) // []</span><br></pre></td></tr></table></figure><p>由以上可知,使用getOwnPropertySymbols() 方法可以得到对应的symbol值,而getOwnPropertyNames() 是得不到对应的symbol值的</p><h2 id="Reflect-ownKeys-obj"><a href="#Reflect-ownKeys-obj" class="headerlink" title="Reflect.ownKeys(obj)"></a>Reflect.ownKeys(obj)</h2><p>ES6中定义了一个新的API Reflect.ownKeys(obj) 可以返回所有类型的键名称,包括常规键名和symbol键名</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">let obj = &#123;</span><br><span class="line">[Symbol(&apos;my_key&apos;)]: 1,</span><br><span class="line">enum: 2,</span><br><span class="line">nonEnum: 3</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">console.log(Object.keys(obj)) // [&quot;enum&quot;, &quot;nonEnum&quot;]</span><br><span class="line"></span><br><span class="line">console.log(Reflect.ownKeys(obj)) </span><br><span class="line">//[&quot;enum&quot;, &quot;nonEnum&quot;, Symbol(my_key)]</span><br></pre></td></tr></table></figure><h2 id="Symbol-for-和-Symbol-keyFor"><a href="#Symbol-for-和-Symbol-keyFor" class="headerlink" title="Symbol.for() 和 Symbol.keyFor()"></a>Symbol.for() 和 Symbol.keyFor()</h2><p>有时候我们希望重新使用同一个symbol值, Symbol.for方法可以做到这一点,它接收一个字符串作为参数,然后搜索没有以该字符串作为名称的Symbol值. 如果有,就返回这个Symbol值, 否则就新建一个以该字符串为名称的Symbol值</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">let s1 = Symbol.for(&apos;foo&apos;)</span><br><span class="line">let s2 = Symbol.for(&apos;foo&apos;)</span><br><span class="line"></span><br><span class="line">console.log(s1 === s2) // true</span><br></pre></td></tr></table></figure><p>上面的代码中,虽然s1和s2都是Symbol值,但是它们都是同一个Symbol.for生成的,所以是同一个值</p><p>Symbol()和Symbol.for()两种写法,都会生成新的Symbol,但是后者会被登记在全局环境中供 搜索,但是前者不会</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">console.log(Symbol.for(&apos;bar&apos;) === Symbol.for(&apos;bar&apos;)) // true</span><br><span class="line">console.log(Symbol(&apos;bar&apos;) === Symbol(&apos;bar&apos;)) // false</span><br></pre></td></tr></table></figure><p>上面的代码中,由于Symbol()没有登记机制,所以每次调用都会返回不同的值</p><p>Symbol.keyFor()方法用于返回一个已经登记的Symbol类型值的key</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">let s3 = Symbol.for(&apos;aaa&apos;)</span><br><span class="line">let s4 = Symbol(&apos;bbb&apos;)</span><br><span class="line"></span><br><span class="line">console.log(Symbol.keyFor(s3)) // aaa</span><br><span class="line">console.log(Symbol.keyFor(s4)) // undefined</span><br></pre></td></tr></table></figure><h1 id="Proxy概述"><a href="#Proxy概述" class="headerlink" title="Proxy概述"></a>Proxy概述</h1><p>proxy 用于修改某些操作的默认行为,等同于在语言层面做出修改,所以属于一种元编程, 即对编程语言进行编程</p><p>Proxy 可以理解为在目标对象前架设一个拦截层,外界对该对象的访问都必须先通过这一层拦截,因此提供了一钟机制来对外界的访问进行过滤和改写</p><p>所以,Proxy 也可以理解为一种代理器</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">let obj = new Proxy(&#123;&#125;, &#123;</span><br><span class="line">get: function(target, key, receiver) &#123;</span><br><span class="line">console.log(`getting $&#123;key&#125;`)</span><br><span class="line">return Reflect.get(target, key, receiver)</span><br><span class="line">&#125;,</span><br><span class="line">set: function(target, key, value, receiver) &#123;</span><br><span class="line">console.log(`setting $&#123;key&#125;`)</span><br><span class="line">return Reflect.set(target, key, value, receiver)</span><br><span class="line">&#125;</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">obj.count = 1  // setting count   </span><br><span class="line">obj.count++  // getting count   setting count</span><br></pre></td></tr></table></figure><p>上面的代码说明, proxy实际上重载了点运算符, 即用自己的定义覆盖了语言的原始定义</p><p>一个小技巧是,可以将Proxy对象设置到object.proxy属性,从而可以在object对象上调用</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">var object = &#123;</span><br><span class="line">    proxy: new Proxy(target, handler)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>那么我们就可以直接定义一个proxy对象,并在需要的时候使用Object.create() 进行对象的创建即可</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">var proxy = new Proxy(&#123;&#125;, &#123;</span><br><span class="line">get: function(target, property) &#123;</span><br><span class="line">return 35</span><br><span class="line">&#125;</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">let obj = Object.create(proxy)</span><br><span class="line"></span><br><span class="line">console.log(obj.time)</span><br></pre></td></tr></table></figure><h1 id="Reflect"><a href="#Reflect" class="headerlink" title="Reflect"></a>Reflect</h1><p>Reflect对象和Proxy对象一样, 也是ES6为了操作对象而提供的新api</p><p>reflect对象的设计目的主要有以下几个</p><blockquote><p>将object对象的一些明显属于语言层面的方法放到reflect对象上. 现阶段, 某些方法同时在object和reflect对象上部署, 未来的新方法将只部署在reflect对象上</p></blockquote><blockquote><p>修改某些object方法的返回结果, 让其变得更加合理, 如:<code>Object.defineProperty(obj, name, desc)</code> 在无法定义属性时会抛出一个错误, 而<code>Reflect.defineProperty(obj, name, desc)</code>则会返回一个false</p></blockquote><blockquote><p>让Object操作都变成函数行为, 某些object操作是命令式, 比如<code>name in obj</code>和<code>delete obj[name]</code>, 而<code>Reflect.has(obj, name)</code>和Reflect.deleteProperty(obj, name)让他们变成了函数行为</p></blockquote><blockquote><p>Reflect对象的方法和Proxy对象的方法一一对应, 只要是Proxy对象的方法, 就能在Reflect对象上找到相应的方法. 也就是说, 不管Proxy怎么修改默认行为, 你总可以在Reflect上获取默认行为</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">Proxy(target, &#123;</span><br><span class="line">set: function(target, name, value, receiver) &#123;</span><br><span class="line">var success = Reflect.set(target, name, value, receiver)</span><br><span class="line">if(success) &#123;</span><br><span class="line">log(&apos;property &apos; + name + &apos; on &apos; + target + &apos; set to &apos; + value)</span><br><span class="line">&#125;</span><br><span class="line">return success </span><br><span class="line">&#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>上面的代码中,proxy方法拦截了target对象的属性赋值行为, 它采用<code>Reflect.set</code>方法赋值给对象的属性, 然后再部署额外的功能. </p><p>(完)</p>]]></content>
    
    <summary type="html">
    
      本系列为在我读完阮一峰老师的《ES6标准入门》第二版之后，所做的阅读笔记的整理。 系列博客将采用一个一个的样例，来说明书中的精华部分（当然，这只是我认为的），同时引导新手，快速入门ES6，并逐步将其投入到生产实践中。
    
    </summary>
    
      <category term="ES6标准入门" scheme="http://blog.changerhe.cn/categories/ES6%E6%A0%87%E5%87%86%E5%85%A5%E9%97%A8/"/>
    
    
      <category term="ES6" scheme="http://blog.changerhe.cn/tags/ES6/"/>
    
      <category term="symbol" scheme="http://blog.changerhe.cn/tags/symbol/"/>
    
      <category term="proxy" scheme="http://blog.changerhe.cn/tags/proxy/"/>
    
      <category term="reflect" scheme="http://blog.changerhe.cn/tags/reflect/"/>
    
  </entry>
  
  <entry>
    <title>微信公众平台接口配置信息详解---Nodejs版</title>
    <link href="http://blog.changerhe.cn/2017/03/24/%E5%BE%AE%E4%BF%A1%E5%85%AC%E4%BC%97%E5%B9%B3%E5%8F%B0%E6%8E%A5%E5%8F%A3%E9%85%8D%E7%BD%AE%E4%BF%A1%E6%81%AF%E8%AF%A6%E8%A7%A3---Nodejs%E7%89%88/"/>
    <id>http://blog.changerhe.cn/2017/03/24/微信公众平台接口配置信息详解---Nodejs版/</id>
    <published>2017-03-24T15:11:42.000Z</published>
    <updated>2017-11-22T05:33:31.663Z</updated>
    
    <content type="html"><![CDATA[<p>首先,要说明一点的是, 虽然标题有说是: nodejs版, 那么会有其他的版本配置方法详情吗?</p><p>答案是没有, 不过在微信公众平台上有详细说明了PHP为后台的配置版本, 如果有兴趣的童鞋可以过去看一下, 这里就不做赘述了</p><p>那么本篇博客主要写哪些呢, 博客的受众有哪些呢?</p><p>本篇博客主要是针对需要进行微信公众平台进行开发的个人开发者, 因为在个人申请公众号的过程中存在诸多限制, 而微信则比较体贴地提供了针对个人开发者的公众平台测试帐号, 这样就可以无需申请公众帐号就能在测试帐号中体验并测试微信公众平台所有高级接口了. </p><p>而根据微信方的要求, 个人开发者需要有自己的服务器, 并且对微信的加密token能够正确地进行返回数据, 进行一番验证之后才能够享受微信所提供的开发者服务</p><p>那么问题来了, 我没有服务器怎么办啊?</p><p>哎不对, 我也不会正确的接收token和返回token啊! 怎么搞~</p><p>这里根据实际情况, 因为即使你有服务器, 每次还要登陆服务器, 势必会造成很大的麻烦, 那么我们一般会使用到ngrok的内网转发服务</p><p>想必到这里很多人不知道ngrok是什么, 这里从百度百科扒一个词条过来解释一下</p><blockquote><p>ngrok 是一个反向代理，通过在公共的端点和本地运行的 Web 服务器之间建立一个安全的通道。ngrok 可捕获和分析所有通道上的流量，便于后期分析和重放</p></blockquote><p>讲得那么复杂, 简单总结一下, 就是使用这玩意儿就可以将你的本地开启的服务器当做一个外网服务器来使用, 也就是说从微信发过来的验证token, 是可以直接发送到我们的电脑上, 从而成功校验token, 美滋滋~</p><h1 id="ngrok的使用及配置"><a href="#ngrok的使用及配置" class="headerlink" title="ngrok的使用及配置"></a>ngrok的使用及配置</h1><p>ngrok本身是源自美国的公司提供的一项反向代理的服务, 使用它就可以很方便地进行反向代理了.</p><h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><p><img src="https://ngrok.com/download" alt="官网下载">地址下载, 解压</p><p>将可执行文件ngrok移到任意文件夹内</p><p>如果需要在命令行直接执行, 则需要进行配置全局变量, 这个有些复杂, 就不展开讲了, 如果有不想每次都要找到这个文件双击打开, 而是直接使用CMD的同学, 可以试一下(不过我觉得每次双击打开问价没啥不好的啊)</p><h2 id="注册授权"><a href="#注册授权" class="headerlink" title="注册授权"></a>注册授权</h2><p>现在其实是可以进行正常捕获到请求了, 但是现在有个问题就是, 这一切是不是来的太简单了…</p><p>没错, 还差一步, 就是要官网的一个token</p><p><img src="https://dashboard.ngrok.com/user/signup" alt="sign up for an account in ngrok"> 获取ngrok的授权码,</p><h2 id="进行本机认证-Install-your-authtoken"><a href="#进行本机认证-Install-your-authtoken" class="headerlink" title="进行本机认证 Install your authtoken"></a>进行本机认证 Install your authtoken</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ngrok authtoken &lt;YOUR_AUTHTOKEN&gt;</span><br></pre></td></tr></table></figure><h2 id="设置外网的访问密码-选做"><a href="#设置外网的访问密码-选做" class="headerlink" title="设置外网的访问密码(选做)"></a>设置外网的访问密码(选做)</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">// username 用户名 password密码 8080相关的端口</span><br><span class="line">ngrok http -auth=&quot;username:password&quot; 8080</span><br></pre></td></tr></table></figure><h2 id="配置妥当"><a href="#配置妥当" class="headerlink" title="配置妥当"></a>配置妥当</h2><p>那么现在我们可以输入以下命令, 启动ngrok了</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ngrok http 8080</span><br></pre></td></tr></table></figure><p>当然, 这个端口可以自己设置, 开心就好</p><p>现在我们到浏览器中输入</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">localhost:4040</span><br></pre></td></tr></table></figure><p>即可看到ngrok的监控页面, 上面有为你分配的http和https两个网址,把网址复制到微信公众平台的测试账号申请的接口配置信息中</p><h1 id="离成功还差半步"><a href="#离成功还差半步" class="headerlink" title="离成功还差半步"></a>离成功还差半步</h1><p>那么, 我们成功设置了ngrok了, 现在要准备对接微信的接口了, 微信的access_token每次传输的内容有下面几个:</p><table><thead><tr><th style="text-align:center">参数</th><th style="text-align:center">描述</th></tr></thead><tbody><tr><td style="text-align:center">signature</td><td style="text-align:center">微信加密签名，signature结合了开发者填写的token参数和请求中的timestamp参数、nonce参数。</td></tr><tr><td style="text-align:center">timestamp</td><td style="text-align:center">时间戳</td></tr><tr><td style="text-align:center">nonce</td><td style="text-align:center">随机数</td></tr><tr><td style="text-align:center">echostr</td><td style="text-align:center">随机字符串</td></tr></tbody></table><p>开发者通过检验signature对请求进行校验（下面有校验方式）。若确认此次GET请求来自微信服务器，请原样返回echostr参数内容，则接入生效，成为开发者成功，否则接入失败。加密/校验流程如下：</p><p>-1）将token、timestamp、nonce三个参数进行字典序排序</p><p>-2）将三个参数字符串拼接成一个字符串进行sha1加密</p><p>-3）开发者获得加密后的字符串可与signature对比，标识该请求来源于微信</p><h1 id="PHP实例代码"><a href="#PHP实例代码" class="headerlink" title="PHP实例代码"></a>PHP实例代码</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">private function checkSignature () &#123;</span><br><span class="line">_GET[&quot;signature&quot;];</span><br><span class="line">_GET[&quot;timestamp&quot;];</span><br><span class="line">_GET[&quot;nonce&quot;];</span><br><span class="line">        </span><br><span class="line">tmpArr = array(timestamp, $nonce);</span><br><span class="line">sort($tmpArr, SORT_STRING);</span><br><span class="line">$tmpStr = implode( $tmpArr );</span><br><span class="line">$tmpStr = sha1( $tmpStr );</span><br><span class="line"></span><br><span class="line">if( signature )&#123;</span><br><span class="line">return true;</span><br><span class="line">&#125; else &#123;</span><br><span class="line">return false;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>以上为微信官网的PHP实例代码, 作为一个会nodejs的小学森, 怎么能不用nodejs呢, 看下nodejs的写法</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">const Koa = require(&apos;koa&apos;)</span><br><span class="line">const sha1 = require(&apos;sha1&apos;)</span><br><span class="line"></span><br><span class="line">var config = &#123;</span><br><span class="line">wechat: &#123;</span><br><span class="line">appId: &apos;***&apos;,</span><br><span class="line">appSecret: &apos;***&apos;,</span><br><span class="line">token: &apos;***&apos;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var app = new Koa()</span><br><span class="line"></span><br><span class="line">app.use(function* (next) &#123;</span><br><span class="line">console.log(this.query)</span><br><span class="line"></span><br><span class="line">var token = config.wechat.token</span><br><span class="line">var signature = this.query.signature</span><br><span class="line">var nonce = this.query.nonce</span><br><span class="line">var timestamp = this.query.timestamp</span><br><span class="line">var echostr = this.query.echostr</span><br><span class="line"></span><br><span class="line">var str = [token, timestamp, nonce].sort().join(&apos;&apos;)</span><br><span class="line">var sha = sha1(str)</span><br><span class="line">console.log(sha)</span><br><span class="line">if (sha === signature) &#123;</span><br><span class="line">this.body = echostr</span><br><span class="line">&#125; else &#123;</span><br><span class="line">this.body = &apos;wrong&apos;</span><br><span class="line">&#125;</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">app.listen(8090)</span><br><span class="line"></span><br><span class="line">console.log(&apos;listening 8090&apos;)</span><br></pre></td></tr></table></figure><p>这里用到了koa框架和sha1加密组件, 喜欢其他的方式的童鞋可以使用其他的开发方法, 总体来说都是一样的</p>]]></content>
    
    <summary type="html">
    
      本篇博客主要是针对需要进行微信公众平台进行开发的个人开发者, 因为在个人申请公众号的过程中存在诸多限制, 而微信则比较体贴地提供了针对个人开发者的公众平台测试帐号, 这样就可以无需申请公众帐号就能在测试帐号中体验并测试微信公众平台所有高级接口了. 
    
    </summary>
    
      <category term="微信公众平台" scheme="http://blog.changerhe.cn/categories/%E5%BE%AE%E4%BF%A1%E5%85%AC%E4%BC%97%E5%B9%B3%E5%8F%B0/"/>
    
    
      <category term="微信公众平台" scheme="http://blog.changerhe.cn/tags/%E5%BE%AE%E4%BF%A1%E5%85%AC%E4%BC%97%E5%B9%B3%E5%8F%B0/"/>
    
  </entry>
  
</feed>
