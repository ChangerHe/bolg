<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Changer He&#39;s Home Page</title>
  <subtitle>What doesn&#39;t kill you make you stronger.</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://github.com/ChangerHe/"/>
  <updated>2017-08-17T02:23:31.112Z</updated>
  <id>https://github.com/ChangerHe/</id>
  
  <author>
    <name>Changer He</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>JavaScript笔试面试题收集（三）</title>
    <link href="https://github.com/ChangerHe/2017/08/17/JavaScript%E7%AC%94%E8%AF%95%E9%9D%A2%E8%AF%95%E9%A2%98%E6%94%B6%E9%9B%86%EF%BC%88%E4%B8%89%EF%BC%89/"/>
    <id>https://github.com/ChangerHe/2017/08/17/JavaScript笔试面试题收集（三）/</id>
    <published>2017-08-17T02:13:35.000Z</published>
    <updated>2017-08-17T02:23:31.112Z</updated>
    
    <content type="html"><![CDATA[<p>今天分享的题比较简单,主要是考察闭包的知识以及一些逻辑思维</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">function fun(n,o)&#123;</div><div class="line">	console.log(o)</div><div class="line">	return &#123;</div><div class="line">		fun:function(m)&#123;</div><div class="line">		return fun(m,n)</div><div class="line">	&#125;&#125;</div><div class="line">&#125;</div><div class="line">var a = fun(0);  //undefined</div><div class="line">a.fun(1);  //0</div><div class="line">a.fun(2); // 0</div><div class="line">a.fun(3);  // 0</div><div class="line">var b = fun(0).fun(1).fun(2).fun(3);  //undefined   0    1    2</div><div class="line">var c = fun(0).fun(1);  // undefined   0</div><div class="line">c.fun(2);     // 1</div><div class="line">c.fun(3);     // 1</div></pre></td></tr></table></figure>
<h1 id="个人拙见"><a href="#个人拙见" class="headerlink" title="个人拙见:"></a>个人拙见:</h1><p>其实以上的代码主要还是一个闭包的问题,代码的逻辑判断清楚了就很好解.因为当我们传一个参的时候,第二个参数必然是undefined.这也是为什么abc一出来就执行的是undefined的原因.因为所有的函数执行都只传递了一个参数.</p>
<p>第二,当我们为返还的函数传参的时候,也就是给这个函数里面的函数fun的参数m传值的时候,会返回一个以m为第一个参数,其父函数的第一个参数作为第二个参数的函数.</p>
<p>其实说到这里就很好理解了,我们将函数看成一个很好玩的方法,我们传值进去的时候,它会记录两个值作为参数,并把第二个参数的值打印出来,再往里面传一个值的时候,就会把之前的第一个参数挪到后面作为第二个参数.以此类推.</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;今天分享的题比较简单,主要是考察闭包的知识以及一些逻辑思维&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;div class=
    
    </summary>
    
      <category term="JavaScript笔试面试题" scheme="https://github.com/ChangerHe/categories/JavaScript%E7%AC%94%E8%AF%95%E9%9D%A2%E8%AF%95%E9%A2%98/"/>
    
    
      <category term="JavaScript笔试面试题" scheme="https://github.com/ChangerHe/tags/JavaScript%E7%AC%94%E8%AF%95%E9%9D%A2%E8%AF%95%E9%A2%98/"/>
    
  </entry>
  
  <entry>
    <title>实现某节点子节点的倒序排列</title>
    <link href="https://github.com/ChangerHe/2017/08/16/%E5%AE%9E%E7%8E%B0%E6%9F%90%E8%8A%82%E7%82%B9%E5%AD%90%E8%8A%82%E7%82%B9%E7%9A%84%E5%80%92%E5%BA%8F%E6%8E%92%E5%88%97/"/>
    <id>https://github.com/ChangerHe/2017/08/16/实现某节点子节点的倒序排列/</id>
    <published>2017-08-16T02:03:10.000Z</published>
    <updated>2017-08-16T02:35:00.241Z</updated>
    
    <content type="html"><![CDATA[<p>文章主要是对于一个很容易被忽略的知识点:createDocumentFragment()方法的一个复习,并给大家解锁一个解决给某个标签动态改变其子节点顺序的新姿势.</p>
<p>首先,documentFragment是一个很早之前就被广泛支持的方法,所以犀牛书上面所提供的为element对象增加一个原型方法insertAdjacentHTML()的兼容性写法,大家可以无视了,因为IE7-IE9都亲测完美支持.当然,如果你想碰IE6,就当我没说.</p>
<h1 id="关于性能"><a href="#关于性能" class="headerlink" title="关于性能"></a>关于性能</h1><p>其实createDocumentFragment()这个方法创建的目的,就是把它当做一个特殊的node,作为其他节点的一个临时的容器.</p>
<p>也就是说,当我们需要使用JS为某标签动态插入较多的子节点的时候,我们可以将需要插入的节点组成一个节点树.然后在插入的时候直接把这个节点树一次性插入到文档流中.</p>
<p>相比于每生成一次节点之后马上插入文档流的做法来说,使用createDocumentFragment()方法可以大大减少浏览器的重绘次数,从而能够提升性能.(每当我们进行动态插入节点的时候,都会引起浏览器的一次重绘操作)</p>
<p>有一点要特别注意的是,IE浏览器是例外的,因为IE浏览器的特殊性,导致当我们使用createDocumentFragment()方法进行动态插入时,反倒会降低浏览器的性能.</p>
<h1 id="某节点子节点的倒序排列的JS实现"><a href="#某节点子节点的倒序排列的JS实现" class="headerlink" title="某节点子节点的倒序排列的JS实现"></a>某节点子节点的倒序排列的JS实现</h1><p>了解到createDocumentFragment()这个方法其实这个问题就很简单了.先将源文档的lastChild逐个插入到createDocumentFragment()的节点树中即可.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">function reverse(n)&#123;</div><div class="line">	var f = document.createDocumentFragment();</div><div class="line">	var a = n.childNodes.length</div><div class="line">	for (var i = 0; i &lt; a; i++) &#123;</div><div class="line">		f.appendChild(n.lastChild)</div><div class="line">	&#125;</div><div class="line">	console.log(f)</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>有一点需要大家特别注意的是,当我们不使用a这个局部变量而是直接使用n.childNodes.length,每次for循环都进行重新判定的时候,会发生神奇的现象.n.childNodes.length会离奇般的消失了一半.</p>
<p>其实了解现代浏览器的childNodes.length判定机制的同学都会知道,当我们对文档流进行childNodes判定的时候,其实其子标签两边的空格和回车也是会作为文本节点被算进childNodes.length里面的.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">&lt;ul id=&quot;aUl&quot;&gt;</div><div class="line">	&lt;li&gt;1111&lt;/li&gt;</div><div class="line">	&lt;li&gt;2222&lt;/li&gt;</div><div class="line">	&lt;li&gt;3333&lt;/li&gt;</div><div class="line">	&lt;li&gt;4444&lt;/li&gt;</div><div class="line">	&lt;li&gt;5555&lt;/li&gt;	</div><div class="line">&lt;/ul&gt;</div><div class="line">//当我们打印aUl中的子节点的长度时候,判定结果是11.(IE老版本会出现仅显示长度为5的问题,后面已经更正)</div></pre></td></tr></table></figure>
<p>说到这里其实刚刚说的神奇的现象就很好解释了,因为我们从后面开始进行移动元素”空白文本节点”及li标签的时候,它们的空白节点会动态消失.所以我们使用for循环每次进行判定该文档的长度的时候,以上面的文档结构为例,判定长度为11,但实际上循环次数仅5次.</p>
<p>这个坑很好的教了我们,要将长度判定等拿到for循环外面的重要性啊,不仅能提升性能,还能避免踩坑…</p>
<p>以上.</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;文章主要是对于一个很容易被忽略的知识点:createDocumentFragment()方法的一个复习,并给大家解锁一个解决给某个标签动态改变其子节点顺序的新姿势.&lt;/p&gt;
&lt;p&gt;首先,documentFragment是一个很早之前就被广泛支持的方法,所以犀牛书上面所提供的
    
    </summary>
    
      <category term="JavaScript 学习笔记" scheme="https://github.com/ChangerHe/categories/JavaScript-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="JavaScript" scheme="https://github.com/ChangerHe/tags/JavaScript/"/>
    
  </entry>
  
  <entry>
    <title>JavaScript深入浅出-闭包及闭包问题的解决办法</title>
    <link href="https://github.com/ChangerHe/2017/08/11/JavaScript%E6%B7%B1%E5%85%A5%E6%B5%85%E5%87%BA-%E9%97%AD%E5%8C%85%E5%8F%8A%E8%A7%A3%E5%86%B3%E5%8A%9E%E6%B3%95/"/>
    <id>https://github.com/ChangerHe/2017/08/11/JavaScript深入浅出-闭包及解决办法/</id>
    <published>2017-08-11T07:15:34.000Z</published>
    <updated>2017-08-11T08:13:44.360Z</updated>
    
    <content type="html"><![CDATA[<h1 id="闭包是什么"><a href="#闭包是什么" class="headerlink" title="闭包是什么?"></a>闭包是什么?</h1><p>在JS中可谓处处是闭包,也许你不知道这个概念,但是你一定自己手写过闭包,而且还碰到了闭包的问题.</p>
<p>闭包的最大作用还是解决了全局作用域中的变量被污染的问题.</p>
<p>但是闭包虽有好处,但是也不能滥用,因为闭包的调用机制使得垃圾回收机制(GC)在闭包使用完毕后,无法对其进行回收,使用过多的话会影响到性能.特别是在IE浏览器中,因为IE浏览器在IE8及之前的GC机制使用的是引用计数方式,所以使用闭包会产生内存泄露.万幸在IE9中更正了这个问题,现在绝大部分浏览器实现的是标记清除式的GC机制.</p>
<p>如果必须使用闭包的时候,笔者建议可在闭包使用完之后,可以将其引用变量设置为null,以便清除其占用的内存空间.</p>
<h1 id="一个很简单的闭包例子"><a href="#一个很简单的闭包例子" class="headerlink" title="一个很简单的闭包例子"></a>一个很简单的闭包例子</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">function add() &#123;</div><div class="line">     var a = 100;</div><div class="line">     return function() &#123;</div><div class="line">        return a++;</div><div class="line">     &#125;</div><div class="line">&#125;</div><div class="line">var a = add();</div><div class="line">console.log(a());   //100</div><div class="line">console.log(a());   //101</div></pre></td></tr></table></figure>
<p>看,这就是闭包了,闭包的调用也很方便,直接执行函数中的函数,就可以了.</p>
<h1 id="闭包产生的问题和解决方法"><a href="#闭包产生的问题和解决方法" class="headerlink" title="闭包产生的问题和解决方法"></a>闭包产生的问题和解决方法</h1><p>其实闭包最大的危害就是在函数进行循环调用的时候以及使用回调函数的时候了,之前没懂闭包,做这类问题的时候是相当的头痛啊,这里我就简单介绍一下如何解决这类问题.下面以循环调用为例.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">function returnArr() &#123;</div><div class="line">	var arr = [];</div><div class="line">	for (var i = 0; i &lt; 5; i++) &#123;</div><div class="line">		arr[i] = function() &#123;</div><div class="line">			return i</div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line">	return arr;</div><div class="line">&#125;</div><div class="line">var a = returnArr();</div><div class="line"></div><div class="line">for (var i = 0; i &lt; 5; i++) &#123;</div><div class="line">	console.log(a[i]())   //5 5 5 5 5</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>可能这个时候很多人会觉得很奇怪,这是什么情况啊,我明明是想要输出0 1 2 3 4的啊!这个时候,你其实已经写了一个闭包了.</p>
<h2 id="闭包问题的产生原因"><a href="#闭包问题的产生原因" class="headerlink" title="闭包问题的产生原因"></a>闭包问题的产生原因</h2><p>在循环体中,当我们像平常一样调用函数中的函数的时候,其实这个时候循环体早就执行完毕了,所以这个时候输出的值是一个固定的值,在本题中输出的是5,因为循环一直到4时跳转,在循环到四之后最后还有一个4++的操作,最终输出的是5 </p>
<h2 id="解决闭包问题的方案"><a href="#解决闭包问题的方案" class="headerlink" title="解决闭包问题的方案"></a>解决闭包问题的方案</h2><p>1.将函数体转换为自执行函数,这个时候就可以在循环的同时将函数一起执行了,所以i的值可以正确地传入,但是因为自执行函数是一个封闭的作用域,所以在这个时候应该将i的值作为参数传递到这个封闭作用域中,最后可以得到想要的输出结果.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">function returnArr() &#123;</div><div class="line">	var arr = [];</div><div class="line">	for (var i = 0; i &lt; 5; i++) &#123;</div><div class="line">		arr[i] = function(a) &#123;</div><div class="line">			return a</div><div class="line">		&#125;(i)</div><div class="line">	&#125;</div><div class="line">	return arr;</div><div class="line">&#125;</div><div class="line">var a = returnArr();</div><div class="line">console.log(a);   //0 1 2 3 4</div></pre></td></tr></table></figure>
<p>2.将函数中再嵌套一个函数,然后再执行以下函数中的函数,这样也可以解决闭包问题,但是为什么我在里面又嵌套了一个匿名函数,却没有再次产生闭包的问题呢?这是因为当我们传参给自执行函数时,其参数时直接驻留在自执行函数的内存中的.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">function returnArr() &#123;</div><div class="line">	var arr = [];</div><div class="line">	for (var i = 0; i &lt; 5; i++) &#123;</div><div class="line">		arr[i] = function(a) &#123;</div><div class="line">			return function() &#123;</div><div class="line">				return a;</div><div class="line">			&#125;</div><div class="line">		&#125;(i)</div><div class="line">	&#125;</div><div class="line">	return arr;</div><div class="line">&#125;</div><div class="line">var a = returnArr();</div><div class="line">for (var i = 0; i &lt; 5; i++) &#123;</div><div class="line">	console.log(a[i]())</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h1 id="闭包的时候的this指向问题"><a href="#闭包的时候的this指向问题" class="headerlink" title="闭包的时候的this指向问题"></a>闭包的时候的this指向问题</h1><p>产生闭包的时候,闭包里的this其实是指向window的.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">var box = &#123;</div><div class="line">    getThis: function() &#123;</div><div class="line">        return function() &#123;</div><div class="line">            return this;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line">console.log(box.getThis()()) //window</div></pre></td></tr></table></figure>
<p>那么当我在使用闭包的时候,想让这个this再指回我们的调用对象怎么办呢?这个时候我们的call方法就派上用场了.</p>
<p>很多时候,call和apply的用法是类似的,只是传参不同而已,大部分情况下使用call也意味着可以使用apply.apply就不演示了.其实两者都是一样的.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">var box = &#123;</div><div class="line">	getThis: function() &#123;</div><div class="line">		return function() &#123;</div><div class="line">			return this;</div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line">&#125;</div><div class="line">console.log(box.getThis().call(box)) //box</div></pre></td></tr></table></figure>
<p>当我们不想用call或者apply方法怎么办呢?ES5中新增了一种方法就是bind(),可以将函数的this硬绑定到一个对象上.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">var box = &#123;</div><div class="line">	getThis: function() &#123;</div><div class="line">		return function() &#123;</div><div class="line">			return this;</div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line">&#125;</div><div class="line">var a = box.getThis();</div><div class="line">console.log(a.bind(box)())   //box</div></pre></td></tr></table></figure>
<p>觉得上面的方法复杂,不想用?别急还有一种暴力方法解决这个问题,就是直接在函数体中动刀.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">var box = &#123;</div><div class="line">	getThis: function() &#123;</div><div class="line">		var that = this;</div><div class="line">		return function() &#123;</div><div class="line">			return that;</div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line">&#125;</div><div class="line">console.log(box.getThis()()) //box</div></pre></td></tr></table></figure>
<h1 id="利用闭包来模仿块级作用域"><a href="#利用闭包来模仿块级作用域" class="headerlink" title="利用闭包来模仿块级作用域"></a>利用闭包来模仿块级作用域</h1><p>包含自我执行的匿名函数,就可以创建私有作用域</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">(function() &#123;</div><div class="line">	(function() &#123;</div><div class="line">		for (var i = 0; i &lt; 5; i++) &#123;</div><div class="line"></div><div class="line">		&#125;</div><div class="line">	&#125;)()</div><div class="line">	console.log(i) //ReferenceError: i is not defined</div><div class="line">&#125;)()</div></pre></td></tr></table></figure>
<p>那么根据以上,就可以引申出各种设计模式了.比如说单例模式啊,工厂模式啊.构造函数模式啊巴拉巴拉.这个在我的<code>JavaScript高级程序设计复习笔记（三）</code>这一篇博客里面有详细讲解.</p>
]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;闭包是什么&quot;&gt;&lt;a href=&quot;#闭包是什么&quot; class=&quot;headerlink&quot; title=&quot;闭包是什么?&quot;&gt;&lt;/a&gt;闭包是什么?&lt;/h1&gt;&lt;p&gt;在JS中可谓处处是闭包,也许你不知道这个概念,但是你一定自己手写过闭包,而且还碰到了闭包的问题.&lt;/p&gt;
&lt;p&gt;
    
    </summary>
    
      <category term="JavaScript 学习笔记" scheme="https://github.com/ChangerHe/categories/JavaScript-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="JavaScript" scheme="https://github.com/ChangerHe/tags/JavaScript/"/>
    
  </entry>
  
  <entry>
    <title>JavaScript模块化编程-commonjs和AMD及CMD</title>
    <link href="https://github.com/ChangerHe/2017/08/10/JavaScript%E6%A8%A1%E5%9D%97%E5%8C%96%E7%BC%96%E7%A8%8B-commonjs%E5%92%8CAMD%E5%8F%8ACMD/"/>
    <id>https://github.com/ChangerHe/2017/08/10/JavaScript模块化编程-commonjs和AMD及CMD/</id>
    <published>2017-08-10T15:00:36.000Z</published>
    <updated>2017-08-10T15:01:34.524Z</updated>
    
    <content type="html"><![CDATA[<h1 id="commonjs"><a href="#commonjs" class="headerlink" title="commonjs"></a>commonjs</h1><p>2009年，美国程序员Ryan Dahl创造了node.js项目，将javascript语言用于服务器端编程。</p>
<p>这标志”Javascript模块化编程”正式诞生。因为老实说，在浏览器环境下，没有模块也不是特别大的问题，毕竟网页程序的复杂性有限；但是在服务器端，一定要有模块，与操作系统和其他应用程序互动，否则根本没法编程。</p>
<p>node.js的模块系统，就是参照CommonJS规范实现的。在CommonJS中，有一个全局性方法require()，用于加载模块。假定有一个数学模块math.js，就可以像下面这样加载。</p>
<p><code>var math = require(&#39;math&#39;);</code></p>
<p>然后就可以调用math.js中提供的各种接口API,在自己的程序中直接使用.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">var math = require(&apos;math&apos;);</div><div class="line">math.add(2, 3);   //5</div></pre></td></tr></table></figure>
<h1 id="AMD和CMD"><a href="#AMD和CMD" class="headerlink" title="AMD和CMD"></a>AMD和CMD</h1><p>有了服务器端模块以后，很自然地，大家就想要客户端模块。而且最好两者能够兼容，一个模块不用修改，在服务器和浏览器都可以运行。</p>
<p>但是，由于一个重大的局限，使得CommonJS规范不适用于浏览器环境。还是上一节的代码，如果在浏览器中运行，会有一个很大异步加载的问题.</p>
<p>还是刚刚的代码,当我的程序在使用commonjs规范的时候,因为整个require的请求是异步的,所以当我们使用require进行请求math.js时,必须要等math.js完全加载完毕后,才能够进行下一步的操作.</p>
<p>这对服务器端不是一个问题，因为所有的模块都存放在本地硬盘，可以同步加载完成，等待时间就是硬盘的读取时间。但是，对于浏览器，这却是一个大问题，因为模块都放在服务器端，等待时间取决于网速的快慢，可能要等很长时间，浏览器处于”假死”状态。</p>
<p>因此，浏览器端的模块，不能采用”同步加载”（synchronous），只能采用”异步加载”（asynchronous）。这就是AMD规范诞生的背景。</p>
<h2 id="AMD"><a href="#AMD" class="headerlink" title="AMD"></a>AMD</h2><p>AMD是”Asynchronous Module Definition”的缩写，意思就是”异步模块定义”。它采用异步方式加载模块，模块的加载不影响它后面语句的运行。所有依赖这个模块的语句，都定义在一个回调函数中，等到加载完成之后，这个回调函数才会运行。</p>
<p>AMD也采用require()语句加载模块，但是不同于CommonJS，它要求两个参数：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">require([module], callback);</div></pre></td></tr></table></figure>
<p>第一个参数[module]，是一个数组，里面的成员就是要加载的模块；第二个参数callback，则是加载成功之后的回调函数。如果将前面的代码改写成AMD形式，就是下面这样：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">require([&apos;math&apos;], function (math) &#123;</div><div class="line">　　math.add(2, 3);</div><div class="line">&#125;);</div></pre></td></tr></table></figure>
<p>math.add()与math模块加载不是同步的，浏览器不会发生假死。所以很显然，AMD比较适合浏览器环境。</p>
<p>目前，主要有两个Javascript库实现了AMD规范：require.js和curl.js。</p>
<h2 id="require-js"><a href="#require-js" class="headerlink" title="require.js"></a>require.js</h2><p>最早的时候，所有Javascript代码都写在一个文件里面，只要加载这一个文件就够了。后来，代码越来越多，一个文件不够了，必须分成多个文件，依次加载。</p>
<p>这样的写法有很大的缺点。首先，加载的时候，浏览器会停止网页渲染，加载文件越多，网页失去响应的时间就会越长；其次，由于js文件之间存在依赖关系，因此必须严格保证加载顺序（比如上例的1.js要在2.js的前面），依赖性最大的模块一定要放到最后加载，当依赖关系很复杂的时候，代码的编写和维护都会变得困难。</p>
<p>!()[<a href="http://image.beekka.com/blog/201211/bg2012110701.png" target="_blank" rel="external">http://image.beekka.com/blog/201211/bg2012110701.png</a>]</p>
<p>使用require.js的第一步，是先去官方网站下载最新版本。下载后，假定把它放在js子目录下面，就可以加载了。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">&lt;script src=&quot;js/require.js&quot;&gt;&lt;/script&gt;</div></pre></td></tr></table></figure>
<p>有人可能会想到，加载这个文件，也可能造成网页失去响应。解决办法有两个，一个是把它放在网页底部加载，另一个是写成下面这样：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">&lt;script src=&quot;js/require.js&quot; defer async=&quot;true&quot; &gt;&lt;/script&gt;</div></pre></td></tr></table></figure>
<p>async属性表明这个文件需要异步加载，避免网页失去响应。IE不支持这个属性，只支持defer，所以把defer也写上。</p>
<p>加载require.js以后，下一步就要加载我们自己的代码了。假定我们自己的代码文件是main.js，也放在js目录下面。那么，只需要写成下面这样就行了：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">&lt;script src=&quot;js/require.js&quot; data-main=&quot;js/main&quot;&gt;&lt;/script&gt;</div></pre></td></tr></table></figure>
<p>data-main属性的作用是，指定网页程序的主模块。在上例中，就是js目录下面的main.js，这个文件会第一个被require.js加载。由于require.js默认的文件后缀名是js，所以可以把main.js简写成main。</p>
<h3 id="require-js主模块的写法"><a href="#require-js主模块的写法" class="headerlink" title="require.js主模块的写法"></a>require.js主模块的写法</h3><p>上一节的main.js，我把它称为”主模块”，意思是整个网页的入口代码。它有点像C语言的main()函数，所有代码都从这儿开始运行。主模块依赖于其他模块，这时就要使用AMD规范定义的的require()函数。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">// main.js</div><div class="line">require([&apos;moduleA&apos;, &apos;moduleB&apos;, &apos;moduleC&apos;], function (moduleA, moduleB, moduleC)&#123;</div><div class="line">　　　　// some code here</div><div class="line">&#125;);</div></pre></td></tr></table></figure>
<p>require()函数接受两个参数。第一个参数是一个数组，表示所依赖的模块，上例就是[‘moduleA’, ‘moduleB’, ‘moduleC’]，即主模块依赖这三个模块；第二个参数是一个回调函数，当前面指定的模块都加载成功后，它将被调用。加载的模块会以参数形式传入该函数，从而在回调函数内部就可以使用这些模块。</p>
<p>require()异步加载moduleA，moduleB和moduleC，浏览器不会失去响应；它指定的回调函数，只有前面的模块都加载成功后，才会运行，解决了依赖性的问题。</p>
]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;commonjs&quot;&gt;&lt;a href=&quot;#commonjs&quot; class=&quot;headerlink&quot; title=&quot;commonjs&quot;&gt;&lt;/a&gt;commonjs&lt;/h1&gt;&lt;p&gt;2009年，美国程序员Ryan Dahl创造了node.js项目，将javascript语言
    
    </summary>
    
      <category term="JavaScript模块化编程" scheme="https://github.com/ChangerHe/categories/JavaScript%E6%A8%A1%E5%9D%97%E5%8C%96%E7%BC%96%E7%A8%8B/"/>
    
    
      <category term="JavaScript模块化编程" scheme="https://github.com/ChangerHe/tags/JavaScript%E6%A8%A1%E5%9D%97%E5%8C%96%E7%BC%96%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>JavaScript躲坑指南（二）</title>
    <link href="https://github.com/ChangerHe/2017/08/09/JavaScript%E8%BA%B2%E5%9D%91%E6%8C%87%E5%8D%97%EF%BC%88%E4%BA%8C%EF%BC%89/"/>
    <id>https://github.com/ChangerHe/2017/08/09/JavaScript躲坑指南（二）/</id>
    <published>2017-08-09T15:02:38.000Z</published>
    <updated>2017-08-09T15:08:51.857Z</updated>
    
    <content type="html"><![CDATA[<p>本系列将会写一些在正常工作中会遇到的一些坑,然后分析它们的产生原因及解决办法.本文的内容主要来自&lt;you don’t know JS&gt;及日常工作的问题的一些总结.</p>
<h1 id="关于arguments的使用"><a href="#关于arguments的使用" class="headerlink" title="关于arguments的使用:"></a>关于arguments的使用:</h1><p>arguments在ES6之前简直就是福音,因为在ES6之前是没有办法取到函数的参数组成的数组的.</p>
<p>但是arguments在使用的过程中还是有一些坑的,我们来看一下:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">function foo(a) &#123;</div><div class="line">    a = 42;</div><div class="line">    console.log(arguments[0])</div><div class="line">&#125;</div><div class="line">foo(2);   //42</div><div class="line">foo();    //undefined</div></pre></td></tr></table></figure>
<p>在向函数传递参数的时候,arguments数组中的对应单元会和命名参数建立关联,以得到相同的值,但是当函数在调用的时候没有传递参数时,因为没有参数,自然arguments就无法和函数建立关联了,自然就是undefined.</p>
<h1 id="try-catch-finally的内容执行先后的问题"><a href="#try-catch-finally的内容执行先后的问题" class="headerlink" title="try/catch/finally的内容执行先后的问题"></a>try/catch/finally的内容执行先后的问题</h1><p>finally中的代码总是会在try之后执行,如果有catch的话会在catch之后执行.其实也可以把finally中的代码当做一个回调函数.无论出现什么情况,最后一定会被调用.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">function foo() &#123;</div><div class="line">    try &#123;</div><div class="line">        return 42;</div><div class="line">    &#125; finally &#123;</div><div class="line">        console.log(&apos;hello&apos;)</div><div class="line">    &#125;</div><div class="line">    console.log(&apos;never runs&apos;);</div><div class="line">&#125;</div><div class="line">console.log(foo());</div><div class="line">//输出结果: 先输出 hello  再输出返回的值hello</div></pre></td></tr></table></figure>
<p>在这里return42先执行,并将foo()函数的返回值设置为42.try执行完毕后执行finally.console.log()显示的是函数的返回值.</p>
<p>对于这个问题还有一个很好玩的东西,就是当你在finally中进行抛出异常时,其实try中的返回值就不生效了.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">function foo() &#123;</div><div class="line">    try &#123;</div><div class="line">        return  42;</div><div class="line">    &#125; finally &#123;</div><div class="line">        throw &quot;oops!&quot;</div><div class="line">    &#125;</div><div class="line">    console.log(&apos;never runs&apos;);</div><div class="line">&#125;</div><div class="line">console.log(foo()); // Uncaught oops!</div></pre></td></tr></table></figure>
<p>其实综上而言,不论try中执行的是什么东西,即使是<code>return</code>或者<code>throw</code>等让函数立即结束的语句,最后finally也会成功执行.但是当<code>finally</code>中抛出异常时,<code>try</code>中的代码其实就相当于无效了.也就是finally中的值会最终覆盖掉try中的值.</p>
<h1 id="关于全局的DOM变量"><a href="#关于全局的DOM变量" class="headerlink" title="关于全局的DOM变量"></a>关于全局的DOM变量</h1><p>当我们在文档流中加入 <code>&lt;div id=&quot;foo&quot;&gt;&lt;/div&gt;</code> 时,我们在其下面的js文档中能否找到foo这个变量呢?答案是可以!</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">//我们直接在文档的下面进行类型判定</div><div class="line">console.log(typeof foo);   //输出结果是object,   WTF?</div></pre></td></tr></table></figure>
<h1 id="关于属性的屏蔽"><a href="#关于属性的屏蔽" class="headerlink" title="关于属性的屏蔽"></a>关于属性的屏蔽</h1><p>当我们在原型链中为底层函数操作原型链中的属性进行算术运算时,属性被被底层函数给屏蔽掉.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">var anotherObject = &#123;</div><div class="line">    a: 2</div><div class="line">&#125;</div><div class="line">var myObject = Object.create(anotherObject);</div><div class="line">console.log(myObject.a);</div><div class="line">myObject.a++;</div><div class="line">console.log(myObject.a,anotherObject.a);</div></pre></td></tr></table></figure>
<p>其实想到原理就很简单,因为当我们把<code>myObject</code>中的a,也就是<code>anotherObject</code>中的a调用之后,相应的<code>myObject.a</code>会得到<code>anotherObject</code>中的a的值,也就是2.但是当我们对<code>myObject</code>执行其属性的自加操作之后,它的底层其实是这样的:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">myObject.__proto__.a = 2;</div><div class="line">myObject= &#123;a:myObject.__proto__.a&#125;;</div><div class="line">myObject.a = myObject.a + 1;</div></pre></td></tr></table></figure>
<h1 id="关于concat-方法连接数组和push-方法连接数组的区别"><a href="#关于concat-方法连接数组和push-方法连接数组的区别" class="headerlink" title="关于concat()方法连接数组和push()方法连接数组的区别"></a>关于concat()方法连接数组和push()方法连接数组的区别</h1><p>首先我们看一个例子:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">var nums = [2, 3, 4, 5];</div><div class="line">console.log(nums.concat([1, 2]))</div><div class="line">//[2, 3, 4, 5, 1, 2]</div><div class="line">console.log(nums)</div><div class="line">//[2, 3, 4, 5]</div><div class="line">nums.push([1, 2])</div><div class="line">console.log(nums)</div><div class="line">[2, 3, 4, 5, [1, 2]]</div></pre></td></tr></table></figure>
<p>其实看了这个例子大家应该都懂了,首先,<code>concat</code>的作用是链接两个数组,会将两个数组拼合成一个数组,并且不会改变之前的数组的值,而是返回一个新数组.</p>
<p>而<code>push()</code>则直接改变了数组的值,而且是直接将<code>push()</code>中传的参数直接接到了数组的后面,也就是当我们在<code>push()</code>中传参数组时,最后会得到一个嵌套的数组.</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本系列将会写一些在正常工作中会遇到的一些坑,然后分析它们的产生原因及解决办法.本文的内容主要来自&amp;lt;you don’t know JS&amp;gt;及日常工作的问题的一些总结.&lt;/p&gt;
&lt;h1 id=&quot;关于arguments的使用&quot;&gt;&lt;a href=&quot;#关于arguments
    
    </summary>
    
      <category term="JavaScript躲坑指南" scheme="https://github.com/ChangerHe/categories/JavaScript%E8%BA%B2%E5%9D%91%E6%8C%87%E5%8D%97/"/>
    
    
      <category term="JavaScript躲坑指南" scheme="https://github.com/ChangerHe/tags/JavaScript%E8%BA%B2%E5%9D%91%E6%8C%87%E5%8D%97/"/>
    
  </entry>
  
  <entry>
    <title>JavaScript躲坑指南（一）</title>
    <link href="https://github.com/ChangerHe/2017/08/08/JavaScript%E8%BA%B2%E5%9D%91%E6%8C%87%E5%8D%97%EF%BC%88%E4%B8%80%EF%BC%89/"/>
    <id>https://github.com/ChangerHe/2017/08/08/JavaScript躲坑指南（一）/</id>
    <published>2017-08-08T15:03:29.000Z</published>
    <updated>2017-08-08T15:27:21.200Z</updated>
    
    <content type="html"><![CDATA[<p>本系列将会写一些在正常工作中会遇到的一些坑,然后分析它们的产生原因及解决办法.本文的内容主要来自&lt;you don’t know JS&gt;及日常工作的问题的一些总结.</p>
<h1 id="坑一-关于parseInt-方法转换字符串的问题-神坑"><a href="#坑一-关于parseInt-方法转换字符串的问题-神坑" class="headerlink" title="坑一: 关于parseInt()方法转换字符串的问题,神坑!"></a>坑一: 关于parseInt()方法转换字符串的问题,神坑!</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">console.log(parseInt(1/0, 19));  //18</div><div class="line">//原因:1/0得到的结果是Infinity,而得到的Infinity本身其实也是一个字符串,所以parseInt会以19进制对其进行类型转换,首字母为I,则其结果则为18了.</div><div class="line">console.log(parseInt(.000009))    //0</div><div class="line">console.log(parseInt(.0000009))   //9</div><div class="line">console.log(parseInt(false, 16))  //250,判定&apos;false&apos;的字符串的&apos;fa&apos;为十六进制了</div><div class="line">console.log(parseInt(parseInt, 16))  //15</div><div class="line">//结果为15的原因是因为parseInt为函数,所以会被typeof为function,</div></pre></td></tr></table></figure>
<h1 id="坑二-位运算符-的妙用"><a href="#坑二-位运算符-的妙用" class="headerlink" title="坑二: 位运算符~的妙用:"></a>坑二: 位运算符~的妙用:</h1><p>在许多编程语言中,查找值或函数执行过程中,大于等于0的值表示查找或执行成功,返回-1则表示查找或执行失败.因此当失败时,可以直接使用位运算符~进行判定,当为-1时, -(-1 + 1) 即为零,因此就可以直接进行布尔运算了.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">var a = &quot;hello world&quot;;</div><div class="line">if(~a.indexof(&quot;lo&quot;))&#123;</div><div class="line">	//查找不到值,则执行函数体中的内容</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>位运算的另一个巧妙用法:将值截除为一个32位整数</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">console.log(Math.floor(-.1))  //-1</div><div class="line">console.log(Math.floor(.1))  //0</div><div class="line">console.log(~~-.1)   // 0</div><div class="line">console.log(~~.1)    //0</div></pre></td></tr></table></figure>
<h1 id="坑三-对于稀疏数组的输出差异"><a href="#坑三-对于稀疏数组的输出差异" class="headerlink" title="坑三: 对于稀疏数组的输出差异"></a>坑三: 对于稀疏数组的输出差异</h1><p>在谷歌浏览器中,对于长度为三,无内容的稀疏数组显示为undefined*3,对于长度为三,但内容都赋值为undefined的数组,显示为[undefined, undefined, undefined].但是此情况在IE浏览器中显示的内容都是两个等号!不过在火狐中相对比较正常,输出的是文字”三个空的数组”和[undefined, undefined, undefined]</p>
<h1 id="坑四-JSON-stringify的妙用"><a href="#坑四-JSON-stringify的妙用" class="headerlink" title="坑四: JSON.stringify的妙用:"></a>坑四: JSON.stringify的妙用:</h1><p>在序列化为JSON对象时,将该对象选择性输出,以得到想要的值;</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">var a = &#123;</div><div class="line">    b: 42,</div><div class="line">    c: &apos;41&apos;,</div><div class="line">    d: [1,2,3]</div><div class="line">&#125;</div><div class="line">console.log(JSON.stringify(a, [&apos;b&apos;,&apos;d&apos;]))   //&#123;&quot;b&quot;:42,&quot;d&quot;:[1,2,3]&#125;</div></pre></td></tr></table></figure>
<p>当然,这个时候stringify还可以传递一个函数进去进行判断.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">var a = &#123;</div><div class="line">    b: 42,</div><div class="line">    c: &apos;41&apos;,</div><div class="line">    d: [1,2,3]</div><div class="line">&#125;</div><div class="line">console.log(JSON.stringify(a, function(k, v)&#123;</div><div class="line">	if(k !== &apos;c&apos;) return v;</div><div class="line">&#125;))   //&#123;&quot;b&quot;:42,&quot;d&quot;:[1,2,3]&#125;</div></pre></td></tr></table></figure>
<p>JSON.stringify()还有一个参数space,用来指定输出的缩进格式,space为数值时表示缩进的字符数,还可以是字符串,为字符串时最前面的十个字符用于每一级的缩进:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">var a = &#123;</div><div class="line">    b: 42,</div><div class="line">    c: &apos;41&apos;,</div><div class="line">    d: [1,2,3]</div><div class="line">&#125;</div><div class="line">console.log(JSON.stringify(a, null, &quot;------------------&quot;));</div><div class="line">//&#123;</div><div class="line">//----------&quot;b&quot;: 42,</div><div class="line">//----------&quot;c&quot;: &quot;41&quot;,</div><div class="line">//----------&quot;d&quot;: [</div><div class="line">//--------------------1,</div><div class="line">//--------------------2,</div><div class="line">//--------------------3</div><div class="line">//----------]</div><div class="line">//&#125;</div></pre></td></tr></table></figure>
<p>从上面来看,使用位运算得到的值和Math.floor() 的值不尽相同,使用位运算相当于直接去掉了数字的小数点.</p>
<h1 id="坑五-当在函数内部为变量指定新值后-并不影响传参的值"><a href="#坑五-当在函数内部为变量指定新值后-并不影响传参的值" class="headerlink" title="坑五: 当在函数内部为变量指定新值后,并不影响传参的值."></a>坑五: 当在函数内部为变量指定新值后,并不影响传参的值.</h1><p>当函数内部制定了变量值后,输出的值是不一样的,我们来看一下例子:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">function foo(x) &#123;</div><div class="line">	x.push(4);</div><div class="line">	console.log(x);   //输出的是[1,2,3,4],没毛病</div><div class="line">	x = [4,5,6];</div><div class="line">	x.push(7);</div><div class="line">	console.log(x);   //输出[4,5,6,7]这个没毛病</div><div class="line">&#125;</div><div class="line">var a = [1,2,3];</div><div class="line">foo(a);</div><div class="line">console.log(a);     //这个情况下,a的值其实是[1,2,3,4];</div></pre></td></tr></table></figure>
<p>其实主要的原因是这样的,当我们的a作为参数传到foo函数中的时候,foo中的参数x其实是获得了一个到a数组的指针,当x进行相应的数值处理操作的时候,会直接作用到a上面,但是当x的指针改变了,也就是x被重新赋值的时候,x的指针就指向新的[4,5,6]数组了,这个时候其实后面的push(7)的操作已经是对于新的数组,并没有对a数组进行相应的操作,故最后返回的a的值只是[1,2,3,4]</p>
<h1 id="坑六-为变量赋予常量值的问题"><a href="#坑六-为变量赋予常量值的问题" class="headerlink" title="坑六: 为变量赋予常量值的问题"></a>坑六: 为变量赋予常量值的问题</h1><p>一个很小的问题(其实涉及到的知识点和上面是类似的),当我为一个变量赋予了一个常量值,但通过函数对这个常量值进行更改,那么更改会不会体现到这个常量值中呢?<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">function foo(x) &#123;</div><div class="line">	x = x + 1;</div><div class="line">	console.log(x);</div><div class="line">&#125;</div><div class="line">var a = 2;</div><div class="line">foo(a);</div><div class="line">console.log(a);  //此时a还是为2</div></pre></td></tr></table></figure></p>
<h1 id="坑七-关于浅复制的一些小技巧-也是对上面问题的另一种出理方案"><a href="#坑七-关于浅复制的一些小技巧-也是对上面问题的另一种出理方案" class="headerlink" title="坑七: 关于浅复制的一些小技巧(也是对上面问题的另一种出理方案)"></a>坑七: 关于浅复制的一些小技巧(也是对上面问题的另一种出理方案)</h1><p>使用slice()方法对变量进行浅复制,达到不影响变量原来的值的目的.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">foo(slice() )</div></pre></td></tr></table></figure>
<h1 id="坑八-new出的对象"><a href="#坑八-new出的对象" class="headerlink" title="坑八: new出的对象"></a>坑八: new出的对象</h1><p>使用new方法new出来的变量都是属于对象,因此进行类型检测时都会显示为object型.</p>
<h1 id="坑九-关于隐式类型转换"><a href="#坑九-关于隐式类型转换" class="headerlink" title="坑九: 关于隐式类型转换"></a>坑九: 关于隐式类型转换</h1><p>对new出来的对象来讲,对其进行判断会有一个自动的隐式类型转换过程,自动调用数组中的valueof()方法,因此就有了以下这样的奇葩现象:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">var a = 2;</div><div class="line">Number.prototype.valueOf = function() &#123;</div><div class="line">    return a++;</div><div class="line">&#125;</div><div class="line">var b = new Number(2);</div><div class="line">if(b == 2 &amp;&amp; b ==3) &#123;</div><div class="line">    console.log(&apos;WTF?&apos;)   //WTF?</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>其实这个问题很好解释,每次对b进行判断都是会调用其valueof方法,而valueof方法中a会自增1,因此会有b又等于2,又等于3的情况.</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本系列将会写一些在正常工作中会遇到的一些坑,然后分析它们的产生原因及解决办法.本文的内容主要来自&amp;lt;you don’t know JS&amp;gt;及日常工作的问题的一些总结.&lt;/p&gt;
&lt;h1 id=&quot;坑一-关于parseInt-方法转换字符串的问题-神坑&quot;&gt;&lt;a href=
    
    </summary>
    
      <category term="JavaScript躲坑指南" scheme="https://github.com/ChangerHe/categories/JavaScript%E8%BA%B2%E5%9D%91%E6%8C%87%E5%8D%97/"/>
    
    
      <category term="JavaScript躲坑指南" scheme="https://github.com/ChangerHe/tags/JavaScript%E8%BA%B2%E5%9D%91%E6%8C%87%E5%8D%97/"/>
    
  </entry>
  
  <entry>
    <title>JavaScript深入浅出-call/apply</title>
    <link href="https://github.com/ChangerHe/2017/08/07/JavaScript%E6%B7%B1%E5%85%A5%E6%B5%85%E5%87%BA-call-apply/"/>
    <id>https://github.com/ChangerHe/2017/08/07/JavaScript深入浅出-call-apply/</id>
    <published>2017-08-07T14:51:48.000Z</published>
    <updated>2017-08-07T14:56:17.125Z</updated>
    
    <content type="html"><![CDATA[<p>本文中call和apply仅占小部分,主要还是关于自己在学习过程中踩到的坑的记录.</p>
<h1 id="使用call方法将变量产生的数组进行转换"><a href="#使用call方法将变量产生的数组进行转换" class="headerlink" title="使用call方法将变量产生的数组进行转换"></a>使用call方法将变量产生的数组进行转换</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">function foo(a, b, c) &#123;</div><div class="line">    var arr1 = [].reverse.call(arguments);</div><div class="line">    console.log(arr1);</div><div class="line">    var arr2 = [].slice.call(arguments);</div><div class="line">    console.log(arr2.reverse());</div><div class="line">&#125;</div><div class="line">foo(1,2,3)</div></pre></td></tr></table></figure>
<p>以上使用了两种方法，arr1使用了数组的reverse方法，并将数组的reverse方法借用给arguments，也就是说arguments使用了数组中的方法，之前的arguments是没有这个方法的。其最终产生的效果是，arr1还是数组的集合。</p>
<p>第二种方法其实是首先将数组的slice方法的作用域赋予给arguments，那么arguments其实是使用了slice的方法进行了数组的序列化，最终产生的效果其实是arr2最终变成了一个数组，然后使用数组，也就是arr2的作用域链中的reverse方法进行了调换。</p>
<h1 id="arrow函数"><a href="#arrow函数" class="headerlink" title="arrow函数"></a>arrow函数</h1><p> 箭头函数其实是对于单调乏味且冗长的function关键词的简写，如：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">var foo = a =&gt; &#123;</div><div class="line">    console.log(a)</div><div class="line">&#125;</div><div class="line">foo(2);   //2</div></pre></td></tr></table></figure>
<p>其实在这个情况下，以上的程序是等价于以下的程序的：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">var foo = function(a) &#123;</div><div class="line">	console.log(a);</div><div class="line">&#125;</div><div class="line">foo(2);</div></pre></td></tr></table></figure>
<p>那么问题来了，这个箭头函数到底表示的是函数表达式还是函数声明呢？，经过一个简单的测试，发现其实这个箭头函数就是一个简单的函数表达式，我们来测试以下它的函数提升过程：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">foo(2);</div><div class="line">var foo = a =&gt; &#123;</div><div class="line">	console.log(a);    //TypeError: foo is not a function</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h1 id="严格模式下必报的this指向问题"><a href="#严格模式下必报的this指向问题" class="headerlink" title="严格模式下必报的this指向问题"></a>严格模式下必报的this指向问题</h1><p>严格模式下，全局对象无法绑定到未进行修饰的函数声明，因此在全局作用域下，在函数内调用this时会造成报错： Cannot read property ‘a’ of undefined；<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">(function foo() &#123;</div><div class="line">	&quot;use strict&quot;;</div><div class="line">	var a = 2;</div><div class="line">	console.log(this.a);   //Cannot read property &apos;a&apos; of undefined；</div><div class="line">&#125;)()</div></pre></td></tr></table></figure></p>
<h1 id="关于this的作用层级问题"><a href="#关于this的作用层级问题" class="headerlink" title="关于this的作用层级问题"></a>关于this的作用层级问题</h1><p>对象中只有引用链的最顶层或者说是作用者的最后一层会影响其调用位置，来看一下下面的这个代码，很奇怪的事情是this居然指向的是obj1 而不是obj2，原因就是因为作用者的最后一层就是obj1.<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">function foo() &#123;</div><div class="line">	console.log(this.a);</div><div class="line">&#125;</div><div class="line">var obj1 = &#123;</div><div class="line">	a: 1,</div><div class="line">	foo: foo</div><div class="line">&#125;</div><div class="line">var obj2 = &#123;</div><div class="line">	a: 2,</div><div class="line">	obj1: obj1</div><div class="line">&#125;</div><div class="line">obj2.obj1.foo();    //输出的是1，也就是代表this其实指向的是obj1</div></pre></td></tr></table></figure></p>
<h1 id="引用类型常量的赋值问题"><a href="#引用类型常量的赋值问题" class="headerlink" title="引用类型常量的赋值问题"></a>引用类型常量的赋值问题</h1><p>当函数内部制定了变量值后,输出的值是不一样的,我们来看一下例子:<br>function foo(x) {<br>    x.push(4);<br>    console.log(x);   //输出的是[1,2,3,4],没毛病<br>    x = [4,5,6];<br>    x.push(7);<br>    console.log(x);   //输出[4,5,6,7]这个没毛病<br>}<br>var a = [1,2,3];<br>foo(a);<br>console.log(a);     //这个情况下,a的值其实是[1,2,3,4];<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">其实主要的原因是这样的,当我们的a作为参数传到foo函数中的时候,foo中的参数x其实是获得了一个到a数组的指针,当x进行相应的数值处理操作的时候,会直接作用到a上面,但是当x的指针改变了,也就是x被重新赋值的时候,x的指针就指向新的[4,5,6]数组了,这个时候其实后面的push(7)的操作已经是对于新的数组,并没有对a数组进行相应的操作,故最后返回的a的值只是[1,2,3,4]</div><div class="line"></div><div class="line"># 引用类型常量的赋值问题再探讨</div><div class="line"></div><div class="line">一个很小的问题(其实涉及到的知识点和第五条是类似的),当我为一个变量赋予了一个常量值,但通过函数对这个常量值进行更改,那么更改会不会体现到这个常量值中呢?</div></pre></td></tr></table></figure></p>
<p>function foo(x) {<br>    x = x + 1;<br>    console.log(x);<br>}<br>var a = 2;<br>foo(a);<br>console.log(a);  //此时a还是为2<br>```</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本文中call和apply仅占小部分,主要还是关于自己在学习过程中踩到的坑的记录.&lt;/p&gt;
&lt;h1 id=&quot;使用call方法将变量产生的数组进行转换&quot;&gt;&lt;a href=&quot;#使用call方法将变量产生的数组进行转换&quot; class=&quot;headerlink&quot; title=&quot;使用c
    
    </summary>
    
      <category term="JavaScript 学习笔记" scheme="https://github.com/ChangerHe/categories/JavaScript-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="JavaScript" scheme="https://github.com/ChangerHe/tags/JavaScript/"/>
    
  </entry>
  
  <entry>
    <title> JavaScript笔试面试题收集（二）</title>
    <link href="https://github.com/ChangerHe/2017/08/04/JavaScript%E7%AC%94%E8%AF%95%E9%9D%A2%E8%AF%95%E9%A2%98%E6%94%B6%E9%9B%86%EF%BC%88%E4%BA%8C%EF%BC%89/"/>
    <id>https://github.com/ChangerHe/2017/08/04/JavaScript笔试面试题收集（二）/</id>
    <published>2017-08-04T14:37:45.000Z</published>
    <updated>2017-08-04T14:48:02.448Z</updated>
    
    <content type="html"><![CDATA[<p>话不多说，直接撸题吧：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div></pre></td><td class="code"><pre><div class="line">function Parent() &#123;</div><div class="line">    this.a = 1;</div><div class="line">    this.b = [1,2,this.a];</div><div class="line">    this.c = &#123;demo: 5&#125;;</div><div class="line">    this.show = function() &#123;</div><div class="line">        console.log(this.a, this.b, this.c.demo)</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line">function Child() &#123;</div><div class="line">    this.a = 2;</div><div class="line">    this.change = function() &#123;</div><div class="line">        this.b.push(this.a);</div><div class="line">        this.a = this.b.length;</div><div class="line">        this.c.demo = this.a++;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line">Child.prototype = new Parent();</div><div class="line">var parent = new Parent();</div><div class="line">var child1 = new Child();</div><div class="line">var child2 = new Child();</div><div class="line">child1.a = 11;</div><div class="line">child2.a = 12;</div><div class="line">parent.show();  //1,[1,2,1],5</div><div class="line">child1.show(); //11,[1,2,11],5</div><div class="line">child2.show();   //12,[1,2,11],5</div><div class="line">child1.change(); </div><div class="line">child2.change();  </div><div class="line">parent.show();  // 1,[1,2,1],5</div><div class="line">child1.show(); //5,[1,2,1,11,12],5</div><div class="line">child2.show();   //6,[1,2,1,11,12],5</div></pre></td></tr></table></figure></p>
<p>其实要解出上面的问题，了解以下几句话就好了：</p>
<blockquote>
<p>1.每个构造函数，都有一个原型，指向构造函数的原型对象。<br>2.每一个实例生成的时候，都会在内存中产生一块新的堆内存。<br>3.每一个实例都有一个隐式原型指向构造函数的原型对象。<br>4.this的指向，取决于this调用的位置，在这道题中，也可以理解为，谁调用这个方法，this就指向哪个对象。<br>5.数组和字面量对象都是引用。<br>6.原型链的查找原则： 就近原则。也就是说：当实例上存在属性时，用实例上的，如果实例不存在，则顺着原型链往上查找，如果存在，则使用原型链上的对象，如果不存在，则查找Object原型对象上的，如果都不存在，则为undefined。</p>
</blockquote>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;话不多说，直接撸题吧：&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;2&lt;/div&gt;&lt;div 
    
    </summary>
    
      <category term="JavaScript笔试面试题" scheme="https://github.com/ChangerHe/categories/JavaScript%E7%AC%94%E8%AF%95%E9%9D%A2%E8%AF%95%E9%A2%98/"/>
    
    
      <category term="JavaScript笔试面试题" scheme="https://github.com/ChangerHe/tags/JavaScript%E7%AC%94%E8%AF%95%E9%9D%A2%E8%AF%95%E9%A2%98/"/>
    
  </entry>
  
  <entry>
    <title>使用Canvas绘制七巧板</title>
    <link href="https://github.com/ChangerHe/2017/07/27/%E4%BD%BF%E7%94%A8Canvas%E7%BB%98%E5%88%B6%E4%B8%83%E5%B7%A7%E6%9D%BF/"/>
    <id>https://github.com/ChangerHe/2017/07/27/使用Canvas绘制七巧板/</id>
    <published>2017-07-27T12:59:49.000Z</published>
    <updated>2017-07-27T15:00:38.011Z</updated>
    
    <content type="html"><![CDATA[<p>中午登上慕课网，偶然发现慕课网改版了，这倒是其次，惊奇的是页面居然出现了不显示我的观看记录和观看百分比的BUG！还准备说要给慕课网反馈一下来着，晚上一登，居然修复了，不得不佩服慕课网工程师们惊人的处突能力啊。</p>
<p>回到正题，相信大家都见到过七巧板，本文使用简单的HTML5新特性Canvas的2d图形绘制功能，绘制了一个简单的七巧板。</p>
<p>Canvas是HTML5的新特性，相比于其他的HTML标签来说，Canvas给前端工程师们提供了更多的操作可能性，也为页面的生动化效果做出了不菲的贡献。canvas的3d绘图的出现，加上JS对HTML页面的强大动态渲染能力，加上各大浏览器厂商对于Flash的抛弃，相信日后canvas将在HTML页面展示，HTML游戏，HTML动画上大有可为。</p>
<p>canvas的2d绘图非常简单，整体的操作感觉非常的人性化，主要是要区分，移动到点位（moveTo）和划线到点位（lineTo）的区别，canvas对于页面的色彩和轮廓方面也加入了相应的边框（stroke）和填充（fill）功能，下面让我们一起来看一下七巧板的canvas实现吧。</p>
<h1 id="HTML方面"><a href="#HTML方面" class="headerlink" title="HTML方面"></a>HTML方面</h1><p>这块我就写了一个canvas的标签，同时制定它的宽高等属性，有一点要注意，其宽高最好不要使用px作为单位，而是使用默认值作为单位（简单点说就是不要写宽高的单位），否则在后期绘图会出现绘图区的一些问题。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">&lt;canvas id=&quot;canvas&quot; width=&quot;800&quot; height=&quot;800&quot; style=&quot;border: 1px solid #eee&quot;&gt;Your broser can&apos;t support canvas&lt;/canvas&gt;</div></pre></td></tr></table></figure>
<h1 id="JS方面"><a href="#JS方面" class="headerlink" title="JS方面"></a>JS方面</h1><p>学过canvas的同学肯定知道，2d绘图简直就是小儿科，用来用去也就那么几个API，照本宣科就是了。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line">var canvas = document.getElementById(&quot;canvas&quot;);</div><div class="line">var context = canvas.getContext(&quot;2d&quot;);</div><div class="line">var arr = [</div><div class="line">	&#123;position: [&#123;x: 0,y: 0&#125;,&#123;x: 400,y: 400&#125;,&#123;x: 800,y: 0&#125;,&#123;x: 0,y: 0&#125;],color: &quot;#caff67&quot;&#125;,</div><div class="line">	&#123;position: [&#123;x: 0,y: 0&#125;,&#123;x: 400,y: 400&#125;,&#123;x: 0,y: 800&#125;,&#123;x: 0,y: 0&#125;],color: &quot;#67becf&quot;&#125;,</div><div class="line">	&#123;position: [&#123;x: 0,y: 800&#125;,&#123;x: 400,y: 400&#125;,&#123;x: 800,y: 800&#125;,&#123;x: 0,y: 800&#125;],color: &quot;#ef3d61&quot;&#125;,</div><div class="line">	&#123;position: [&#123;x: 400,y: 400&#125;,&#123;x: 800,y: 400&#125;,&#123;x: 600,y: 600&#125;,&#123;x: 400,y: 400&#125;],color: &quot;#f9f51a&quot;&#125;,</div><div class="line">	&#123;position: [&#123;x: 400,y: 400&#125;,&#123;x: 800,y: 400&#125;,&#123;x: 800,y: 0&#125;,&#123;x: 400,y: 400&#125;],color: &quot;#a594c0&quot;&#125;,</div><div class="line">	&#123;position: [&#123;x: 600,y: 600&#125;,&#123;x: 800,y: 600&#125;,&#123;x: 800,y: 400&#125;,&#123;x: 600,y: 600&#125;],color: &quot;#fa8ecc&quot;&#125;,</div><div class="line">	&#123;position: [&#123;x: 600,y: 600&#125;,&#123;x: 800,y: 600&#125;,&#123;x: 800,y: 800&#125;,&#123;x: 600,y: 600&#125;],color: &quot;#caff67&quot;&#125;</div><div class="line">];</div><div class="line">console.log(arr[0].color)</div><div class="line">for( var i = 0; i &lt; arr.length; i++) &#123;</div><div class="line">	context.beginPath();</div><div class="line">	context.moveTo(arr[i].position[0].x,arr[i].position[0].y);</div><div class="line">	for( var j = 1; j &lt; arr[i].position.length; j++) &#123;</div><div class="line">		context.lineTo(arr[i].position[j].x,arr[i].position[j].y);</div><div class="line">	&#125;</div><div class="line">	context.closePath();</div><div class="line">	context.lineWidth = &quot;2&quot;;</div><div class="line">	context.stroke();</div><div class="line">	context.fillStyle = arr[i].color;</div><div class="line">	context.fill();</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>代码为以上，欢迎批评指正。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;中午登上慕课网，偶然发现慕课网改版了，这倒是其次，惊奇的是页面居然出现了不显示我的观看记录和观看百分比的BUG！还准备说要给慕课网反馈一下来着，晚上一登，居然修复了，不得不佩服慕课网工程师们惊人的处突能力啊。&lt;/p&gt;
&lt;p&gt;回到正题，相信大家都见到过七巧板，本文使用简单的H
    
    </summary>
    
      <category term="Canvas学习笔记" scheme="https://github.com/ChangerHe/categories/Canvas%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="Canvas学习笔记" scheme="https://github.com/ChangerHe/tags/Canvas%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>浅谈框架模式的MVC/MVP/MVVM</title>
    <link href="https://github.com/ChangerHe/2017/07/25/%E6%B5%85%E8%B0%88%E6%A1%86%E6%9E%B6%E6%A8%A1%E5%BC%8F%E7%9A%84MVC-MVP-MVVM/"/>
    <id>https://github.com/ChangerHe/2017/07/25/浅谈框架模式的MVC-MVP-MVVM/</id>
    <published>2017-07-25T02:24:22.000Z</published>
    <updated>2017-07-25T02:45:14.136Z</updated>
    
    <content type="html"><![CDATA[<p>框架模式不是一门写代码的学问，而是一门管理与组织代码的学问。其本质是一种软件开发的模型。与设计模式不同，设计模式是在解决一类问题时总结抽象出的公共方法，如（工厂模式、单例模式。。等等），他们与某种具体的技术栈无关。一种框架模式往往使用了多种设计模式。<br>下面来说一下框架设计的诞生原因及演化。</p>
<h1 id="第一代：脚本式设计（无架构设计）"><a href="#第一代：脚本式设计（无架构设计）" class="headerlink" title="第一代：脚本式设计（无架构设计）"></a>第一代：脚本式设计（无架构设计）</h1><p>下面这样的代码，就是没有任何设计模式的产物：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">const a = document.createElement(&quot;a&quot;);</div><div class="line">a.innerHTML = &quot;www.google.com&quot;;</div><div class="line">a.href = &quot;//www.google.com&quot;;</div><div class="line">a.style.position = &quot;absolute&quot;;</div><div class="line">a.style.top = 100;</div><div class="line">a.onclick = function()&#123;</div><div class="line">    console.log(&quot;google&quot;);</div><div class="line">&#125;</div><div class="line"> document.body.appendChild(a);</div></pre></td></tr></table></figure></p>
<p>这种搞法虽有不少缺点，但麻雀虽小五脏俱全，所有功能一应俱全。早些年由于UI程序还处在一个懵懂期， 逻辑不算太复杂，代码量也不会太多。这样的搞法似乎也没有什么问题。 毕竟到达A B两点最短的距离就是直线，上述代码可以说是实现某功能的最短路径。 典型的例子就是 ASM (虽然汇编语言不是用来写UI的)，他们共有的缺点是 :入口单一 功能简单 不可维护。</p>
<p>我们来修改一下上面的逻辑：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line">function doCss(a) &#123;</div><div class="line">    a.style.position = &quot;absolute&quot;;</div><div class="line">    a.style.top = 100;</div><div class="line">&#125;</div><div class="line">function doEvent(a) &#123;</div><div class="line">    a.onclick = function()&#123;</div><div class="line">        alert(&quot;google&quot;);</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line">function doAttribute(a)&#123;</div><div class="line">    a.innerHTML = &quot;www.google.com&quot;;</div><div class="line">    a.href = &quot;//www.google.com&quot;;</div><div class="line">&#125;</div><div class="line">const a = document.createElement(&quot;a&quot;);</div><div class="line">doCss(a);</div><div class="line">doEvent(a);</div><div class="line">doAttribute(a)</div><div class="line">document.body.appendChild(a);</div></pre></td></tr></table></figure></p>
<p>这里我们将一个功能拆分成了3个部分，即 外观 事件 和属性。</p>
<p>函数将他们重新分离成一个个独立的逻辑块，这样一定程度上达到了分离复用的目的，比如你想修改外观，就去doCss函数里去找。。。</p>
<p>就像有钱人追求更多的财富，权贵追求更多权利一样。</p>
<p>人类总在思考同一个问题， 我们能不能做得更好。。</p>
<p>直到有一天。。。</p>
<h1 id="第二代：代码文件分离-CodeBehind"><a href="#第二代：代码文件分离-CodeBehind" class="headerlink" title="第二代：代码文件分离(CodeBehind)"></a>第二代：代码文件分离(CodeBehind)</h1><p>HTML是视图文件，而对应的。csS文件是他的相关逻辑处理文件 事件驱动模式下，框架帮我们完成了基本的事件类型，我们要做的是在事件下完成相关业务逻辑。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">&lt;html&gt;</div><div class="line">&lt;head&gt;</div><div class="line">    &lt;link href=&quot;style.css&quot; rel=&quot;stylesheet&quot; /&gt;</div><div class="line">&lt;/head&gt;</div><div class="line">&lt;body&gt;</div><div class="line">    &lt;script src=&quot;bundle.js&quot; &gt;&lt;/script&gt;</div><div class="line">&lt;/body&gt;</div><div class="line">&lt;/html&gt;</div></pre></td></tr></table></figure></p>
<p>各文件各司其职，编写的时候分离，在运行的时候合并。这样进一步降低了功能之间的耦合度。 视图看起来非常”清爽”，对应的逻辑也被分离成一个个文件， 交由相应的开发人员处理。</p>
<p>如果你涉猎的技术范围很广，你会发现其实这种技术已经出现在诸多成熟的技术栈中。。。。</p>
<p>但是，没过多久伊甸园欢乐的笑声被下面这个需求打破。。。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">`购买苹果按钮`绑定事件如下:</div><div class="line">1.int 苹果数变量 + 1;</div><div class="line">2.显示苹果数控件的值 = 苹果数变量;</div><div class="line"> </div><div class="line">`购买梨按钮`绑定事件如下:</div><div class="line">1.int 梨数变量 + 1;</div><div class="line">2.显示梨数控件的值 = 梨数变量;</div><div class="line"> </div><div class="line">...`吃苹果`</div><div class="line"> </div><div class="line">...`吃梨`</div></pre></td></tr></table></figure></p>
<p>这里比较困难的是 第2步</p>
<p>就是如果显示苹果数的控件是另一个程序员开发的黑盒， 如何修改其值?</p>
<p>于是程序员A 去找 程序员B 寻求是否存在对应的 get/set 方法。</p>
<p>程序员B说有， “有” 字还没落地， 开发买梨的程序员C 又踹门进来了，问了同样的问题， 后来才知道 开发吃苹果功能的程序员D正在路上。。。</p>
<p>于是程序员B 不得不把接口的详细信息写到 wiki中， 于是 程序员CDEFGHIJKMLN 都看了wiki 懂了。</p>
<p>完成这件事 程序员B 写wiki 花了 10分钟， 程序员CDEFGHIJKMLN 看wiki每人花 1分钟，一共团队成本 20分钟。</p>
<p>于是 wiki中这个 get/set 接口函数出现在了每一个被绑定的函数里。一共4个button 出现4次</p>
<p>ps: 这个get/set接口本质上就是一个view刷新接口</p>
<p>事情仍在在酝酿:</p>
<p>产品大爷发话了，需求改了！</p>
<p>多了一个求和。</p>
<p>于是伪代码变成了这样:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">`购买苹果按钮`绑定事件如下:</div><div class="line">1.int 苹果数变量 + 1;</div><div class="line">2.int 总和变量 = 苹果数变量 + 梨数变量;</div><div class="line">2.显示苹果数控件的值 = 苹果数变量;</div><div class="line">3.显示总和控件的值 = 总和变量;</div></pre></td></tr></table></figure></p>
<p>这次 程序员B为了人身安全，提前把 get/set 接口发布到了 wiki上。。</p>
<p>于是 总和控件的值 = 总和变量 这行代码出现了 4次。</p>
<p>产品存在的意义，就是将程序狗虐到极致:qq</p>
<p>于是需求改成了这样:</p>
<p>q2</p>
<p>只是删了一行。</p>
<p>于是 4个函数中 所有相关代码都被删除。。。 共影响 4行代码。。</p>
<p>段子讲完了，其核心问题在于，按照事件进行的业务模块划分，有时候是不合理的，事件是用户行为的入口，但不是程序逻辑的入口。 一个button的click就可能横跨N个领域， 需要N个人来进行协作， 这部分逻辑到最后还是会耦合在一起，通过各种函数封装进行解耦，无疑是扬汤止沸，而我们需要的是釜底抽薪</p>
<h1 id="M-V-C-模型，视图，控制器"><a href="#M-V-C-模型，视图，控制器" class="headerlink" title="M-V-C:(模型，视图，控制器)"></a>M-V-C:(模型，视图，控制器)</h1><p>现在网上有很多关于mvc的介绍，让人纠结的是他们各不相同，而且有的根本就说的不对， 对于框架模式这东西，没有一个严格的规定说这样搞是 mvc 那样就不是。 甚至连mvc本身也有很多变种，我们只要从根源上理解这个东西就行。</p>
<p>我就不扒祖坟了，咱们只需要知道它已经存在了 30多年就行了。</p>
<p>我们思考一下 UI(图形化用户界面) 的本质:</p>
<p>为什么要有UI， 在计算机眼中 一切即数据，其实要是深挖这个问题，数据与操作其实都是 0 1 组成的机器码，只不过 CPU运行的时候用指定寄存器的数据当做指令罢了，也就是说 决定一个数据到底是数据还是指令 只取决于他所在的寄存器位置。(好了好了 扯远了，往回跑。。) 数据的操作是抽象的，是专业人士干的事情， 计算机为了走进千家万户， 必须提供一种傻瓜式的操作方式，于是UI诞生了。。。 用一句话解释UI就是:他是数据到图像的一种映射程序;</p>
<p>刚才说了它是一种映射程序，用户通过操作图像上的按钮，来达到操作数据的目的，数据被用户改变后，肯定需要从新生成映射。</p>
<h2 id="Model-View-Controller-是干什么的"><a href="#Model-View-Controller-是干什么的" class="headerlink" title="Model View Controller 是干什么的:"></a>Model View Controller 是干什么的:</h2><p>1.View: 放置视图相关的代码，原则上里面不应该有任何业务逻辑。</p>
<p>2.Controller: 放置视图与模型之间的映射，原则上这里应该很薄，他只放一些事件绑定相关的代码(router)，但并不实现真正的功能，他只是一个桥梁。</p>
<p>3.Model: 这里的model不是说 实体类， 他是主要实现逻辑的地方。</p>
<p>那还是上面 买水果的例子，那么在MVC下该如何设计呢:</p>
<table>
<thead>
<tr>
<th style="text-align:center">概念</th>
<th style="text-align:center">解释</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">view层</td>
<td style="text-align:center">放置界面代码，以及一些刷新逻辑 如数据中的 0 1 转成 男 女</td>
</tr>
<tr>
<td style="text-align:center">controller层</td>
<td style="text-align:center">放置一些绑定逻辑。完成router，不实现函数体。</td>
</tr>
<tr>
<td style="text-align:center">model层</td>
<td style="text-align:center">接收view的注册，当自身数据变化时，执行view的刷新函数。 业务逻辑都在这里</td>
</tr>
</tbody>
</table>
<p>他是这样一个流程:</p>
<p>1.创建显示苹果数量的控件。</p>
<p>2.将上面控件注册到model中。(设置关联的数据，–苹果数变量)</p>
<p>3.修改model中 苹果数变量 。</p>
<p>4.由于苹果数变量被修改，触发所有绑定在上面的控件(view)从新执行刷新函数。</p>
<p>5.显示苹果数量的控件被更新。</p>
<p>这样便解决了大部分界面与逻辑耦合的问题，但是它并不完美:</p>
<p>View 和 Model 并不是完全脱离的，还是有一些逻辑耦合，因为需要根据修改后的model从新刷新view。 难免view里面沾染一点model的结构。</p>
<p>代码量膨胀。</p>
<p>不方便进行更精细的颗粒化控制。(因为view只知道 model被改了，但不知道谁改的!)</p>
<p>model在对应多个view的时候，很难都伺候到位。<br>于是。。。</p>
<h1 id="M-V-P-模型，视图，派发器"><a href="#M-V-P-模型，视图，派发器" class="headerlink" title="M-V-P:(模型，视图，派发器)"></a>M-V-P:(模型，视图，派发器)</h1><p>针对mvc的一些问题，在mvp模式下， 斩断了 view 与 model的关系， 当m 改变时，m 通知 p 去改变v， 所以v变得更纯洁(刷新逻辑被移动到了p层)， 为了保证m可以最大程度的复用 一部分业务逻辑也从 m 转移到了p所以 mvp下 p 非常厚实。</p>
<p>mvp中最后改变v的是p那么在 v与p 之间会有一个接口，解决怎么转换以及传值的问题。</p>
<h1 id="M-V-VM-模型，视图，抽象视图"><a href="#M-V-VM-模型，视图，抽象视图" class="headerlink" title="M-V-VM:(模型，视图，抽象视图)"></a>M-V-VM:(模型，视图，抽象视图)</h1><p>mvvm 与 mvp 的最大区别就是它使用 数据绑定(Data Binding)、依赖属性(Dependency Property)、命令(Command)、路由事件(Routed Event) 来搞定与view层的交互， 但是这种绑定是与某种具体技术栈相关的， ViewModel从Model中抽象而来，但更贴近于业务模型， 比如你Model中某字段是 true false， ViewModel中可能就是 “黑”，”白”等 这种更贴近业务场景的描述。 ViewModel中的属性直接与某具体控件的属性相绑定。 也就是说当某具体控件发生变化，ViewModel中的 某个字段就会跟着变化，然后Model中的字段也会进一步变化。</p>
<p>(以上文章摘自网络)</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;框架模式不是一门写代码的学问，而是一门管理与组织代码的学问。其本质是一种软件开发的模型。与设计模式不同，设计模式是在解决一类问题时总结抽象出的公共方法，如（工厂模式、单例模式。。等等），他们与某种具体的技术栈无关。一种框架模式往往使用了多种设计模式。&lt;br&gt;下面来说一下框架
    
    </summary>
    
      <category term="JavaScript框架模式" scheme="https://github.com/ChangerHe/categories/JavaScript%E6%A1%86%E6%9E%B6%E6%A8%A1%E5%BC%8F/"/>
    
    
      <category term="JavaScript框架模式" scheme="https://github.com/ChangerHe/tags/JavaScript%E6%A1%86%E6%9E%B6%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>CSS样式书写规范</title>
    <link href="https://github.com/ChangerHe/2017/07/19/CSS%E6%A0%B7%E5%BC%8F%E4%B9%A6%E5%86%99%E8%A7%84%E8%8C%83/"/>
    <id>https://github.com/ChangerHe/2017/07/19/CSS样式书写规范/</id>
    <published>2017-07-19T13:16:09.000Z</published>
    <updated>2017-07-19T13:40:49.913Z</updated>
    
    <content type="html"><![CDATA[<p>(以下文章转载自伯乐在线,仅供以后方便查阅使用)<br>可能不同团队都有各自的规范，又或者很多人在写 CSS 的时候还是想到什么就写什么，不存在太多的约束。</p>
<p>我觉得 CSS 代码规范还是有存在的必要的，尤其是在团队配合，多人协作下，规范就显得尤为重要。</p>
<p>本文的所列是实践当中得出的一套比较不错的 CSS 书写规范，并不希望大家完全采用，而是希望可以结合自己的团队需要，发展出一套适合自己的 CSS 代码规范。</p>
<p>不同的规范都有各自的长处与缺陷，对待所谓的规范最好的方式不是人云亦云，拿来就用，而是应该结合实际情况及需求，取长补短，取其精华去其糟粕。</p>
<h1 id="编码设置"><a href="#编码设置" class="headerlink" title="编码设置"></a>编码设置</h1><p>采用 UTF-8 编码，在 CSS 代码头部使用：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">@charset &quot;utf-8&quot;;</div></pre></td></tr></table></figure>
<p>注意，必须要定义在 CSS 文件所有字符的前面（包括编码注释），@charset 才会生效。</p>
<p>例如，下面的例子都会使得 @charset 失效：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">/* 字符编码 */</div><div class="line">@charset &quot;utf-8&quot;;</div><div class="line">html,</div><div class="line">body &#123;</div><div class="line">  height: 100%;</div><div class="line">&#125;</div><div class="line"> </div><div class="line">@charset &quot;utf-8&quot;;</div></pre></td></tr></table></figure>
<h1 id="命名空间规范"><a href="#命名空间规范" class="headerlink" title="命名空间规范"></a>命名空间规范</h1><ul>
<li>布局：以 g 为命名空间，例如：.g-wrap 、.g-header、.g-content。<br>状态：以 s 为命名空间，表示动态的、具有交互性质的状态，例如：.s-current、s-selected。</li>
<li>工具：以 u 为命名空间，表示不耦合业务逻辑的、可复用的的工具，例如：u-clearfix、u-ellipsis。</li>
<li>组件：以 m 为命名空间，表示可复用、移植的组件模块，例如：m-slider、m-dropMenu。</li>
<li>钩子：以 j 为命名空间，表示特定给 JavaScript 调用的类名，例如：j-request、j-open。</li>
</ul>
<h1 id="命名空间思想"><a href="#命名空间思想" class="headerlink" title="命名空间思想"></a>命名空间思想</h1><p>没有选择 BEM 这种命名过于严苛及样式名过长过丑的规则，采取了一种比较折中的方案。</p>
<p>不建议使用下划线 _ 进行连接</p>
<ul>
<li>节省操作，输入的时候少按一个 shift 键</li>
<li>能良好区分 JavaScript 变量命名</li>
</ul>
<h1 id="字符小写"><a href="#字符小写" class="headerlink" title="字符小写"></a>字符小写</h1><p>定义的选择器名，属性及属性值的书写皆为小写。</p>
<h1 id="选择器"><a href="#选择器" class="headerlink" title="选择器"></a>选择器</h1><p>当一个规则包含多个选择器时，每个选择器独占一行。</p>
<blockquote>
<p>、+、~、&gt; 选择器的两边各保留一个空格。</p>
<p>.g-header &gt; .g-header-des,<br>.g-content ~ .g-footer {</p>
<p>}</p>
</blockquote>
<p>命名短且语义化良好</p>
<p>对于选择器的命名，尽量简洁且具有语义化，不应该出现 g-abc 这种语义模糊的命名。</p>
<h1 id="规则声明块"><a href="#规则声明块" class="headerlink" title="规则声明块"></a>规则声明块</h1><ul>
<li>当规则声明块中有多个样式声明时，每条样式独占一行。</li>
<li>在规则声明块的左大括号 { 前加一个空格。</li>
<li>在样式属性的冒号 : 后面加上一个空格，前面不加空格。</li>
<li>在每条样式后面都以分号 ; 结尾。</li>
<li>规则声明块的右大括号 } 独占一行。</li>
<li>每个规则声明间用空行分隔。</li>
<li>所有最外层引号使用单引号 ‘ 。</li>
<li>当一个属性有多个属性值时，以逗号 , 分隔属性值，每个逗号后添加一个空格，当单个属性值过长时，每个属性值独占一行。</li>
</ul>
<p>完整示例如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">.g-footer,</div><div class="line">.g-header &#123;</div><div class="line">  position: relative;</div><div class="line">&#125;</div><div class="line"> </div><div class="line">.g-content &#123;</div><div class="line">  background:</div><div class="line">    linear-gradient(135deg, deeppink 25%, transparent 25%) -50px 0,</div><div class="line">    linear-gradient(225deg, deeppink 25%, transparent 25%) -50px 0,</div><div class="line">    linear-gradient(315deg, deeppink 25%, transparent 25%),</div><div class="line">    linear-gradient(45deg, deeppink 25%, transparent 25%);</div><div class="line">  &#125;</div><div class="line"> </div><div class="line">.g-content::before &#123;</div><div class="line">  content: &apos;&apos;;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h1 id="数值与单位"><a href="#数值与单位" class="headerlink" title="数值与单位"></a>数值与单位</h1><ul>
<li>当属性值或颜色参数为 0 – 1 之间的数时，省略小数点前的 0 。color: rgba(255, 255, 255, 0.5)color: rgba(255, 255, 255, .5);</li>
<li>当长度值为 0 时省略单位。margin: 0px automargin: 0 auto</li>
<li>十六进制的颜色属性值使用小写和尽量简写。color: #ffcc00color: #fc0</li>
</ul>
<h1 id="样式属性顺序"><a href="#样式属性顺序" class="headerlink" title="样式属性顺序"></a>样式属性顺序</h1><p>单个样式规则下的属性在书写时，应按功能进行分组，并以 Positioning Model &gt; Box Model &gt; Typographic &gt; Visual 的顺序书写，提高代码的可读性。</p>
<ul>
<li>如果包含 content 属性，应放在最前面；<br>Positioning Model 布局方式、位置，相关属性包括：position / top / right / bottom / left / z-index / display / float / …</li>
<li>Box Model 盒模型，相关属性包括：width / height / padding / margin / border / overflow / …</li>
<li>Typographic 文本排版，相关属性包括：font / line-height / text-align / word-wrap / …</li>
<li>Visual 视觉外观，相关属性包括：color / background / list-style / transform / animation / transition / …</li>
</ul>
<p>Positioning 处在第一位，因为他可以使一个元素脱离正常文本流，并且覆盖盒模型相关的样式。盒模型紧跟其后，因为他决定了一个组件的大小和位置。其他属性只在组件内部起作用或者不会对前面两种情况的结果产生影响，所以他们排在后面。</p>
<h1 id="合理使用使用引号"><a href="#合理使用使用引号" class="headerlink" title="合理使用使用引号"></a>合理使用使用引号</h1><p>在某些样式中，会出现一些含有空格的关键字或者中文关键字。</p>
<p>font-family 内使用引号</p>
<p>当字体名字中间有空格，中文名字体及 Unicode 字符编码表示的中文字体，为了保证兼容性，都建议在字体两端添加单引号或者双引号：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">body &#123;</div><div class="line">  font-family: &apos;Microsoft YaHei&apos;, &apos;黑体-简&apos;, &apos;\5b8b\4f53&apos;;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>background-image 的 url 内使用引号</p>
<p>如果路径里面有空格，旧版 IE 是无法识别的，会导致路径失效，建议不管是否存在空格，都添加上单引号或者双引号：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">div &#123;</div><div class="line">  background-image: url(&apos;...&apos;);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h1 id="避免使用-important"><a href="#避免使用-important" class="headerlink" title="避免使用 !important"></a>避免使用 !important</h1><p>除去某些极特殊的情况，尽量不要不要使用 !important。</p>
<p>!important 的存在会给后期维护以及多人协作带来噩梦般的影响。</p>
<p>当存在样式覆盖层叠时，如果你发现新定义的一个样式无法覆盖一个旧的样式，只有加上 !important 才能生效时，是因为你新定义的选择器的优先级不够旧样式选择器的优先级高。所以，合理的书写新样式选择器，是完全可以规避一些看似需要使用 !important 的情况的。</p>
<h1 id="代码注释"><a href="#代码注释" class="headerlink" title="代码注释"></a>代码注释</h1><h2 id="单行注释"><a href="#单行注释" class="headerlink" title="单行注释"></a>单行注释</h2><p>星号与内容之间必须保留一个空格。</p>
<h2 id="多行注释"><a href="#多行注释" class="headerlink" title="多行注释"></a>多行注释</h2><p>星号要一列对齐，星号与内容之间必须保留一个空格。</p>
<h2 id="规则声明块内注释"><a href="#规则声明块内注释" class="headerlink" title="规则声明块内注释"></a>规则声明块内注释</h2><p>使用 // 注释，// 后面加上一个空格，注释独立一行。</p>
<h2 id="文件注释"><a href="#文件注释" class="headerlink" title="文件注释"></a>文件注释</h2><p>文件顶部必须包含文件注释，用 @name 标识文件说明。星号要一列对齐，星号与内容之间必须保留一个空格，标识符冒号与内容之间必须保留一个空格。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">/**</div><div class="line">* @name: 文件名或模块名</div><div class="line">* @description: 文件或模块描述</div><div class="line">* @author: author-name(mail-name@domain.com)</div><div class="line">*          author-name2(mail-name2@domain.com)</div><div class="line">* @update: 2015-04-29 00:02</div><div class="line">*/</div><div class="line">//@description为文件或模块描述。</div><div class="line">//@update为可选项，建议每次改动都更新一下。</div></pre></td></tr></table></figure>
<p>当该业务项目主要由固定的一个或多个人负责时，需要添加@author标识，一方面是尊重劳动成果，另一方面方便在需要时快速定位责任人。</p>
<h1 id="SASS-使用建议"><a href="#SASS-使用建议" class="headerlink" title="SASS 使用建议"></a>SASS 使用建议</h1><h2 id="嵌套层级规定"><a href="#嵌套层级规定" class="headerlink" title="嵌套层级规定"></a>嵌套层级规定</h2><p>使用 SASS 、 LESS 等预处理器时，建议嵌套层级不超过 3 层。</p>
<h2 id="组件-公用类的使用方法"><a href="#组件-公用类的使用方法" class="headerlink" title="组件/公用类的使用方法"></a>组件/公用类的使用方法</h2><p>组件/公用类使用 %placeholders 定义，使用 @extend 引用。如：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">%clearfix &#123;</div><div class="line"> </div><div class="line">  overflow: auto;</div><div class="line">  zoom: 1;</div><div class="line">&#125;</div><div class="line"> </div><div class="line">.g-header &#123;</div><div class="line">  @extend %clearfix;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="组件类的思考"><a href="#组件类的思考" class="headerlink" title="组件类的思考"></a>组件类的思考</h2><p>使用 SASS ，经常会预先定义好一些常用公用组件类，譬如清除浮动，水平垂直居中，文字 ellipsis。又或者多个元素具有同样的样式，我们希望能够少写这部分代码，公共部分抽离出来只写一次，达到复用。</p>
<p>但是复用的方式在 SASS 中有多种，那么是使用单独使用一个类定义，给需要的标签添加，还是使用 @include 或者 @extend在定义的类中引入一个 @mixin，或者一个 @function 呢？</p>
<p>基于让 CSS 更简洁以及代码的复用考虑，采用上面的使用 %placeholders 定义，使用 @extend 引用的方案。</p>
<ul>
<li>%placeholders，只是一个占位符，只要不通过 @extend 调用，编译后不会产生任何代码量</li>
<li>使用 @extend 引用，则是因为每次调用相同的 %placeholders 时，编译出来相同的 CSS 样式会进行合并（反之，如果使用 @include 调用定义好的 @mixin，编译出来相同的 CSS 样式不会进行合并）</li>
<li>这里的组件类特指那些不会动态改变的 CSS 样式，注意与那些可以通过传参生成不同数值样式的 @mixin 方法进行区分</li>
</ul>
<h2 id="尽量避免使用标签名"><a href="#尽量避免使用标签名" class="headerlink" title="尽量避免使用标签名"></a>尽量避免使用标签名</h2><p>使用 SASS ，或者说在 CSS 里也有这种困惑。</p>
<p>假设我们有如下 html 结构：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">&lt;span&gt;</div><div class="line">  &lt;div class=&quot;g-content&quot;&gt;</div><div class="line">    &lt;ul class=&quot;g-content-list&quot;&gt;&lt;li class=&quot;item&quot;/&gt;</div><div class="line">        &lt;li class=&quot;item&quot;/&gt;</div><div class="line">        &lt;li class=&quot;item&quot;/&gt;</div><div class="line">        &lt;li class=&quot;item&quot;/&gt;</div><div class="line">    &lt;/ul&gt;&lt;/div&gt;</div><div class="line">&lt;/span&gt;</div></pre></td></tr></table></figure>
<p>在给最里层的标签命名书写样式的时候，我们有两种选择：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">.g-content &#123;</div><div class="line">  .g-content-list &#123;</div><div class="line">    li &#123;</div><div class="line">      ...</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>或者是</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">.g-content &#123;</div><div class="line">  .g-content-list &#123;</div><div class="line">    .item &#123;</div><div class="line">      ...</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>也就是，编译之后生成了下面这两个，到底使用哪个好呢？</p>
<ul>
<li>.g-content .g-content-list li { }</li>
<li>.g-content .g-content-list .item { }</li>
</ul>
<p>基于 CSS 选择器的解析规则（从右向左），建议使用上述第二种 .g-content .g-content-list .item { } ，避免使用通用标签名作为选择器的一环可以提高 CSS 匹配性能。</p>
<p>浏览器的排版引擎解析 CSS 是基于从右向左（right-to-left）的规则，这么做是为了使样式规则能够更快地与渲染树上的节点匹配。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;(以下文章转载自伯乐在线,仅供以后方便查阅使用)&lt;br&gt;可能不同团队都有各自的规范，又或者很多人在写 CSS 的时候还是想到什么就写什么，不存在太多的约束。&lt;/p&gt;
&lt;p&gt;我觉得 CSS 代码规范还是有存在的必要的，尤其是在团队配合，多人协作下，规范就显得尤为重要。&lt;/p&gt;
    
    </summary>
    
      <category term="HTML &amp; CSS 学习笔记" scheme="https://github.com/ChangerHe/categories/HTML-CSS-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="CSS样式书写规范" scheme="https://github.com/ChangerHe/tags/CSS%E6%A0%B7%E5%BC%8F%E4%B9%A6%E5%86%99%E8%A7%84%E8%8C%83/"/>
    
  </entry>
  
  <entry>
    <title>JavaScript计时器的优化</title>
    <link href="https://github.com/ChangerHe/2017/07/19/JavaScript%E8%AE%A1%E6%97%B6%E5%99%A8%E7%9A%84%E4%BC%98%E5%8C%96/"/>
    <id>https://github.com/ChangerHe/2017/07/19/JavaScript计时器的优化/</id>
    <published>2017-07-19T01:51:42.000Z</published>
    <updated>2017-07-19T02:14:31.578Z</updated>
    
    <content type="html"><![CDATA[<p>首先，要对我的脑子进行严格而深刻的批判，写个简单的计时器，花了一个小时的时间才写完。</p>
<blockquote>
<p>“脑子是个好东西，我希望我自己也能有一个。”   ——某位将要成为前端大佬的菜鸟如是说</p>
</blockquote>
<p>情况分析：在HTML文件中写入相应的代码，实现计时效果，因此需要用到定时器，代码如下，我是将代码直接写在timer中了：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line">setInterval(function timtSetter()&#123;</div><div class="line">	s++;</div><div class="line">	var S,m,M,h,H;</div><div class="line">	S = s % 60;</div><div class="line">	m = Math.floor(s/60);</div><div class="line">	M = m % 60;</div><div class="line">	h = Math.floor(m/60);</div><div class="line">	H = h % 24;</div><div class="line">	if( S &lt; 10)&#123;</div><div class="line">		S = &quot;0&quot; + S;</div><div class="line">	&#125;</div><div class="line">	if( M &lt; 10)&#123;</div><div class="line">		M = &quot;0&quot; + M;</div><div class="line">	&#125;</div><div class="line">	if( H &lt; 10)&#123;</div><div class="line">		H = &quot;0&quot; + H;</div><div class="line">	&#125;</div><div class="line">	timer.innerHTML = H + &quot;:&quot; + M + &quot;:&quot; + S;</div><div class="line">&#125;,1000);</div></pre></td></tr></table></figure></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;首先，要对我的脑子进行严格而深刻的批判，写个简单的计时器，花了一个小时的时间才写完。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;“脑子是个好东西，我希望我自己也能有一个。”   ——某位将要成为前端大佬的菜鸟如是说&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;情况分析：在HTM
    
    </summary>
    
      <category term="JavaScript 学习笔记" scheme="https://github.com/ChangerHe/categories/JavaScript-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="JavaScript" scheme="https://github.com/ChangerHe/tags/JavaScript/"/>
    
  </entry>
  
  <entry>
    <title>JavaScript笔试面试题收集（一）</title>
    <link href="https://github.com/ChangerHe/2017/07/17/JavaScript%E7%AC%94%E8%AF%95%E9%9D%A2%E8%AF%95%E9%A2%98%E6%94%B6%E9%9B%86%EF%BC%88%E4%B8%80%EF%BC%89/"/>
    <id>https://github.com/ChangerHe/2017/07/17/JavaScript笔试面试题收集（一）/</id>
    <published>2017-07-17T13:34:18.000Z</published>
    <updated>2017-07-17T13:39:06.050Z</updated>
    
    <content type="html"><![CDATA[<p>出题的大师兄，草粉吗？<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div></pre></td><td class="code"><pre><div class="line">function Foo() &#123;</div><div class="line">	getName = function () &#123;</div><div class="line">		console.log(1);</div><div class="line">	&#125;;</div><div class="line">	return this;</div><div class="line">&#125;</div><div class="line">Foo.getName = function () &#123;</div><div class="line">	console.log(2);</div><div class="line">&#125;;</div><div class="line">Foo.prototype.getName = function () &#123;</div><div class="line">	console.log(3);</div><div class="line">&#125;;</div><div class="line">var getName = function () &#123;</div><div class="line">	console.log(4);</div><div class="line">&#125;;</div><div class="line">function getName() &#123;</div><div class="line">	console.log(5);</div><div class="line">&#125;;</div><div class="line"></div><div class="line">// 请写出以下输出结果：</div><div class="line">Foo.getName();</div><div class="line">getName();</div><div class="line">Foo().getName();</div><div class="line">getName();</div><div class="line">new Foo.getName();</div><div class="line">new Foo().getName();</div><div class="line">new new Foo().getName();</div></pre></td></tr></table></figure></p>
<p>题目只答对一半的宝宝表示很想哭啊。<br>以下是解题思路：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div></pre></td><td class="code"><pre><div class="line">Foo.getName();              // 2</div><div class="line">getName();                     // 4</div><div class="line">Foo().getName();           // 1</div><div class="line">getName();                     // 1</div><div class="line"></div><div class="line">new Foo.getName();          // 2</div><div class="line">// var a = new Foo.getName();  </div><div class="line">// var a = &#123;&#125;;</div><div class="line">// a.__proto = Foo.getName.prototype;</div><div class="line">// Foo.getName.call(a);</div><div class="line"></div><div class="line">new Foo().getName();        // 3</div><div class="line">// var b = new Foo().getName();</div><div class="line">// var b = &#123;&#125;;</div><div class="line">// b.__proto__ = Foo.prototype;</div><div class="line">// Foo.call(b);</div><div class="line">// b.getName();</div><div class="line"></div><div class="line">new new Foo().getName();    // 3</div><div class="line">// var c = new Foo().getName();</div><div class="line">// var c = &#123;&#125;;</div><div class="line">// c.__proto__ = Foo.prototype;</div><div class="line">// Foo.call(c);</div><div class="line">// var d = new c.getName();</div><div class="line">// var d = &#123;&#125;;</div><div class="line">// d.__proto__ = c.getName.prototype;</div><div class="line">// c.getName.call(d);</div></pre></td></tr></table></figure></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;出题的大师兄，草粉吗？&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;2&lt;/div&gt;&lt;div 
    
    </summary>
    
      <category term="JavaScript笔试面试题" scheme="https://github.com/ChangerHe/categories/JavaScript%E7%AC%94%E8%AF%95%E9%9D%A2%E8%AF%95%E9%A2%98/"/>
    
    
      <category term="JavaScript笔试面试题" scheme="https://github.com/ChangerHe/tags/JavaScript%E7%AC%94%E8%AF%95%E9%9D%A2%E8%AF%95%E9%A2%98/"/>
    
  </entry>
  
  <entry>
    <title>基本算法的JavaScript实现</title>
    <link href="https://github.com/ChangerHe/2017/07/16/%E5%9F%BA%E6%9C%AC%E7%AE%97%E6%B3%95%E7%9A%84JavaScript%E5%AE%9E%E7%8E%B0/"/>
    <id>https://github.com/ChangerHe/2017/07/16/基本算法的JavaScript实现/</id>
    <published>2017-07-16T13:47:22.000Z</published>
    <updated>2017-07-16T14:15:44.449Z</updated>
    
    <content type="html"><![CDATA[<p>也算是一时兴起，对着手机拾掇了一早上，实现了一些简单的排序算法。</p>
<h1 id="冒泡排序"><a href="#冒泡排序" class="headerlink" title="冒泡排序"></a>冒泡排序</h1><p>这个不必多说，最经典的排序算法之一，下面我也是用的最经典的解决方案，同时对算法进行了优化，减少了不必要的比较次数。<br>冒泡排序在嵌套循环都为数组长度的话，这个时候的循环最多次数是N的平方，但是用以下的算法，比较的次数可以减少一半。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">function bubbleSort(arr)&#123;   </div><div class="line">	console.time(&apos;冒泡排序耗时&apos;)</div><div class="line">	var len = arr.length;  //定义冒泡排序的数组长度</div><div class="line">	var n;           //定义n用于在冒泡排序时进行位置调换</div><div class="line">	for (var i = 0; i &lt; len-1; i++) &#123;  //外层循环，使冒泡排序循环数组长度</div><div class="line">		for (var j = 0; j &lt; len-i-1; j++) &#123;</div><div class="line">			if (arr[j] &gt; arr[j+1]) &#123;</div><div class="line">				n = arr[j];</div><div class="line">				arr[j] = arr[j+1];</div><div class="line">				arr[j+1] = n;</div><div class="line">			&#125; </div><div class="line"></div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line">	console.timeEnd(&apos;冒泡排序耗时&apos;)</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>冒泡排序的经典算法经过我自己思考优化后，其实还存在一个多次比较的问题，在网上查了些资料，大佬们给出了另一种算法，主要的优化点在于，记录上要调换的位置，然后从要调换的位置开始进行调换，调换之后，再对剩余的地方进行调换。无疑减少了在一个不需要调换的位置进行多次比较的次数。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line">function betterBubbleSort(arr)&#123;</div><div class="line">	console.time(&apos;改进后冒泡排序耗时&apos;)</div><div class="line">	var i = arr.length-1;  //定义i为数组的最后一位数</div><div class="line">	var n;      //n作为中间值，用于进行数组调换</div><div class="line">	while(i &gt; 0)&#123;     </div><div class="line">		var pos = 0;   //记录需要调换的位置</div><div class="line">		for(var j = 0; j &lt; i; j++)&#123;   //</div><div class="line">			if (arr[j] &gt; arr[j+1]) &#123;</div><div class="line">				pos = j;</div><div class="line">				n = arr[j];</div><div class="line">				arr[j] = arr[j+1];</div><div class="line">				arr[j+1] = n;</div><div class="line">			&#125; </div><div class="line">		&#125;</div><div class="line">		i = pos;</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	console.timeEnd(&apos;改进后冒泡排序耗时&apos;)</div><div class="line">	return arr;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>以上算法对于计算次数已经有了较多的优化了，计算次数显然已经不能再往下优化，但是还有一点就是，我们能否进行多线程的计算，从而缩短整体的计算时间呢？<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div></pre></td><td class="code"><pre><div class="line">function bestBubbleSort(arr)&#123;</div><div class="line">	console.time(&apos;改进后冒泡排序耗时&apos;)</div><div class="line">	var low = 0;</div><div class="line">	var high = arr.length -1;</div><div class="line">	var tmp,j;</div><div class="line">	while(low &lt; high)&#123;</div><div class="line">		for(j = low; j &lt; high; ++j)&#123;</div><div class="line">			if( arr[j] &gt; arr[j+1])&#123;</div><div class="line">				tmp = arr[j];</div><div class="line">				arr[j] = arr[j+1];</div><div class="line">				arr[j+1] = tmp;</div><div class="line">			&#125;</div><div class="line">		&#125;</div><div class="line">		--high;</div><div class="line">		for(j = high; j &gt; low; --j)&#123;</div><div class="line">			if( arr[j] &lt; arr[j-1])&#123;</div><div class="line">				tmp = arr[j];</div><div class="line">				arr[j] = arr[j-1];</div><div class="line">				arr[j-1] = tmp;</div><div class="line">			&#125;</div><div class="line">		&#125;</div><div class="line">		++low;</div><div class="line">	&#125;</div><div class="line">	console.timeEnd(&apos;改进后冒泡排序耗时&apos;)</div><div class="line">	return arr;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h1 id="选择排序的算法"><a href="#选择排序的算法" class="headerlink" title="选择排序的算法"></a>选择排序的算法</h1><p>选择排序是先在数组中进行查找而不调换位置，找到数组中最小数之后，将最小数放到数组的第一个位置，然后再次寻找第二个数。这样做的好处就是，相比于冒泡排序，大大减少了两个数组元素调换位置所产生的内存消耗和计算量。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line">function selectionSort(arr)&#123;</div><div class="line">	var len = arr.length-1; //定义数组的长度，并赋值给len</div><div class="line">	console.time(&apos;选择排序耗时&apos;);   //设置计时开始</div><div class="line">	var minindex,temp;</div><div class="line">	for (var i = 0; i &lt; len; i++) &#123;</div><div class="line">		minindex = i;    </div><div class="line">		//设置最小数组下标为minindex，将i赋值给minindex</div><div class="line">		for( var j = i; j &lt; len; j++)&#123;</div><div class="line">		//设置循环，循环区间为最小值到最后一位数</div><div class="line">			if (arr[j] &lt; arr[minindex]) &#123;</div><div class="line">			//若某数小于第minindex个数组的值，就把它赋值给minindex</div><div class="line">				minindex = j;</div><div class="line">			&#125;</div><div class="line">		&#125;</div><div class="line">		//进行最小值与需要调换值的数组下标调换</div><div class="line">		temp = arr[i];</div><div class="line">		arr[i] = arr[minindex];</div><div class="line">		arr[minindex] = temp;</div><div class="line">	&#125;</div><div class="line">	console.timeEnd(&apos;选择排序耗时&apos;);</div><div class="line">	return arr;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h1 id="插入排序算法"><a href="#插入排序算法" class="headerlink" title="插入排序算法"></a>插入排序算法</h1><p>插入排序即是将需要排序的数组中的元素，逐次插入，以达到排序的效果，亲测此方法比上面的两个方法所耗时间都要短。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">function insertionSort(arr)&#123;</div><div class="line">	console.time(&apos;插入排序耗时&apos;);   //设置计时开始</div><div class="line">	for( var i = 1; i &lt; arr.length; i++)&#123;</div><div class="line">		var key = arr[i];</div><div class="line">		var j = i - 1;</div><div class="line">		while(j &gt;= 0 &amp;&amp; arr[j] &gt; key)&#123;</div><div class="line">			arr[j+1] = arr[j];</div><div class="line">			j--;</div><div class="line">		&#125;</div><div class="line">		arr[j+1] = key;</div><div class="line">	&#125;</div><div class="line">	console.timeEnd(&apos;插入排序耗时&apos;);   //设置计时开始</div><div class="line">	return arr;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h1 id="排序算法耗时汇总"><a href="#排序算法耗时汇总" class="headerlink" title="排序算法耗时汇总"></a>排序算法耗时汇总</h1><p>冒泡排序三个方法在随机生成10000个数并对其进行排序的计算中，均耗时约300ms，选择排序和插入排序则耗时较短些，选择排序耗时约200ms左右，插入排序可达到低于200ms。</p>
<h1 id="JS内核的自带排序算法"><a href="#JS内核的自带排序算法" class="headerlink" title="JS内核的自带排序算法"></a>JS内核的自带排序算法</h1><p>不多说了，就是这个sort()方法，简直想给它跪舔！同样用10000个随机生成的0-100的数，对其进行排序，其计算时间竟然能缩短到逆天的15ms！但是并没有办法详细了解其深层次的原因，听说是因为V8引擎的优化，和基于C++的算法优化所产生的效果。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;也算是一时兴起，对着手机拾掇了一早上，实现了一些简单的排序算法。&lt;/p&gt;
&lt;h1 id=&quot;冒泡排序&quot;&gt;&lt;a href=&quot;#冒泡排序&quot; class=&quot;headerlink&quot; title=&quot;冒泡排序&quot;&gt;&lt;/a&gt;冒泡排序&lt;/h1&gt;&lt;p&gt;这个不必多说，最经典的排序算法之一，下面我也
    
    </summary>
    
      <category term="JavaScript 学习笔记" scheme="https://github.com/ChangerHe/categories/JavaScript-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="JavaScript" scheme="https://github.com/ChangerHe/tags/JavaScript/"/>
    
  </entry>
  
  <entry>
    <title>深入理解JavaScript构造函数和原型对象</title>
    <link href="https://github.com/ChangerHe/2017/07/16/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3JavaScript%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%E5%92%8C%E5%8E%9F%E5%9E%8B%E5%AF%B9%E8%B1%A1/"/>
    <id>https://github.com/ChangerHe/2017/07/16/深入理解JavaScript构造函数和原型对象/</id>
    <published>2017-07-15T23:25:47.000Z</published>
    <updated>2017-07-15T23:34:29.730Z</updated>
    
    <content type="html"><![CDATA[<h1 id="对象？"><a href="#对象？" class="headerlink" title="对象？"></a>对象？</h1><p>对象，是javascript中非常重要的一个梗，是否能透彻的理解它直接关系到你对整个javascript体系的基础理解，说白了，javascript就是一群对象在搞！！基！！</p>
<h1 id="常用的几种对象创建模式"><a href="#常用的几种对象创建模式" class="headerlink" title="常用的几种对象创建模式"></a>常用的几种对象创建模式</h1><h2 id="使用new关键字创建"><a href="#使用new关键字创建" class="headerlink" title="使用new关键字创建"></a>使用new关键字创建</h2><p>最基础的对象创建方式，无非就是和其他多数语言一样说的一样：所以俗话说得好，当我们程序猿们没对象的时候，我们应该“new”一个对象出来。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">var gf = new Object();</div><div class="line">gf.name = &quot;tangwei&quot;;</div><div class="line">gf.bar = &quot;c++&quot;;</div><div class="line">gf.sayWhat = function() &#123;</div><div class="line">  console.log(this.name + &quot;said:love you forever&quot;);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h2 id="使用字面量创建"><a href="#使用字面量创建" class="headerlink" title="使用字面量创建"></a>使用字面量创建</h2><p>这样似乎妥妥的了，但是宅寂的geek们岂能喜欢如此复杂和low土的定义变量的方式，作为一门脚本语言那应该有和其他兄弟们一样的范儿，于是出现了对象字面量的定义方式：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">var gf = &#123;</div><div class="line">  name : &quot;tangwei&quot;,</div><div class="line">  bar : &quot;c++&quot;,</div><div class="line">  sayWhat : function() &#123;</div><div class="line">    console.log(this.name + &quot;said:love you forever&quot;);</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h1 id="工厂模式"><a href="#工厂模式" class="headerlink" title="工厂模式"></a>工厂模式</h1><p>实际上这是我们在实际中最常用的对象定义方式，但是我要有好多拥有相似属性的对象（想想都让人激动。。。）怎么办呢？那要是一个个的定义，就会产生大量的代码，何不建个工厂，批量的生产出我们的对象呢，于是，javascript世界中第一个充气娃。。。不，“工厂模式”诞生了！<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">function createGf(name, bar) &#123;</div><div class="line">  var o = new Object();</div><div class="line">  o.name = name;</div><div class="line">  o.bar = bar;</div><div class="line">  o.sayWhat = function() &#123;</div><div class="line">    alert(this.name + &quot;said:love you forever&quot;);</div><div class="line">  &#125;</div><div class="line">  return o;</div><div class="line">&#125;</div><div class="line">var gf1 = createGf(&quot;bingbing&quot;,&quot;d&quot;);</div><div class="line">var gf2 = createGf(&quot;mimi&quot;,&quot;a&quot;);</div></pre></td></tr></table></figure></p>
<h1 id="构造函数"><a href="#构造函数" class="headerlink" title="构造函数"></a>构造函数</h1><p>工厂模式解决了多个相似对象的创建问题，但是问题又来了，这些对象都是Object整出来的，怎么区分它们的对象具体类型呢？这时候我们就需要切换到另一种模式了，构造函数模式：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">function Gf(name,bar)&#123;</div><div class="line">  this.name = name;</div><div class="line">  this.bar = bar;</div><div class="line">  this.sayWhat = function()&#123;</div><div class="line">    alert(this.name + &quot;said:love you forever&quot;);</div><div class="line">  &#125;</div><div class="line">&#125;</div><div class="line">var gf1 = new Gf(&quot;vivian&quot;,&quot;f&quot;);</div><div class="line">var gf2 = new Gf(&quot;vivian2&quot;,&quot;f&quot;);</div></pre></td></tr></table></figure></p>
<p>这里我们使用一个大写字母开头的构造函数替代了上例中的createGf，注意按照约定构造函数的首字母要大写。在这里我们创建一个新对象，然后将构造函数的作用域赋给新对象，调用构造函数中的方法。<br>上面的方式似乎没什么不妥，但是我们可以发现，两个实例中调用的构造函数中的sayWhat方法不是同一个Function实例：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">console.log(gf1.sayWhat == gf2.sayWhat); //false</div></pre></td></tr></table></figure></p>
<p>调用同一个方法，却声明了不同的实例，实在浪费资源。我们可以优化一下将sayWhat函数放到构造函数外面声明：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">function Gf(name,bar)&#123;</div><div class="line">  this.name = name;</div><div class="line">  this.bar = bar;</div><div class="line">  this.sayWhat = sayWhat</div><div class="line">&#125;</div><div class="line">function sayWhat()&#123;</div><div class="line">  alert(this.name + &quot;said:love you forever&quot;);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>这样解决了，多个实例多次定义同一个方法实例的问题，但是新问题又来了，我们定义的sayWhat是一个全局作用域的方法，但这个方法其实是没法直接调用的，这就有点矛盾了。如何更优雅的定义一个具备一定封装性的对象呢？我们来看一下javascript原型对象模式。</p>
<h1 id="原型对象模式"><a href="#原型对象模式" class="headerlink" title="原型对象模式"></a>原型对象模式</h1><p>当我们创建一个函数时，该函数就会具备一个prototype属性，这个属性指向通过构造函数创建的那个函数的原型对象。通俗点讲原型对象就是内存中为其他对象提供共享属性和方法的对象。<br><img src="http://files.jb51.net/file_images/article/201409/2014923152050636.png?201482315219" alt=""><br>在原型模式中，不必再构造函数中定义实例属性，可以将属性信息直接赋予原型对象：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">function Gf()&#123;</div><div class="line">  Gf.prototype.name = &quot;vivian&quot;;</div><div class="line">  Gf.prototype.bar = &quot;c++&quot;;</div><div class="line">  Gf.prototype.sayWhat = function()&#123;</div><div class="line">    alert(this.name + &quot;said:love you forever&quot;);</div><div class="line">  &#125;</div><div class="line">&#125;</div><div class="line">var gf1 = new Gf();</div><div class="line">gf1.sayWhat();</div><div class="line">var gf2 = new Gf();</div></pre></td></tr></table></figure></p>
<p>和构造函数不同的是这里新对象的属性和方法是所有实例都可以共享的，换句话说gf1和gf2访问的是同一份属性和方法。原型对象中除了我们赋予的属性外，还有一些内置的属性，所有原型对象都具备一个constructor属性，这个属性是一个指向包含prototype属性函数的一个指针（敢不敢再绕点！）。通过一幅图我们来清楚的理一下这个绕口的流程：<br><img src="http://files.jb51.net/file_images/article/201409/2014923152134756.png?2014823152147" alt=""><br>所有的对象都有一个原型对象（prototype），原型对象中有一个constructor属性指向包含prototype属性的函数，Gf的实例gf1和gf2都包含一个内部属性指向原型对象（在firefox浏览器中表现为私有属性proto），当我们访问一个对象中的属性时，首先会询问实例对象中有没有该属性，如果没有则继续查找原型对象。<br>在前面的示例中，我们注意到在为原型对象添加属性时，需要每个都增加Gf.prototype，这个工作很重复，在上面对象的创建模式中，我们知道可以通过字面量的形式创建一个对象，这里我们也可以改进一下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">function Gf()&#123;&#125;</div><div class="line">Gf.prototype = &#123;</div><div class="line">  name : &quot;vivian&quot;,</div><div class="line">  bar : &quot;c++&quot;,</div><div class="line">  sayWhat : function()&#123;</div><div class="line">    alert(this.name + &quot;said:love you forever&quot;);</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>这里有一个地方需要特别注意，constructor属性不再指向对象Gf，因为每定义一个函数，就会同时为其创建一个prototype对象，这个对象也会自动获取一个新的constructor属性，这个地方我们使用Gf.prototype本质上覆写了原有的prototype对象，因此constructor也变成了新对象的constructor属性，不再指向Gf，而是Object:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">var gf1 = new Gf();</div><div class="line">console.log(gf1.constructor == Gf);//false</div><div class="line">console.log(gf1.constructor == Object)//true</div></pre></td></tr></table></figure></p>
<p>一般情况下，这个微妙的改变是不会对我们造成影响的，但如果你对constructor有特殊的需求，我们也可以显式的指定下Gf.prototype的constructor属性：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">Gf.prototype = &#123;</div><div class="line">  constructor : Gf,</div><div class="line">  name : &quot;vivian&quot;,</div><div class="line">  bar : &quot;c++&quot;,</div><div class="line">  sayWhat : function() &#123;</div><div class="line">    alert(this.name + &quot;said:love you forever&quot;);</div><div class="line">  &#125;</div><div class="line">&#125;</div><div class="line">var gf1 = new Gf();</div><div class="line">console.log(gf1.constructor == Gf);//true</div></pre></td></tr></table></figure></p>
<p>通过对原型对象模式的初步了解，我们发现所有的实例对象都共享相同的属性，这是原型模式的基本特点，但往往对于开发者来说这是把“双刃剑”，在实际开发中，我们希望的实例应该是具备自己的属性，这也是在实际开发中很少有人单独使用原型模式的主要原因。</p>
<h1 id="构造函数和原型组合模式"><a href="#构造函数和原型组合模式" class="headerlink" title="构造函数和原型组合模式"></a>构造函数和原型组合模式</h1><p>在实际开发中，我们可以使用构造函数来定义对象的属性，使用原型来定义共享的属性和方法，这样我们就可以传递不同的参数来创建出不同的对象，同时又拥有了共享的方法和属性。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">function Gf(name,bar)&#123;</div><div class="line">  this.name = name;</div><div class="line">  this.bar = bar;</div><div class="line">&#125;</div><div class="line">Gf.prototype = &#123;</div><div class="line">  constructor : Gf,</div><div class="line">  sayWhat : function() &#123;</div><div class="line">    alert(this.name + &quot;said:love you forever&quot;);</div><div class="line">  &#125;</div><div class="line">&#125;</div><div class="line">var gf1 = new Gf(&quot;vivian&quot;, &quot;f&quot;);</div><div class="line">var gf2 = new Gf(&quot;vivian1&quot;, &quot;c&quot;);</div></pre></td></tr></table></figure></p>
<p>在这个例子中，我们再构造函数中定义了对象各自的属性值，在原型对象中定义了constructor属性和sayWhat函数，这样gf1和gf2属性之间就不会产生影响了。这种模式也是实际开发中最常用的对象定义方式，包括很多js库（bootstrap等）默认的采用的模式。</p>
]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;对象？&quot;&gt;&lt;a href=&quot;#对象？&quot; class=&quot;headerlink&quot; title=&quot;对象？&quot;&gt;&lt;/a&gt;对象？&lt;/h1&gt;&lt;p&gt;对象，是javascript中非常重要的一个梗，是否能透彻的理解它直接关系到你对整个javascript体系的基础理解，说白了，ja
    
    </summary>
    
      <category term="JavaScript 学习笔记" scheme="https://github.com/ChangerHe/categories/JavaScript-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="JavaScript" scheme="https://github.com/ChangerHe/tags/JavaScript/"/>
    
  </entry>
  
  <entry>
    <title>PHP菜鸟入门不完全指南</title>
    <link href="https://github.com/ChangerHe/2017/07/13/PHP%E8%8F%9C%E9%B8%9F%E5%85%A5%E9%97%A8%E7%AC%94%E8%AE%B0/"/>
    <id>https://github.com/ChangerHe/2017/07/13/PHP菜鸟入门笔记/</id>
    <published>2017-07-13T14:05:35.000Z</published>
    <updated>2017-07-15T23:20:07.654Z</updated>
    
    <content type="html"><![CDATA[<p>PHP是作用于服务器端的语言，偏前端的朋友们会称他为后端语言。而专门做后端的朋友们则会说，PHP是一种前端的弱类型语言。<br>当然，这个语言的定位不是最重要的，重要的是，PHP到底是不是最好的语言？</p>
<h1 id="PHP的适用范围"><a href="#PHP的适用范围" class="headerlink" title="PHP的适用范围"></a>PHP的适用范围</h1><h3 id="生成动态页面内容"><a href="#生成动态页面内容" class="headerlink" title="生成动态页面内容"></a>生成动态页面内容</h3><h3 id="创建，打开，读取，写入，删除及关闭服务器上的文件。"><a href="#创建，打开，读取，写入，删除及关闭服务器上的文件。" class="headerlink" title="创建，打开，读取，写入，删除及关闭服务器上的文件。"></a>创建，打开，读取，写入，删除及关闭服务器上的文件。</h3><h3 id="接收表单数据，发送并取回cookies"><a href="#接收表单数据，发送并取回cookies" class="headerlink" title="接收表单数据，发送并取回cookies"></a>接收表单数据，发送并取回cookies</h3><h3 id="添加，删除，修改数据库中的数据"><a href="#添加，删除，修改数据库中的数据" class="headerlink" title="添加，删除，修改数据库中的数据"></a>添加，删除，修改数据库中的数据</h3><h3 id="限制用户访问网站中的某个页面"><a href="#限制用户访问网站中的某个页面" class="headerlink" title="限制用户访问网站中的某个页面"></a>限制用户访问网站中的某个页面</h3><h1 id="PHP结构"><a href="#PHP结构" class="headerlink" title="PHP结构"></a>PHP结构</h1><p>以<code>&lt;?php</code>开头，以 <code>?&gt;</code> 结尾，默认文件扩展名是 <code>.php</code> ,语句不同于javascript，必须要以分号结尾。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">&lt;?php echo &quot;hi&quot;.&quot;changer&quot;; ?&gt;     //hichanger</div><div class="line">//PHP不同于其他语言的以“+”链接两字符串的方式，而是以“.”进行连接。</div></pre></td></tr></table></figure>
<h1 id="PHP基本语法"><a href="#PHP基本语法" class="headerlink" title="PHP基本语法"></a>PHP基本语法</h1><h2 id="变量的定义"><a href="#变量的定义" class="headerlink" title="变量的定义"></a>变量的定义</h2><pre><code>必须以字母或下划线开头，如&quot;$_name&quot;/&quot;$name&quot;/&quot;$name2&quot;等。
变量名只能由字母数字及下划线组成，可以包含汉字，但不推荐这样做。
变量名不允许包含空格，因此当变量名由多个单词组成，建议使用下划线分隔，或者使用驼峰命名法。变量名严格区分大小写。
</code></pre><p>smallTips: 使用memory_get_usage获取当前PHP消耗的内存</p>
<h1 id="PHP标量类型"><a href="#PHP标量类型" class="headerlink" title="PHP标量类型"></a>PHP标量类型</h1><p>布尔类型<br>整型<br>浮点型<br>字符串</p>
<p>smallTips: 当双引号包含变量时，变量会引入，单引号包含变量时，变量不引入。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">$love = &quot;I love you!&quot;;</div><div class="line">$string1 = &quot;Changer , $love&quot;;</div><div class="line">$string2 = &apos;Changer , $love&apos;;</div><div class="line">echo $string1;     //Changer, I love you!</div><div class="line">echo $string2;     //Changer, $love</div></pre></td></tr></table></figure></p>
<p>smallTips: 当字符串很长时，可使用定界符进行表示<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">$string = &lt;&lt;&lt;GOD  </div><div class="line">	//中间放大量内容</div><div class="line">GOD;</div></pre></td></tr></table></figure></p>
<h1 id="PHP特殊类型"><a href="#PHP特殊类型" class="headerlink" title="PHP特殊类型"></a>PHP特殊类型</h1><h2 id="资源"><a href="#资源" class="headerlink" title="资源"></a>资源</h2><p>由专门函数来建立和使用，我们可对资源进行操作（创建，使用，释放），任何资源在不使用时应被及时释放。如果我们忘记释放资源，系统会自动启动垃圾回收机制，在页面执行完毕后回收资源。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">&lt;?php</div><div class="line">	$file = fopen(&quot;f.txt&quot;,&quot;r&quot;);  //打开文件</div><div class="line">	$con = mysql_connect(&quot;localhost&quot;,&quot;root&quot;,&quot;root&quot;);  //链接数据库</div><div class="line">	$img = imagecreate(100,100);   //图形画布</div><div class="line">?&gt;</div></pre></td></tr></table></figure></p>
<h1 id="空类型"><a href="#空类型" class="headerlink" title="空类型"></a>空类型</h1><p>对大小写不敏感，null类型只有一个取值，表示一个变量没有值，当被赋值NULL或未被赋值或被unset()时，变量为NULL。</p>
<p>smalltips: error_reporting(0);    //禁止显示PHP警告提示</p>
<h1 id="PHP常量"><a href="#PHP常量" class="headerlink" title="PHP常量"></a>PHP常量</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">bool define(string $constant_name, mixed $value[,$case_sensitive = true])</div><div class="line">//参数 constant_name: 常量名称，常量命名规则与变量一致，可不带$符号。</div><div class="line">//     value        :常量的值</div><div class="line">//     case_sensitive: (可选项）表示是否对大小写敏感，默认为false，敏感。</div><div class="line">//     string       ：表示字符串类型，mixed表示参数类型可接受为多种不同类型。</div></pre></td></tr></table></figure>
<h1 id="PHP系统常量"><a href="#PHP系统常量" class="headerlink" title="PHP系统常量"></a>PHP系统常量</h1><p>1.<strong>FILE</strong>:指PHP程序文件名，可帮助我们获取当前文静在服务器的物理位置。<br>2.<strong>LINE</strong>:指PHP程序文件行数，可告诉我们当前代码在第几行。<br>3.PHP_VERSION:当前PHP解析器的版本号。<br>4.PHP_OS:执行当前PHP版本的操作系统名称。</p>
<p>smallTips:判断常量是否被定义<br><code>bool defined(string constants_name)</code></p>
<h1 id="PHP赋值运算符"><a href="#PHP赋值运算符" class="headerlink" title="PHP赋值运算符"></a>PHP赋值运算符</h1><p>等号 “=” ：表示把右边表达式的值赋值给左边的运算数，两者为不同内存空间。<br>和符号 “&amp;” : 表示引用赋值，两者相等，引用的是同一块内存空间。</p>
<p>smallTips：在PHP比较时，“！=”和“&lt;&gt;”是等价的，但用数据库时，后者的兼容性更好。</p>
<h1 id="PHP逻辑运算符"><a href="#PHP逻辑运算符" class="headerlink" title="PHP逻辑运算符"></a>PHP逻辑运算符</h1><table>
<thead>
<tr>
<th style="text-align:center">逻辑运算符</th>
<th style="text-align:center">表示的含义</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">$a and $b</td>
<td style="text-align:center">与</td>
</tr>
<tr>
<td style="text-align:center">$a or $b</td>
<td style="text-align:center">或</td>
</tr>
<tr>
<td style="text-align:center">$a xor $b</td>
<td style="text-align:center">异或</td>
</tr>
<tr>
<td style="text-align:center">!$a</td>
<td style="text-align:center">非</td>
</tr>
<tr>
<td style="text-align:center">$a &amp;&amp; $b</td>
<td style="text-align:center">与</td>
</tr>
<tr>
<td style="text-align:center">$a &#124;&#124; $b</td>
<td style="text-align:center">或</td>
</tr>
</tbody>
</table>
<p>smallTips: <code>.rand(1,50);</code>  表示1-50之间的随机数</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;PHP是作用于服务器端的语言，偏前端的朋友们会称他为后端语言。而专门做后端的朋友们则会说，PHP是一种前端的弱类型语言。&lt;br&gt;当然，这个语言的定位不是最重要的，重要的是，PHP到底是不是最好的语言？&lt;/p&gt;
&lt;h1 id=&quot;PHP的适用范围&quot;&gt;&lt;a href=&quot;#PHP的
    
    </summary>
    
      <category term="PHP 学习笔记" scheme="https://github.com/ChangerHe/categories/PHP-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="PHP" scheme="https://github.com/ChangerHe/tags/PHP/"/>
    
  </entry>
  
  <entry>
    <title>JavaScipt中sort()方法的底层原理及妙用</title>
    <link href="https://github.com/ChangerHe/2017/07/12/JavaScipt%E4%B8%ADsort-%E6%96%B9%E6%B3%95%E7%9A%84%E5%BA%95%E5%B1%82%E5%8E%9F%E7%90%86%E5%8F%8A%E5%A6%99%E7%94%A8/"/>
    <id>https://github.com/ChangerHe/2017/07/12/JavaScipt中sort-方法的底层原理及妙用/</id>
    <published>2017-07-12T09:58:29.000Z</published>
    <updated>2017-07-12T10:45:59.923Z</updated>
    
    <content type="html"><![CDATA[<p>众所周知，JavaScript中的sort()方法可对数组进行排序。<br>平时我们使用就是简单的执行一个sort()方法，但是其实这个方法是带有参数的。<br>语法为：<code>arrayObject.sort(sortby);</code><br>其中，参数sortby，必须为函数！这点要注意，之前试过传值的方法一直都不奏效，后面才发现，只能传递一个参数。</p>
<h1 id="未传参情况下的排序"><a href="#未传参情况下的排序" class="headerlink" title="未传参情况下的排序"></a>未传参情况下的排序</h1><p>当没有为该方法传参时，则默认对数组进行从大到小排序，排序的依据是数组中每个元素的首个字符的ASCII码，因此当你想要对数组<code>[2,10,3]</code>排序时，直接排序的结果为<code>[10,2,3]</code>，因为在sort()的底层，比较时会自动为数组中的值进行toString()方法的转换，比较时比较的是字符。</p>
<h1 id="传参情况下的排序"><a href="#传参情况下的排序" class="headerlink" title="传参情况下的排序"></a>传参情况下的排序</h1><p>JS高程中介绍了传递比较函数的方法。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">var a = [10,3,12];</div><div class="line">  var line = function(a,b)&#123;</div><div class="line">    return b -a;</div><div class="line">  &#125;</div><div class="line"> a.sort(line)</div><div class="line"> console.log(a)   //3,10,12</div></pre></td></tr></table></figure></p>
<p> 但是有个问题，这个数东西就只能针对数组额，但是如果我想要对数组对象进行排序呢？<br> 其实方法类似，万变不离其宗。如下：<br> <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"> var arr = [</div><div class="line">	&#123;name: &quot;aaa&quot;, age: 0&#125;,</div><div class="line">	&#123;name: &quot;bbb&quot;, age: 18&#125;,</div><div class="line">	&#123;name: &quot;ccc&quot;, age: 8&#125;</div><div class="line"> ];</div><div class="line">function compare(property)&#123;</div><div class="line">	return function(a,b)&#123;</div><div class="line">		var value1 = a[property];  //获取a的</div><div class="line">		var value2 = b[property];</div><div class="line">		return value1 - value2;</div><div class="line">	&#125;</div><div class="line">&#125;</div><div class="line">console.log(arr.sort(compare(&apos;age&apos;)));</div></pre></td></tr></table></figure></p>
<h1 id="逆向排序"><a href="#逆向排序" class="headerlink" title="逆向排序"></a>逆向排序</h1><p>那么问题来了，如果都是从小到大排序，那就不好玩了，能不能有办法在不使用reverse()方法的情况下，实现增加一个参数，来决定他们是从大到小排序，还是从小到大排序呢？<br>当然问题还是有解决方案的。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line">sortBy:function(attr,rev)&#123;</div><div class="line">	if(rev == undefined)&#123;</div><div class="line">		rev = 1;    //当未传递参数时，默认为从小到大排序，即undefined时，为1</div><div class="line">	&#125;else&#123;</div><div class="line">		rev = (rev)? 1 : -1;</div><div class="line">	&#125;</div><div class="line">	return function(a,b)&#123;</div><div class="line">		a = a[attr]</div><div class="line">		b = b[attr]</div><div class="line">		if(a &lt; b)&#123;</div><div class="line">			return rev * -1;</div><div class="line">		&#125; else if(a = b)&#123;</div><div class="line">			return 0;</div><div class="line">		&#125; else &#123;</div><div class="line">			return 1;</div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">someArray.sort(sortBy(&quot;number&quot;,false));</div></pre></td></tr></table></figure></p>
<h1 id="底层原理"><a href="#底层原理" class="headerlink" title="底层原理"></a>底层原理</h1><p>以上是研究出的部分结果，但是对sort()的底层排序机制，还是不太理解，到底是用的冒泡排序，还是堆排序，还是更牛逼的高级算法？这就不得而知了，这里引用一下segmenfault上大神们的解释：<br>不同的浏览器，对sort()方法的实现机制是不同的。<br>Mozilla、Firefox这两个浏览器是使用的<code>归并排序</code>方法。使用V8引擎，对数组长度小于等于22的用插入排序，其他的使用快速排序。<br>webkit这个浏览器底层使用了C++库中的qsort()方法。<br>```</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;众所周知，JavaScript中的sort()方法可对数组进行排序。&lt;br&gt;平时我们使用就是简单的执行一个sort()方法，但是其实这个方法是带有参数的。&lt;br&gt;语法为：&lt;code&gt;arrayObject.sort(sortby);&lt;/code&gt;&lt;br&gt;其中，参数sortb
    
    </summary>
    
      <category term="JavaScript 学习笔记" scheme="https://github.com/ChangerHe/categories/JavaScript-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="JavaScript" scheme="https://github.com/ChangerHe/tags/JavaScript/"/>
    
  </entry>
  
  <entry>
    <title>XML学习笔记</title>
    <link href="https://github.com/ChangerHe/2017/07/09/XML%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    <id>https://github.com/ChangerHe/2017/07/09/XML学习笔记/</id>
    <published>2017-07-09T15:29:15.000Z</published>
    <updated>2017-07-09T18:06:27.099Z</updated>
    
    <content type="html"><![CDATA[<h1 id="XML-HTML-XHTML-DHTML的相互关系"><a href="#XML-HTML-XHTML-DHTML的相互关系" class="headerlink" title="XML/HTML/XHTML/DHTML的相互关系"></a>XML/HTML/XHTML/DHTML的相互关系</h1><p>XML(Extensible Markup Language)可扩展标记语言，和HTML类似，都是一种标记语言，还有类似的标记语言有：DHTML和XHTML，先来捋一捋他们的关系：</p>
<h2 id="HTML（HyperText-Markup-Language）"><a href="#HTML（HyperText-Markup-Language）" class="headerlink" title="HTML（HyperText Markup Language）"></a>HTML（HyperText Markup Language）</h2><p>这个不必多说，网络的通用语言，随着网络的盛行，大行其道。本身是一种文本文件，通过在文本文件中添加标记符来告诉浏览器显示什么内容。因为最初的标准不完善，经过长时间的演化，现在是一个基本上已经算是完全固定的HTML5版本。<br>HTML因为之前的不断向下兼容，导致结构不够严谨而备受诟病，因此之后一些搞事的程序猿们开始构思一个结构更加严谨的文档标记语言，这个时候XHTML应运而生了。</p>
<h2 id="XHTML（Extensible-HyperText-Markup-Language）"><a href="#XHTML（Extensible-HyperText-Markup-Language）" class="headerlink" title="XHTML（Extensible HyperText Markup Language）"></a>XHTML（Extensible HyperText Markup Language）</h2><p>先看一下百度百科上对XHTML的解释<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">可扩展超文本标记语言，是一种置标语言，表现方式与超文本标记语言（HTML）类似，不过语法上更加严格。</div></pre></td></tr></table></figure></p>
<p>其实就严谨性来说，XHTML确实相比于HTML严谨了很多，但是随之也产生了跨平台的兼容性问题和无法向下兼容的问题。因此XHTML逐渐被淘汰，只有一些很老的公司在使用这个技术。</p>
<h2 id="DHTML（Dynamic-HTML）"><a href="#DHTML（Dynamic-HTML）" class="headerlink" title="DHTML（Dynamic HTML）"></a>DHTML（Dynamic HTML）</h2><p>DHTML其实相当于HTML加上CSS加上JS，因为DHTML是“动态的”HTML。</p>
<h2 id="XML-Extensible-Markup-Language"><a href="#XML-Extensible-Markup-Language" class="headerlink" title="XML(Extensible Markup Language)"></a>XML(Extensible Markup Language)</h2><p>下面就是我们的主角登场了，因为考虑到数据的严谨性和可调用性，同时要保证能够和前台的HTML进行成功的交互，此时XML就应运而生了（其实XML比XHTML诞生的早很多，在1998年就成为了W3C的推荐标准），XML是各种应用程序之间进行数据传输最常用的工具。</p>
<h1 id="XML的语法"><a href="#XML的语法" class="headerlink" title="XML的语法"></a>XML的语法</h1><h2 id="语法注意事项"><a href="#语法注意事项" class="headerlink" title="语法注意事项"></a>语法注意事项</h2><p>1.空元素标签都必须用“/”来关闭，如：  <code>&lt;br/&gt;</code><br>2.所有标签都区分大小写。<br>3.必须严格嵌套。<br>4.所有标签的属性都必须用引号括起来。<br>5.XML有且只有一个根元素。</p>
<h2 id="XML声明"><a href="#XML声明" class="headerlink" title="XML声明"></a>XML声明</h2><p>&lt;?xml 版本信息[编码信息][文档独立性信息]?&gt;<br>如： <code>&lt;?xml version=&quot;1.0&quot;?&gt;</code><br>注：xml文档声明必须放到文档第一行，且前方不能又任何字符。</p>
<h2 id="文档类型声明（DTD）"><a href="#文档类型声明（DTD）" class="headerlink" title="文档类型声明（DTD）"></a>文档类型声明（DTD）</h2><h3 id="命名规范"><a href="#命名规范" class="headerlink" title="命名规范"></a>命名规范</h3><p>1.只能以字母，下划线，或冒号开头。<br>2.不能包含空格。<br>3.名称中尽量不使用冒号，否则可能出现解析问题。<br>4.字符中不能有 <code>&amp;</code> 和 <code>&lt;</code> 以及 <code>]]&gt;</code> 标签，否则会被理解为标记的起始和结束定界符。</p>
<h3 id="字符引用"><a href="#字符引用" class="headerlink" title="字符引用"></a>字符引用</h3><p>有些地方必须要用字符时，可用字符的实体或者字符的进制码代替</p>
<table>
<thead>
<tr>
<th style="text-align:center">字符</th>
<th style="text-align:center">字符引用（十进制）</th>
<th style="text-align:center">字符引用（十六进制）</th>
<th style="text-align:center">预定义实体引用</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">&lt;</td>
<td style="text-align:center">&amp;#60;</td>
<td style="text-align:center">&amp;#x3c;</td>
<td style="text-align:center">&amp;lt;</td>
</tr>
<tr>
<td style="text-align:center">&gt;</td>
<td style="text-align:center">&amp;#62;</td>
<td style="text-align:center">&amp;#x3e;</td>
<td style="text-align:center">&amp;gt;</td>
</tr>
<tr>
<td style="text-align:center">“</td>
<td style="text-align:center">&amp;#34;</td>
<td style="text-align:center">&amp;#x22;</td>
<td style="text-align:center">&amp;quot;</td>
</tr>
<tr>
<td style="text-align:center">‘</td>
<td style="text-align:center">&amp;#39;</td>
<td style="text-align:center">&amp;#x27;</td>
<td style="text-align:center">&amp;apos;</td>
</tr>
<tr>
<td style="text-align:center">&amp;</td>
<td style="text-align:center">&amp;#38;</td>
<td style="text-align:center">&amp;#x26;</td>
<td style="text-align:center">&amp;amp;</td>
</tr>
</tbody>
</table>
<h3 id="CDATA字段"><a href="#CDATA字段" class="headerlink" title="CDATA字段"></a>CDATA字段</h3><p>其内容不被XML处理器解析，所以可以包含任意字符。但是不能有 <code>&amp;</code> 和 <code>&lt;</code> 以及 <code>]]&gt;</code> ，相当于引用了其中的内容，而该内容不被解析。<br>格式：<code>&lt;![CDATA[ 任何不想被解析的内容 ]]&gt;</code></p>
<h3 id="引用"><a href="#引用" class="headerlink" title="引用"></a>引用</h3><p>引用css格式：<code>&lt;?xml-stylesheet href=&quot;hello.css&quot; type=&quot;text/css&quot;?&gt;</code><br>引用外部DTD格式：<code>&lt;!DOCTYPE greeting SYSTEM &quot;hello.dtd&quot;&gt;</code><br>直接写在xml文档内的DTD：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">&lt;!DOCTYPE greeting [</div><div class="line">	&lt;!ELEMENT greeting (#PCDATA)&gt;</div><div class="line">]&gt;</div></pre></td></tr></table></figure></p>
<p>不过，对于css而言，对xml其实并不特别合适，XML的首选样式语言是XSLT (eXtensible Stylesheet Language Transformations)<br>其引用方式与css类似：<br><code>&lt;?xml-stylesheet type=&quot;text/xsl&quot; href=&quot;simple.xsl&quot;?&gt;</code><br>注：<br><code>PCDATA</code>:被解析的字符数据<br><code>CDATA</code>:不会被解析器解析的文本</p>
<h2 id="属性声明"><a href="#属性声明" class="headerlink" title="属性声明"></a>属性声明</h2><p>属性通过ATTLIST来进行声明<br>格式：<code>&lt;!ATTLIST 元素名称 属性名称 属性类型 默认值&gt;</code><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">&lt;!ATTLIST payment type CDATA &quot;check&quot;&gt;</div><div class="line">&lt;payment type=&quot;check&quot;/&gt;</div></pre></td></tr></table></figure></p>
<h1 id="XML-HTTP-Request"><a href="#XML-HTTP-Request" class="headerlink" title="XML HTTP Request"></a>XML HTTP Request</h1><p>讲了半天XML的杂七杂八，其实这玩意儿才是正主。<br>XMLHttpRequest 对象用于在后台与服务器交换数据。也就是有了他，AJAX,JSON,XMLHttpRequest对象之流才能正常工作起来，实现数据的交换和同步异步传输。<br>语法如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line">&lt;script&gt;</div><div class="line">var xmlhttp=new XMLHttpRequest();   </div><div class="line">//新定义一个XMLHttpRequest对象</div><div class="line">xmlhttp.onreadystatechange = state_Change; </div><div class="line">//onreadystatechange 是一个事件句柄。它的值 (state_Change) 是一个函数的名称</div><div class="line">//当 XMLHttpRequest 对象的状态发生改变时，会触发此函数。</div><div class="line">xmlhttp.open(&quot;GET&quot;,url,true);</div><div class="line">//参数提交方式为GET，参数指向一个url，参数为异步请求（true）</div><div class="line">xmlhttp.send(null);</div><div class="line">//send()方法仅在使用POST传参时使用，故设定为null</div><div class="line">function state_Change()&#123;</div><div class="line">	if(xmlhttp.readyState == 4)&#123;   //4表示已装载</div><div class="line">		if(xmlhttp.status == 200)&#123;  //200表示http请求执行成功</div><div class="line">			//此处可执行代码</div><div class="line">		&#125; else &#123;</div><div class="line">			console.log(&quot;服务器发生错误&quot;)</div><div class="line">		&#125;</div><div class="line">	&#125; else  &#123;</div><div class="line">		consolg.log(&quot;未成功装载&quot;)</div><div class="line">	&#125;</div><div class="line">&#125;</div><div class="line">&lt;/script&gt;</div></pre></td></tr></table></figure></p>
]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;XML-HTML-XHTML-DHTML的相互关系&quot;&gt;&lt;a href=&quot;#XML-HTML-XHTML-DHTML的相互关系&quot; class=&quot;headerlink&quot; title=&quot;XML/HTML/XHTML/DHTML的相互关系&quot;&gt;&lt;/a&gt;XML/HTML/XH
    
    </summary>
    
      <category term="XML 学习笔记" scheme="https://github.com/ChangerHe/categories/XML-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="XML" scheme="https://github.com/ChangerHe/tags/XML/"/>
    
  </entry>
  
  <entry>
    <title>JavaScript高级程序设计复习笔记（三）</title>
    <link href="https://github.com/ChangerHe/2017/07/08/JavaScript%E9%AB%98%E7%BA%A7%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E5%A4%8D%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%88%E4%B8%89%EF%BC%89/"/>
    <id>https://github.com/ChangerHe/2017/07/08/JavaScript高级程序设计复习笔记（三）/</id>
    <published>2017-07-08T12:20:09.000Z</published>
    <updated>2017-07-08T12:41:30.925Z</updated>
    
    <content type="html"><![CDATA[<p>昨天看了一遍javascript的面向对象，感觉javascript的面向对象比java难懂很多啊，主要还是原型链继承这块的东西。<br>本篇内容主要讲在学习javascript中很容易搞不清楚的call()方法和apply()方法。</p>
<h1 id="apply和call的区别在哪里"><a href="#apply和call的区别在哪里" class="headerlink" title="apply和call的区别在哪里"></a>apply和call的区别在哪里</h1><p>apply:方法能劫持另外一个对象的方法，继承另外一个对象的属性.<br>Function.apply(obj,args)方法能接收两个参数<br>obj：这个对象将代替Function类里this对象<br>args：这个是数组，它将作为参数传给Function（args–&gt;arguments）<br>call:和apply的意思一样,只不过是参数列表不一样.<br>Function.call(obj,[param1[,param2[,…[,paramN]]]])<br>obj：这个对象将代替Function类里this对象<br>params：这个是一个参数列表<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">/*定义一个人类*/  </div><div class="line">function Person(name,age)  </div><div class="line">    &#123;  </div><div class="line">        this.name=name;  </div><div class="line">        this.age=age;  </div><div class="line">    &#125;  </div><div class="line">/*定义一个学生类*/  </div><div class="line">functionStudent(name,age,grade)  </div><div class="line">    &#123;  </div><div class="line">        Person.apply(this,arguments);  </div><div class="line">        this.grade=grade;  </div><div class="line">    &#125;  </div><div class="line">//创建一个学生类  </div><div class="line">var student=new Student(&quot;zhangsan&quot;,21,&quot;一年级&quot;);  </div><div class="line">//测试  </div><div class="line">alert(&quot;name:&quot;+student.name+&quot;\n&quot;+&quot;age:&quot;+student.age+&quot;\n&quot;+&quot;grade:&quot;+student.grade);</div></pre></td></tr></table></figure></p>
<p>大家可以看到测试结果name:zhangsan age:21  grade:一年级<br>学生类里面我没有给name和age属性赋值啊,为什么又存在这两个属性的值呢,这个就是apply的神奇之处.<br>分析: Person.apply(this,arguments);<br>this:在创建对象在这个时候代表的是student<br>arguments:是一个数组,也就是[“zhangsan”,”21”,”一年级”];<br>也就是通俗一点讲就是:用student去执行Person这个类里面的内容,在Person这个类里面存在this.name等之类的语句,这样就将属性创建到了student对象里面。</p>
<h1 id="什么情况下用apply-什么情况下用call"><a href="#什么情况下用apply-什么情况下用call" class="headerlink" title="什么情况下用apply,什么情况下用call"></a>什么情况下用apply,什么情况下用call</h1><p>在给对象参数的情况下,如果参数的形式是数组的时候,比如apply示例里面传递了参数arguments,这个参数是数组类型,并且在调用Person的时候参数的列表是对应一致的(也就是Person和Student的参数列表前两位是一致的) 就可以采用 apply , 如果我的Person的参数列表是这样的(age,name),而Student的参数列表是(name,age,grade),这样就可以用call来实现了,也就是直接指定参数列表对应值的位置(Person.call(this,age,name,grade));</p>
<h1 id="Function-apply-在提升程序性能方面的技巧"><a href="#Function-apply-在提升程序性能方面的技巧" class="headerlink" title="Function.apply()在提升程序性能方面的技巧"></a>Function.apply()在提升程序性能方面的技巧</h1><p>我们先从 Math.max() 函数说起，  Math.max后面可以接任意个参数，最后返回所有参数中的最大值。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">alert(Math.max(5,8))   //8</div><div class="line">alert(Math.max(5,7,9,3,1,6))   //9</div></pre></td></tr></table></figure></p>
<p>但是在很多情况下，我们需要找出数组中最大的元素。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">var arr=[5,7,9,1]</div><div class="line">alert(Math.max(arr))</div></pre></td></tr></table></figure></p>
<p>这样却是不行的。一定要这样写<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">function getMax(arr)&#123;</div><div class="line">    var arrLen=arr.length;</div><div class="line">    for(var i=0,ret=arr[0];i&lt;arrLen;i++)&#123;</div><div class="line">        ret=Math.max(ret,arr[i]);        </div><div class="line">    &#125;</div><div class="line">    return ret;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>这样写麻烦而且低效。如果用 apply呢，看代码：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">function getMax2(arr)&#123;</div><div class="line">    return Math.max.apply(null,arr)</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>两段代码达到了同样的目的，但是getMax2却优雅，高效，简洁得多。</p>
<p>看性能测试:<br>getMax性能测试<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div></pre></td><td class="code"><pre><div class="line">&lt;script&gt;</div><div class="line">var myArr=new Array()</div><div class="line"></div><div class="line">function fillRnd(arrLen)&#123;  //填入 arrLen个1-10的随机数字到数组</div><div class="line">    for(var i=0,arr=[];i&lt;arrLen;i++)&#123;</div><div class="line">        arr[i]=Math.ceil(Math.random()*10)</div><div class="line">    &#125;</div><div class="line">    return arr</div><div class="line">&#125;</div><div class="line"></div><div class="line">function getMax(arr)&#123;</div><div class="line">    var arrLen=arr.length;</div><div class="line">    for(var i=0,ret=arr[0];i&lt;arrLen;i++)&#123;</div><div class="line">        ret=Math.max(ret,arr[i]);        </div><div class="line">    &#125;</div><div class="line">    return ret;</div><div class="line">&#125;</div><div class="line"></div><div class="line">function getMax2(arr)&#123;</div><div class="line">    return Math.max.apply(null,arr)</div><div class="line">&#125;</div><div class="line"></div><div class="line"></div><div class="line">myArr=fillRnd(20*10000)  //生成20万个随机数填到数组</div><div class="line"></div><div class="line">var t1=new Date()</div><div class="line">var max1=getMax(myArr)</div><div class="line">var t2=new Date()</div><div class="line">var max2=getMax2(myArr)</div><div class="line">var t3=new Date()</div><div class="line"></div><div class="line">if (max1!==max2) alert(&quot;error&quot;)</div><div class="line">alert([t3-t2,t2-t1])   //在我机器上 96,464 .不同的机器,结果可能有差异</div><div class="line"></div><div class="line">&lt;/script&gt;</div></pre></td></tr></table></figure></p>
<p>通过20万个数据的比较， getMax2 时间为 96ms 而 getmax时间为464。 两者相差5倍</p>
<p> 再比如数组的push方法。<br><code>var arr1=[1,3,4];</code><br><code>var arr2=[3,4,5];</code><br>如果我们要把 arr2展开，然后一个一个追加到 <code>arr1</code>中去，最后让  <code>arr1=[1,3,4,3,4,5]</code><br><code>arr1.push(arr2)</code>  显然是不行的。 因为这样做会得到  <code>[1,3,4, [3,4,5] ]</code></p>
<p>我们只能用一个循环去一个一个的<code>push</code>当然也可以用 <code>arr1.concat(arr2)</code> 但是<code>concat</code>方法并不改变 arr1本身<br>自从有了 Apply    ,事情就变得如此简单<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">Array.prototype.push.apply(arr1,arr2)</div></pre></td></tr></table></figure></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;昨天看了一遍javascript的面向对象，感觉javascript的面向对象比java难懂很多啊，主要还是原型链继承这块的东西。&lt;br&gt;本篇内容主要讲在学习javascript中很容易搞不清楚的call()方法和apply()方法。&lt;/p&gt;
&lt;h1 id=&quot;apply和c
    
    </summary>
    
      <category term="JavaScript 学习笔记" scheme="https://github.com/ChangerHe/categories/JavaScript-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="JavaScript" scheme="https://github.com/ChangerHe/tags/JavaScript/"/>
    
  </entry>
  
  <entry>
    <title>JavaScript高级程序设计复习笔记（二）</title>
    <link href="https://github.com/ChangerHe/2017/07/07/JavaScript%E9%AB%98%E7%BA%A7%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E5%A4%8D%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%88%E4%BA%8C%EF%BC%89/"/>
    <id>https://github.com/ChangerHe/2017/07/07/JavaScript高级程序设计复习笔记（二）/</id>
    <published>2017-07-07T12:53:14.000Z</published>
    <updated>2017-07-07T14:58:23.633Z</updated>
    
    <content type="html"><![CDATA[<h3 id="Array类型的数组数量问题"><a href="#Array类型的数组数量问题" class="headerlink" title="Array类型的数组数量问题"></a>Array类型的数组数量问题</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">var ar = [,,,];</div><div class="line">console.log(arr.length);   //3（最后一个逗号后面不计数）</div></pre></td></tr></table></figure>
<p>小技巧，利用length在数组的末尾添加新项<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">var colors = [&quot;red&quot;,&quot;blue&quot;];</div><div class="line">colors[color.length] = &quot;black&quot;;</div></pre></td></tr></table></figure></p>
<h3 id="join-方法用于给数组提供分隔符以构建字符串"><a href="#join-方法用于给数组提供分隔符以构建字符串" class="headerlink" title="join()方法用于给数组提供分隔符以构建字符串"></a>join()方法用于给数组提供分隔符以构建字符串</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">var colors = [&quot;red&quot;,&quot;green&quot;];</div><div class="line">console.log(colors.join(&quot;||&quot;));</div><div class="line">//输出 red||green，当直接调用join()时，使用默认的“，”分隔。</div></pre></td></tr></table></figure>
<h3 id="栈方法（LIFO-后进先出；队列方法-FIFO-先进先出"><a href="#栈方法（LIFO-后进先出；队列方法-FIFO-先进先出" class="headerlink" title="栈方法（LIFO):后进先出；队列方法(FIFO):先进先出"></a>栈方法（LIFO):后进先出；队列方法(FIFO):先进先出</h3><p>方法类比：</p>
<table>
<thead>
<tr>
<th style="text-align:center">方法名称</th>
<th style="text-align:center">方法作用</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">push()</td>
<td style="text-align:center">从数组后方依次添加</td>
</tr>
<tr>
<td style="text-align:center">unshift()</td>
<td style="text-align:center">从数组前方依次添加</td>
</tr>
<tr>
<td style="text-align:center">pop()</td>
<td style="text-align:center">从数组后方删除最后一个，并返回被删除值</td>
</tr>
<tr>
<td style="text-align:center">shift()</td>
<td style="text-align:center">从数组前删除第一个，并返回第一个被删除的值</td>
</tr>
</tbody>
</table>
<h3 id="重排序方法"><a href="#重排序方法" class="headerlink" title="重排序方法"></a>重排序方法</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">var values = [0,1,2,10,15];</div><div class="line">values.sort();</div><div class="line">console.log(values); //0,1,10,15,2</div></pre></td></tr></table></figure>
<p>原因：排序时sort将所有数组值均转化为字符串值再拍讯。<br>解决方法：新建一个compare()方法进行比较<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">function compare(value1,value2)&#123;</div><div class="line">	if(value1 &lt; value2)&#123;</div><div class="line">		return -1;</div><div class="line">	&#125; else if (value1 &gt; value2)&#123;</div><div class="line">		return 1;</div><div class="line">	&#125; else &#123;</div><div class="line">		return 0;</div><div class="line">	&#125;</div><div class="line">	</div><div class="line">&#125;</div><div class="line">var values = [0,1,5,10,15];</div><div class="line">values.sort(compare);</div><div class="line">console.log(values);   //0,1,5,10,15</div></pre></td></tr></table></figure></p>
<h3 id="操作方法"><a href="#操作方法" class="headerlink" title="操作方法"></a>操作方法</h3><p>concat():链接两数组，若不传递参数，则只复制一份，不会额外向原数组增加内容。<br>slice():复制当前数组，参数为开始和结束位置。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">var arr = [1,2,3,4,5];</div><div class="line">var arr1 = arr.slice(1);</div><div class="line">console.log(arr1);  //2,3,4,5</div><div class="line">var arr2 = arr.slice(1,4);</div><div class="line">console.log(arr2);  //2,3,4</div></pre></td></tr></table></figure></p>
<p>注：当slice传参为负时，则要加上数组长度，以得到正确结果。<br>splice()：有删除，插入，替换三个作用<br>    删除：splice（要删除的第一项，删除的项数）；<br>    插入：splice（起始位置，0，要插入的项）；<br>    替换：splice（起始位置，要删除的项，要替换的项）；</p>
<h3 id="迭代方法"><a href="#迭代方法" class="headerlink" title="迭代方法"></a>迭代方法</h3><pre><code>every():为数组每一次运行给定函数，每一项为true，则返回true。
fliter():为数组的每一项执行给定函数，返回true项组成的数组。
forEach():每一项执行函数，无返回值。
map():为每一项执行函数，返回每次调用结果组成的数组。
some():为每一项执行函数，任意项返回true，则返回true。
</code></pre><h3 id="归并方法"><a href="#归并方法" class="headerlink" title="归并方法"></a>归并方法</h3><pre><code>reduce():迭代数组所有项，构建一个最终返回值。
reduceRight():迭代数组所有项，从最后一个数开始。
</code></pre><h3 id="函数声明提升"><a href="#函数声明提升" class="headerlink" title="函数声明提升"></a>函数声明提升</h3><p>解析器会在代码执行前进行一个函数声明提升的过程，读取并将函数声明添加到执行环境中。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">console.log(num1(1,2));   //3</div><div class="line">console.log(num2(1,2));   //报错</div><div class="line">function num1(m , n)&#123;</div><div class="line">	return m + n;</div><div class="line">&#125;</div><div class="line">num2 = function(m , n)&#123;</div><div class="line">	return m + n;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>注：要访问函数的指针而不执行函数，则需要在调用时去掉函数的圆括号进行调用。</p>
<h3 id="使用arguments-callee-消除紧密耦合"><a href="#使用arguments-callee-消除紧密耦合" class="headerlink" title="使用arguments.callee()消除紧密耦合"></a>使用arguments.callee()消除紧密耦合</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">//这是一个普通的递归函数</div><div class="line">function factioral(num)&#123;</div><div class="line">	if(num &lt;= 1)&#123;</div><div class="line">		return 1;</div><div class="line">	&#125; else &#123;</div><div class="line">		return num*arguments.callee(num - 1);</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="函数的prototype属性"><a href="#函数的prototype属性" class="headerlink" title="函数的prototype属性"></a>函数的prototype属性</h3><p>对于所有属性，prototype属性时保存他们的所有实例方法的真正所在，prototype属性包含两个非继承来的方法：apply()和call()。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">function sum(num1,num2)&#123;</div><div class="line">	return num1 + num2;</div><div class="line">&#125;</div><div class="line">function callSum1(num1,num2)&#123;</div><div class="line">	return sum.apply(this.arguments);  //传入arguments对象</div><div class="line">&#125;</div><div class="line">function callSum2(num1,num2)&#123;</div><div class="line">	return sum.apply(this,[num1,num2]); //传入数组</div><div class="line">&#125;</div><div class="line">function callSum3(num1,num2)&#123;</div><div class="line">	return sum.call(this,num1,num2);</div><div class="line">&#125;</div><div class="line">console.log(callSum1(10,10));  //20</div><div class="line">console.log(callSum2(10,10));  //20</div><div class="line">console.log(callSum3(10,10));  //20</div></pre></td></tr></table></figure></p>
<p>call和apply的作用相同，当包含函数中接受数组时，apply更加合适。<br>apply和call的最大用处，是可扩充函数赖以执行的作用域7.<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">window.color = &quot;red&quot;;</div><div class="line">var o = &#123;color : &quot;blue&quot;&#125;;</div><div class="line">function sayColor()&#123;</div><div class="line">	alert(this.color);</div><div class="line">&#125;</div><div class="line">sayColor();   //red</div><div class="line">sayColor(o);  //blue</div><div class="line">sayColor(window); //red</div></pre></td></tr></table></figure></p>
<h3 id="基本包装类"><a href="#基本包装类" class="headerlink" title="基本包装类"></a>基本包装类</h3><p>基本包装类的自用创建的引用类型实例，会在代码执行后立即销毁。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">var s1 = &quot;some test&quot;;</div><div class="line">s1.color = &quot;red&quot;;</div><div class="line">colsole.log(s1.color);   //undefined</div></pre></td></tr></table></figure></p>
<p>注：直接使用转型函数，则返回相应结果。使用构造函数，则返回相应函数的实例。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">var value = &quot;25&quot;;</div><div class="line">var number = Number(value);   //使用转型函数</div><div class="line">console.log(typeof number);  //number</div><div class="line">var obj = new Number(value);   //使用构造函数</div><div class="line">console.log(typeof obj);   //Object</div></pre></td></tr></table></figure></p>
<p>注：new会创造一个object对象，new Boolean(false)可判定为true。</p>
<h3 id="数值类型的转换"><a href="#数值类型的转换" class="headerlink" title="数值类型的转换"></a>数值类型的转换</h3><p>.toFixed(n):表示转换为几位小数的值。<br>.toExponential(n):表示转换为几位指数值<br>.toPreoision(n):表示转换为n位最合适的数<br>.charAt():输出当前字符串的第n位字符（从0开始）<br>.charCodeAt():输出当前字符串的第n位字符的ASCII码<br>.trim():删除前缀和后缀的空格，并返回结果<br>.toLowerCase():转换为小写<br>.toUpperCase():转换为大写<br>.match():查找字符串相匹配的位置（search()）的作用相同<br>.replace():传递两个参数，用后面的参数替换前面的参数<br>.localeCompare():比较，返回-1,0,1的其中一种<br>.fromCharCode():接收字符编码，转换为字符串<br>.eval():相当于一个独立解析器，在其中创建任何变量或函数都不会被提升</p>
<h3 id="typrof-和instanceof-得到的结果不同-如下："><a href="#typrof-和instanceof-得到的结果不同-如下：" class="headerlink" title="typrof()和instanceof()得到的结果不同,如下："></a>typrof()和instanceof()得到的结果不同,如下：</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">var numberObject = new Number(10);</div><div class="line">var numberValue = 10;</div><div class="line">console.log(typeof numberObject);  //Object</div><div class="line">console.log(typeof numberValue);   //number</div><div class="line">console.log(numberObject instanceof Number);  //true</div><div class="line">console.log(numberValue instanceof Number); //false</div></pre></td></tr></table></figure>
<h1 id="面向对象"><a href="#面向对象" class="headerlink" title="面向对象"></a>面向对象</h1><h3 id="数据属性"><a href="#数据属性" class="headerlink" title="数据属性"></a>数据属性</h3><p>configurable:表示能否通过delete删除属性从而重新定义属性，默认为true。<br>enumerable:表示能否通过for-in循环返回属性，默认为true。<br>writable：表示能否修改属性值，默认为true。<br>value：表示包含这个属性的数据值，默认为undefined。<br>以上的属性，可以通过` Object.defineProperty()方法进行修改。但是一旦属性定义为不可配置，再调用该方法修改除writable以外的属性，都会导致错误。定义多个属性，可用Object.defineProperties()。<br>Object.getOwnPropertyDescriptor()方法，可取得给定属性的描述符。</p>
<h3 id="访问器属性"><a href="#访问器属性" class="headerlink" title="访问器属性"></a>访问器属性</h3><p>访问器属性不包含属性值，但包含一对getter和setter函数，读取时调用getter，写入时调用setter。<br>注：在某参数前加“_”表示该参数只能通过对象方法访问。</p>
<h2 id="工厂模式"><a href="#工厂模式" class="headerlink" title="工厂模式"></a>工厂模式</h2><p>抽象了创建具体对象的过程，用函数来封装以特定接口创建对象的细节。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">function createPerson(name,age,job)&#123;</div><div class="line">	var o = new Object();</div><div class="line">	o.name = name;</div><div class="line">	o.age  = age;</div><div class="line">	o.job  = job;</div><div class="line">	o.sayName = function()&#123;</div><div class="line">		alert(this.name);</div><div class="line">	&#125;</div><div class="line">	return o;</div><div class="line">&#125;</div><div class="line">var person1 = createPerson(&quot;changer&quot;,18,&quot;Engineer&quot;);</div></pre></td></tr></table></figure></p>
<p>函数createPerson()能够根据接受的参数来构建一个包含所有必要信息的person对象，可无数次调用，工厂模式虽然解决了多个相似对象的问题，却没有解决对象识别的问题。</p>
<h2 id="构造函数模式"><a href="#构造函数模式" class="headerlink" title="构造函数模式"></a>构造函数模式</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">function Person(name,age,job)&#123;</div><div class="line">	this.name = name;</div><div class="line">	this.age = age;</div><div class="line">	this.job = job;</div><div class="line">	this.sayName = function()&#123;</div><div class="line">		alert(this.name);</div><div class="line">	&#125;</div><div class="line">&#125;</div><div class="line">var person1 = Person(&quot;changer&quot;,&quot;18,&quot;Engineer&quot;);</div></pre></td></tr></table></figure>
<p>构造函数始终都应以一个大写字母开头，非构造函数应以小写字母开头。构造函数的实例都有constructor()属性，该属性指向Person。<br>构造函数的缺点：每个方法都要在每个实例上重新创建一遍，因此可将函数定义转移到函数外面以解决问题：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">function Person(name,age,job)&#123;</div><div class="line">	this.name = name;</div><div class="line">	this.age = age;</div><div class="line">	this.job = job;</div><div class="line">&#125;</div><div class="line">function sayName()&#123;</div><div class="line">		alert(this.name);</div><div class="line">&#125;</div><div class="line">var person1 = Person(&quot;changer&quot;,&quot;18,&quot;Engineer&quot;);</div></pre></td></tr></table></figure></p>
<p>以上做法解决了两个函数做同一件事的问题，但是在全局作用域中定义的函数实际上只能被某个对象调用，这让全局作用域名不副实，如果要定义多个方法，全部作为全局变量就毫无封装性可言了。</p>
<h2 id="原型模式"><a href="#原型模式" class="headerlink" title="原型模式"></a>原型模式</h2><p>注：当原型中有某属性而且实例中也有该属性时，原型中的该属性值就用不到了，也无法被检测出来。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">function Person()&#123;&#125;</div><div class="line">Person.prototype = &#123;</div><div class="line">	name : &quot;Nicholas&quot;,</div><div class="line">	age : 29,</div><div class="line">	job : &quot;Software Engineer&quot;,</div><div class="line">	sayName : function()&#123;</div><div class="line">		alert(this.name);</div><div class="line">	&#125;</div><div class="line">&#125;</div><div class="line">var friend = new Person();</div><div class="line">alert(friend instanceof Person);  //true</div><div class="line">alert(friend.constructor == Person);  //false</div></pre></td></tr></table></figure></p>
<p>以上写法完全重写了默认的prototype对象，因此constructor属性也就变成了新对象的constructor属性，指向Object构造函数。<br>在浏览器内核兼容ES5的情况下，可在下面增加：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">Object.defineProperty(Person.prototype,&quot;constructor&quot;,&#123;</div><div class="line">	enumerable : false,</div><div class="line">	value : Person</div><div class="line">&#125;)</div></pre></td></tr></table></figure></p>
<p>该写法改进了在Person.prototype中设置导致enumerable属性被设置为true的问题。<br>但是原型对象还存在问题：省略了构造函数传递初始化参数这一操作，会使所有实例在默认情况下取得相同值。</p>
<h2 id="混成模式"><a href="#混成模式" class="headerlink" title="混成模式"></a>混成模式</h2><p>组合使用了构造函数模式和原型模式，构造函数模式用于定义实例属性，原型模式用于定义方法和共享的属性。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">function Person(name,age,job)&#123;</div><div class="line">	this.name = name;</div><div class="line">	this.age = age;</div><div class="line">	this.job = job;</div><div class="line">	this.friends = [&quot;aa&quot;,&quot;bb&quot;];</div><div class="line">&#125;</div><div class="line">Person.prototype = &#123;</div><div class="line">	constructor : Person;</div><div class="line">	sayName : function()&#123;</div><div class="line">		alert(this.name);</div><div class="line">	&#125;</div><div class="line">&#125;</div><div class="line">var person1 = new Person(&quot;changer&quot;,18,&quot;worker&quot;);</div></pre></td></tr></table></figure></p>
<h2 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h2><p>通过原型链实现继承时，不能使用对象字面量创建原型方法，这样做会重写原型链。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line">function SuperType()&#123;</div><div class="line">	this.property = true;</div><div class="line">&#125;</div><div class="line">SuperType.prototype.getSuperValue = function()&#123;</div><div class="line">	return this.property;</div><div class="line">&#125;</div><div class="line">function SubType()&#123;</div><div class="line">	this.property = false;</div><div class="line">&#125;</div><div class="line">SubType.prototype = new SuperType;</div><div class="line">//为原型使用字面量添加新方法，会使之前的方法无效</div><div class="line">SubType.prototype = &#123;</div><div class="line">	getSubValue : function()&#123;</div><div class="line">		return this.subproperty;</div><div class="line">	&#125;</div><div class="line">	SomeOtherMeshod :funcion()&#123;</div><div class="line">		return false;</div><div class="line">	&#125;</div><div class="line">&#125;</div><div class="line">var instance = new SubType();</div><div class="line">alert(instance.gerSuperValue());  //错误，找不到该方法</div></pre></td></tr></table></figure></p>
<p>原型链的问题：原型链上所有属性都被共享，原型链上的数据可由原型push进行增加。创建子类型的实例时，无法向超类型的构造函数中传递参数。</p>
<h2 id="借用构造函数"><a href="#借用构造函数" class="headerlink" title="借用构造函数"></a>借用构造函数</h2><p>在子类型构造函数的内部调用超类型构造函数<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">function SuperType()&#123;</div><div class="line">	this.colors = [&quot;red&quot;,&quot;blue&quot;,&quot;green&quot;];</div><div class="line">&#125;</div><div class="line">function SubType()&#123;</div><div class="line">	SuperType.call(this);</div><div class="line">&#125;</div><div class="line">var instance1 = new SubType();</div><div class="line">instance1.colors.push(&quot;black&quot;);</div><div class="line">console.log(instance1,colors);  //red,blue,green,black</div><div class="line">var instance2 = new SubType();</div><div class="line">console.log(instance2.colors);  //red,blue,green</div></pre></td></tr></table></figure></p>
<p>由此可见，因为call()方法创造了一个新的SuperType的作用域，使得两个实例在不同的作用域中进行，从而产生了不同的colors结果。</p>
]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;Array类型的数组数量问题&quot;&gt;&lt;a href=&quot;#Array类型的数组数量问题&quot; class=&quot;headerlink&quot; title=&quot;Array类型的数组数量问题&quot;&gt;&lt;/a&gt;Array类型的数组数量问题&lt;/h3&gt;&lt;figure class=&quot;highlight 
    
    </summary>
    
      <category term="JavaScript 学习笔记" scheme="https://github.com/ChangerHe/categories/JavaScript-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="JavaScript" scheme="https://github.com/ChangerHe/tags/JavaScript/"/>
    
  </entry>
  
</feed>
